---
description: Unit and E2E testing patterns for RS School App
globs: **/*.test.ts, **/*.test.tsx, **/*.spec.ts, client/specs/**/*.ts
alwaysApply: false
---

# RS App Testing Patterns

## File Organization

- Unit tests: `{source}.test.ts(x)` next to source file
- E2E tests: `client/specs/*.spec.ts` (Playwright)
- Never use separate `__tests__` directories for new code

## Do's

### Test Structure
- `describe` as noun/situation: `describe('AuthService')`
- `it` should describe behavior: `it('should return null when not found')`
- Group related tests with nested `describe` blocks
- Extract shared setup to `beforeEach`
- Extract shared mock data to reusable constants
- Keep test code DRY

### Test Independence
- Each test must be independent and not rely on others
- Reset mocks and state in `beforeEach`
- Ensure tests are deterministic (no random values)
- Tests should pass in any order

### Assertions
- Assert full object shapes over field-by-field checks
- Use `expect.objectContaining()` for partial matching
- Use `expect.arrayContaining()` when order doesn't matter
- Test both success and error paths
- Test edge cases: empty arrays, null values, boundaries, etc.

### Parameterized Tests
- Use `test.each` for multiple similar test cases

### Async Testing
- Use `await expect().rejects.toThrow()` for error cases
- In React: use `findBy*` for first async query, then `getBy*` for rest
- Keep only ONE assertion inside `waitFor` callback

### Mock Data Typing
```typescript
// ✅ Correct - prefer specific assertion over generic assertion
const mockData = { id: 1, name: 'Test' } as User;

// ❌ Incorrect - generic assertion
const mockData = { ... } as unknown as User;
```

### NestJS Tests
- Use `Test.createTestingModule()` for setup
- Mock repositories via `getRepositoryToken(Entity)`
- Mock services with `jest.fn()` methods

### React Tests
- Use `@testing-library/react` utilities
- Query by role/text over test IDs
- Test user behavior, not implementation

## Don'ts

```typescript
// ❌ Generic test names
it('works', () => {});
it('test 1', () => {});
// ✅ Describe expected behavior
it('should return null when course not found', () => {});
it('should throw ForbiddenException when unauthorized', () => {});

// ❌ Test implementation details
expect(component.state.isLoading).toBe(true);
// ✅ Test observable behavior
expect(screen.getByRole('progressbar')).toBeInTheDocument();

// ❌ Multiple expects inside waitFor
await waitFor(() => {
  expect(a).toBe(1);
  expect(b).toBe(2);
});
// ✅ Single expect, then synchronous queries
await waitFor(() => expect(a).toBe(1));
expect(screen.getByText('loaded')).toBeInTheDocument();

// ❌ Arbitrary timeouts
await new Promise(r => setTimeout(r, 1000));
// ✅ Proper async utilities
await waitFor(() => expect(element).toBeVisible());

// ❌ Shared mutable state without reset
let data = [];
it('test 1', () => { data.push(1); });
it('test 2', () => { /* data is [1]! */ });
// ✅ Reset in beforeEach
beforeEach(() => { data = []; });

// ❌ console.log left in tests
console.log(result);

// ❌ Snapshot tests (avoid unless explicitly needed)
expect(component).toMatchSnapshot();
// ✅ Explicit assertions
expect(component.prop).toBe(expected);
```

## Mock Patterns

```typescript
// Repository mock
{
  provide: getRepositoryToken(Entity),
  useValue: {
    find: jest.fn(),
    findOneBy: jest.fn(),
    findOneOrFail: jest.fn(),
    save: jest.fn(),
    update: jest.fn(),
    delete: jest.fn(),
  },
}

// Parameterized tests
test.each([
  { input: 'a', expected: 1 },
  { input: 'b', expected: 2 },
])('should handle $input correctly', ({ input, expected }) => {
  expect(process(input)).toBe(expected);
});
```
