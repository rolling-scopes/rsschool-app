/* tslint:disable */
/* eslint-disable */
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AlertDto
 */
export interface AlertDto {
    /**
     * 
     * @type {number}
     * @memberof AlertDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof AlertDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof AlertDto
     */
    'text': string;
    /**
     * 
     * @type {boolean}
     * @memberof AlertDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {number}
     * @memberof AlertDto
     */
    'courseId': number;
    /**
     * 
     * @type {string}
     * @memberof AlertDto
     */
    'updatedDate': string;
    /**
     * 
     * @type {string}
     * @memberof AlertDto
     */
    'createdDate': string;
}
/**
 * 
 * @export
 * @interface CourseDto
 */
export interface CourseDto {
    /**
     * 
     * @type {number}
     * @memberof CourseDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'createdDate': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'updatedDate': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'alias': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'descriptionUrl': string;
    /**
     * 
     * @type {number}
     * @memberof CourseDto
     */
    'year': number;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'endDate': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'registrationEndDate': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'primarySkillId': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'primarySkillName': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'locationName': string;
    /**
     * 
     * @type {number}
     * @memberof CourseDto
     */
    'discordServerId': number;
    /**
     * 
     * @type {boolean}
     * @memberof CourseDto
     */
    'completed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CourseDto
     */
    'planned': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CourseDto
     */
    'inviteOnly': boolean;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'certificateIssuer': string;
    /**
     * 
     * @type {boolean}
     * @memberof CourseDto
     */
    'usePrivateRepositories': boolean;
}
/**
 * 
 * @export
 * @interface CreateAlertDto
 */
export interface CreateAlertDto {
    /**
     * 
     * @type {string}
     * @memberof CreateAlertDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAlertDto
     */
    'text': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAlertDto
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateAlertDto
     */
    'courseId'?: number;
}
/**
 * 
 * @export
 * @interface CreateDisciplineDto
 */
export interface CreateDisciplineDto {
    /**
     * 
     * @type {string}
     * @memberof CreateDisciplineDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateStudentFeedbackDto
 */
export interface CreateStudentFeedbackDto {
    /**
     * 
     * @type {StudentFeedbackContentDto}
     * @memberof CreateStudentFeedbackDto
     */
    'content': StudentFeedbackContentDto;
    /**
     * 
     * @type {string}
     * @memberof CreateStudentFeedbackDto
     */
    'recommendation': CreateStudentFeedbackDtoRecommendationEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateStudentFeedbackDto
     */
    'englishLevel': CreateStudentFeedbackDtoEnglishLevelEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateStudentFeedbackDtoRecommendationEnum {
    Hire = 'hire',
    NotHire = 'not-hire'
}
/**
    * @export
    * @enum {string}
    */
export enum CreateStudentFeedbackDtoEnglishLevelEnum {
    Unknown = 'unknown',
    A1 = 'a1',
    A2 = 'a2',
    B1 = 'b1',
    B2 = 'b2',
    C1 = 'c1',
    C2 = 'c2'
}

/**
 * 
 * @export
 * @interface DisciplineDto
 */
export interface DisciplineDto {
    /**
     * 
     * @type {string}
     * @memberof DisciplineDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof DisciplineDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DisciplineDto
     */
    'createdDate': string;
    /**
     * 
     * @type {string}
     * @memberof DisciplineDto
     */
    'updatedDate': string;
}
/**
 * 
 * @export
 * @interface MentorStudentDto
 */
export interface MentorStudentDto {
    /**
     * 
     * @type {string}
     * @memberof MentorStudentDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof MentorStudentDto
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof MentorStudentDto
     */
    'active': boolean;
    /**
     * 
     * @type {string}
     * @memberof MentorStudentDto
     */
    'cityName': string;
    /**
     * 
     * @type {string}
     * @memberof MentorStudentDto
     */
    'countryName': string;
    /**
     * 
     * @type {string}
     * @memberof MentorStudentDto
     */
    'githubId': string;
    /**
     * 
     * @type {number}
     * @memberof MentorStudentDto
     */
    'totalScore': number;
    /**
     * 
     * @type {number}
     * @memberof MentorStudentDto
     */
    'rank': number;
    /**
     * 
     * @type {Array<StudentFeedback>}
     * @memberof MentorStudentDto
     */
    'feedbacks': Array<StudentFeedback>;
}
/**
 * 
 * @export
 * @interface PersonDto
 */
export interface PersonDto {
    /**
     * 
     * @type {string}
     * @memberof PersonDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PersonDto
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface ProfileCourseDto
 */
export interface ProfileCourseDto {
    /**
     * 
     * @type {number}
     * @memberof ProfileCourseDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'alias': string;
}
/**
 * 
 * @export
 * @interface SoftSkillEntry
 */
export interface SoftSkillEntry {
    /**
     * 
     * @type {string}
     * @memberof SoftSkillEntry
     */
    'id': SoftSkillEntryIdEnum;
    /**
     * 
     * @type {string}
     * @memberof SoftSkillEntry
     */
    'value': SoftSkillEntryValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SoftSkillEntryIdEnum {
    Responsible = 'skill.soft.responsible',
    TeamPlayer = 'skill.soft.team-player',
    Communicable = 'skill.soft.communicable'
}
/**
    * @export
    * @enum {string}
    */
export enum SoftSkillEntryValueEnum {
    None = 'None',
    Poor = 'Poor',
    Fair = 'Fair',
    Good = 'Good',
    Great = 'Great',
    Excellent = 'Excellent'
}

/**
 * 
 * @export
 * @interface StudentDto
 */
export interface StudentDto {
    /**
     * 
     * @type {string}
     * @memberof StudentDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof StudentDto
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof StudentDto
     */
    'active': boolean;
    /**
     * 
     * @type {string}
     * @memberof StudentDto
     */
    'cityName': string;
    /**
     * 
     * @type {string}
     * @memberof StudentDto
     */
    'countryName': string;
    /**
     * 
     * @type {string}
     * @memberof StudentDto
     */
    'githubId': string;
    /**
     * 
     * @type {number}
     * @memberof StudentDto
     */
    'totalScore': number;
    /**
     * 
     * @type {number}
     * @memberof StudentDto
     */
    'rank': number;
}
/**
 * 
 * @export
 * @interface StudentFeedback
 */
export interface StudentFeedback {
    /**
     * 
     * @type {number}
     * @memberof StudentFeedback
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface StudentFeedbackContentDto
 */
export interface StudentFeedbackContentDto {
    /**
     * 
     * @type {string}
     * @memberof StudentFeedbackContentDto
     */
    'impression': string;
    /**
     * 
     * @type {string}
     * @memberof StudentFeedbackContentDto
     */
    'gaps': string;
    /**
     * 
     * @type {string}
     * @memberof StudentFeedbackContentDto
     */
    'recommendationComment': string;
    /**
     * 
     * @type {Array<SoftSkillEntry>}
     * @memberof StudentFeedbackContentDto
     */
    'softSkills': Array<SoftSkillEntry>;
}
/**
 * 
 * @export
 * @interface StudentFeedbackDto
 */
export interface StudentFeedbackDto {
    /**
     * 
     * @type {number}
     * @memberof StudentFeedbackDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof StudentFeedbackDto
     */
    'createdDate': string;
    /**
     * 
     * @type {string}
     * @memberof StudentFeedbackDto
     */
    'updatedDate': string;
    /**
     * 
     * @type {StudentFeedbackContentDto}
     * @memberof StudentFeedbackDto
     */
    'content': StudentFeedbackContentDto;
    /**
     * 
     * @type {string}
     * @memberof StudentFeedbackDto
     */
    'recommendation': StudentFeedbackDtoRecommendationEnum;
    /**
     * 
     * @type {PersonDto}
     * @memberof StudentFeedbackDto
     */
    'author': PersonDto;
    /**
     * 
     * @type {PersonDto}
     * @memberof StudentFeedbackDto
     */
    'mentor': PersonDto;
    /**
     * 
     * @type {string}
     * @memberof StudentFeedbackDto
     */
    'englishLevel': StudentFeedbackDtoEnglishLevelEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum StudentFeedbackDtoRecommendationEnum {
    Hire = 'hire',
    NotHire = 'not-hire'
}
/**
    * @export
    * @enum {string}
    */
export enum StudentFeedbackDtoEnglishLevelEnum {
    Unknown = 'unknown',
    A1 = 'a1',
    A2 = 'a2',
    B1 = 'b1',
    B2 = 'b2',
    C1 = 'c1',
    C2 = 'c2'
}

/**
 * 
 * @export
 * @interface UpdateDisciplineDto
 */
export interface UpdateDisciplineDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateDisciplineDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UpdateStudentFeedbackDto
 */
export interface UpdateStudentFeedbackDto {
    /**
     * 
     * @type {StudentFeedbackContentDto}
     * @memberof UpdateStudentFeedbackDto
     */
    'content': StudentFeedbackContentDto;
    /**
     * 
     * @type {string}
     * @memberof UpdateStudentFeedbackDto
     */
    'recommendation': UpdateStudentFeedbackDtoRecommendationEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateStudentFeedbackDto
     */
    'englishLevel': UpdateStudentFeedbackDtoEnglishLevelEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum UpdateStudentFeedbackDtoRecommendationEnum {
    Hire = 'hire',
    NotHire = 'not-hire'
}
/**
    * @export
    * @enum {string}
    */
export enum UpdateStudentFeedbackDtoEnglishLevelEnum {
    Unknown = 'unknown',
    A1 = 'a1',
    A2 = 'a2',
    B1 = 'b1',
    B2 = 'b2',
    C1 = 'c1',
    C2 = 'c2'
}


/**
 * AlertsApi - axios parameter creator
 * @export
 */
export const AlertsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateAlertDto} createAlertDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlert: async (createAlertDto: CreateAlertDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAlertDto' is not null or undefined
            assertParamExists('createAlert', 'createAlertDto', createAlertDto)
            const localVarPath = `/api/v2/alerts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAlertDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAlert', 'id', id)
            const localVarPath = `/api/v2/alerts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} enabled 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlerts: async (enabled: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enabled' is not null or undefined
            assertParamExists('getAlerts', 'enabled', enabled)
            const localVarPath = `/api/v2/alerts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlert: async (id: number, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAlert', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateAlert', 'body', body)
            const localVarPath = `/api/v2/alerts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertsApi - functional programming interface
 * @export
 */
export const AlertsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlertsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateAlertDto} createAlertDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlert(createAlertDto: CreateAlertDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlert(createAlertDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlert(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlert(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} enabled 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlerts(enabled: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AlertDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlerts(enabled, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAlert(id: number, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAlert(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AlertsApi - factory interface
 * @export
 */
export const AlertsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlertsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateAlertDto} createAlertDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlert(createAlertDto: CreateAlertDto, options?: any): AxiosPromise<AlertDto> {
            return localVarFp.createAlert(createAlertDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAlert(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} enabled 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlerts(enabled: boolean, options?: any): AxiosPromise<Array<AlertDto>> {
            return localVarFp.getAlerts(enabled, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlert(id: number, body: object, options?: any): AxiosPromise<AlertDto> {
            return localVarFp.updateAlert(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
export class AlertsApi extends BaseAPI {
    /**
     * 
     * @param {CreateAlertDto} createAlertDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public createAlert(createAlertDto: CreateAlertDto, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).createAlert(createAlertDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public deleteAlert(id: number, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).deleteAlert(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} enabled 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public getAlerts(enabled: boolean, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).getAlerts(enabled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public updateAlert(id: number, body: object, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).updateAlert(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubCallback: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/auth/github/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubLogin: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/auth/github/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubLogout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/auth/github/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async githubCallback(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.githubCallback(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async githubLogin(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.githubLogin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async githubLogout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.githubLogout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubCallback(options?: any): AxiosPromise<void> {
            return localVarFp.githubCallback(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubLogin(options?: any): AxiosPromise<void> {
            return localVarFp.githubLogin(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubLogout(options?: any): AxiosPromise<void> {
            return localVarFp.githubLogout(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public githubCallback(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).githubCallback(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public githubLogin(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).githubLogin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public githubLogout(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).githubLogout(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CoursesApi - axios parameter creator
 * @export
 */
export const CoursesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} aliasOrId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourse: async (aliasOrId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aliasOrId' is not null or undefined
            assertParamExists('getCourse', 'aliasOrId', aliasOrId)
            const localVarPath = `/api/v2/courses/{aliasOrId}`
                .replace(`{${"aliasOrId"}}`, encodeURIComponent(String(aliasOrId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/courses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoursesApi - functional programming interface
 * @export
 */
export const CoursesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoursesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} aliasOrId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourse(aliasOrId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourse(aliasOrId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourses(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CourseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourses(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CoursesApi - factory interface
 * @export
 */
export const CoursesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoursesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} aliasOrId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourse(aliasOrId: string, options?: any): AxiosPromise<CourseDto> {
            return localVarFp.getCourse(aliasOrId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses(options?: any): AxiosPromise<Array<CourseDto>> {
            return localVarFp.getCourses(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoursesApi - object-oriented interface
 * @export
 * @class CoursesApi
 * @extends {BaseAPI}
 */
export class CoursesApi extends BaseAPI {
    /**
     * 
     * @param {string} aliasOrId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public getCourse(aliasOrId: string, options?: AxiosRequestConfig) {
        return CoursesApiFp(this.configuration).getCourse(aliasOrId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public getCourses(options?: AxiosRequestConfig) {
        return CoursesApiFp(this.configuration).getCourses(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DisciplinesApi - axios parameter creator
 * @export
 */
export const DisciplinesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateDisciplineDto} createDisciplineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiscipline: async (createDisciplineDto: CreateDisciplineDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDisciplineDto' is not null or undefined
            assertParamExists('createDiscipline', 'createDisciplineDto', createDisciplineDto)
            const localVarPath = `/api/v2/disciplines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDisciplineDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscipline: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDiscipline', 'id', id)
            const localVarPath = `/api/v2/disciplines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisciplines: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/disciplines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateDisciplineDto} updateDisciplineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDiscipline: async (id: number, updateDisciplineDto: UpdateDisciplineDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDiscipline', 'id', id)
            // verify required parameter 'updateDisciplineDto' is not null or undefined
            assertParamExists('updateDiscipline', 'updateDisciplineDto', updateDisciplineDto)
            const localVarPath = `/api/v2/disciplines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDisciplineDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DisciplinesApi - functional programming interface
 * @export
 */
export const DisciplinesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DisciplinesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateDisciplineDto} createDisciplineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDiscipline(createDisciplineDto: CreateDisciplineDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisciplineDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDiscipline(createDisciplineDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDiscipline(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDiscipline(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDisciplines(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DisciplineDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDisciplines(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateDisciplineDto} updateDisciplineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDiscipline(id: number, updateDisciplineDto: UpdateDisciplineDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisciplineDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDiscipline(id, updateDisciplineDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DisciplinesApi - factory interface
 * @export
 */
export const DisciplinesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DisciplinesApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateDisciplineDto} createDisciplineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiscipline(createDisciplineDto: CreateDisciplineDto, options?: any): AxiosPromise<DisciplineDto> {
            return localVarFp.createDiscipline(createDisciplineDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscipline(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDiscipline(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisciplines(options?: any): AxiosPromise<Array<DisciplineDto>> {
            return localVarFp.getDisciplines(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateDisciplineDto} updateDisciplineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDiscipline(id: number, updateDisciplineDto: UpdateDisciplineDto, options?: any): AxiosPromise<DisciplineDto> {
            return localVarFp.updateDiscipline(id, updateDisciplineDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DisciplinesApi - object-oriented interface
 * @export
 * @class DisciplinesApi
 * @extends {BaseAPI}
 */
export class DisciplinesApi extends BaseAPI {
    /**
     * 
     * @param {CreateDisciplineDto} createDisciplineDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisciplinesApi
     */
    public createDiscipline(createDisciplineDto: CreateDisciplineDto, options?: AxiosRequestConfig) {
        return DisciplinesApiFp(this.configuration).createDiscipline(createDisciplineDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisciplinesApi
     */
    public deleteDiscipline(id: number, options?: AxiosRequestConfig) {
        return DisciplinesApiFp(this.configuration).deleteDiscipline(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisciplinesApi
     */
    public getDisciplines(options?: AxiosRequestConfig) {
        return DisciplinesApiFp(this.configuration).getDisciplines(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UpdateDisciplineDto} updateDisciplineDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisciplinesApi
     */
    public updateDiscipline(id: number, updateDisciplineDto: UpdateDisciplineDto, options?: AxiosRequestConfig) {
        return DisciplinesApiFp(this.configuration).updateDiscipline(id, updateDisciplineDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MentorsApi - axios parameter creator
 * @export
 */
export const MentorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} mentorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMentorStudents: async (mentorId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mentorId' is not null or undefined
            assertParamExists('getMentorStudents', 'mentorId', mentorId)
            const localVarPath = `/api/v2/mentors/{mentorId}/students`
                .replace(`{${"mentorId"}}`, encodeURIComponent(String(mentorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MentorsApi - functional programming interface
 * @export
 */
export const MentorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MentorsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} mentorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMentorStudents(mentorId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MentorStudentDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMentorStudents(mentorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MentorsApi - factory interface
 * @export
 */
export const MentorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MentorsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} mentorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMentorStudents(mentorId: number, options?: any): AxiosPromise<Array<MentorStudentDto>> {
            return localVarFp.getMentorStudents(mentorId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MentorsApi - object-oriented interface
 * @export
 * @class MentorsApi
 * @extends {BaseAPI}
 */
export class MentorsApi extends BaseAPI {
    /**
     * 
     * @param {number} mentorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MentorsApi
     */
    public getMentorStudents(mentorId: number, options?: AxiosRequestConfig) {
        return MentorsApiFp(this.configuration).getMentorStudents(mentorId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProfileApi - axios parameter creator
 * @export
 */
export const ProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCourses: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUserCourses', 'username', username)
            const localVarPath = `/api/v2/profile/{username}/courses`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCourses(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProfileCourseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCourses(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileApiFp(configuration)
    return {
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCourses(username: string, options?: any): AxiosPromise<Array<ProfileCourseDto>> {
            return localVarFp.getUserCourses(username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
    /**
     * 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getUserCourses(username: string, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).getUserCourses(username, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudentsApi - axios parameter creator
 * @export
 */
export const StudentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} studentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudent: async (studentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studentId' is not null or undefined
            assertParamExists('getStudent', 'studentId', studentId)
            const localVarPath = `/api/v2/students/{studentId}`
                .replace(`{${"studentId"}}`, encodeURIComponent(String(studentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudentsApi - functional programming interface
 * @export
 */
export const StudentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} studentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudent(studentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudent(studentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StudentsApi - factory interface
 * @export
 */
export const StudentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudentsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} studentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudent(studentId: number, options?: any): AxiosPromise<StudentDto> {
            return localVarFp.getStudent(studentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudentsApi - object-oriented interface
 * @export
 * @class StudentsApi
 * @extends {BaseAPI}
 */
export class StudentsApi extends BaseAPI {
    /**
     * 
     * @param {number} studentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public getStudent(studentId: number, options?: AxiosRequestConfig) {
        return StudentsApiFp(this.configuration).getStudent(studentId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudentsFeedbacksApi - axios parameter creator
 * @export
 */
export const StudentsFeedbacksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} studentId 
         * @param {CreateStudentFeedbackDto} createStudentFeedbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudentFeedback: async (studentId: number, createStudentFeedbackDto: CreateStudentFeedbackDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studentId' is not null or undefined
            assertParamExists('createStudentFeedback', 'studentId', studentId)
            // verify required parameter 'createStudentFeedbackDto' is not null or undefined
            assertParamExists('createStudentFeedback', 'createStudentFeedbackDto', createStudentFeedbackDto)
            const localVarPath = `/api/v2/students/{studentId}/feedbacks`
                .replace(`{${"studentId"}}`, encodeURIComponent(String(studentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStudentFeedbackDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} studentId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentFeedback: async (studentId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studentId' is not null or undefined
            assertParamExists('getStudentFeedback', 'studentId', studentId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStudentFeedback', 'id', id)
            const localVarPath = `/api/v2/students/{studentId}/feedbacks/{id}`
                .replace(`{${"studentId"}}`, encodeURIComponent(String(studentId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} studentId 
         * @param {number} id 
         * @param {UpdateStudentFeedbackDto} updateStudentFeedbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStudentFeedback: async (studentId: number, id: number, updateStudentFeedbackDto: UpdateStudentFeedbackDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studentId' is not null or undefined
            assertParamExists('updateStudentFeedback', 'studentId', studentId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateStudentFeedback', 'id', id)
            // verify required parameter 'updateStudentFeedbackDto' is not null or undefined
            assertParamExists('updateStudentFeedback', 'updateStudentFeedbackDto', updateStudentFeedbackDto)
            const localVarPath = `/api/v2/students/{studentId}/feedbacks/{id}`
                .replace(`{${"studentId"}}`, encodeURIComponent(String(studentId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStudentFeedbackDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudentsFeedbacksApi - functional programming interface
 * @export
 */
export const StudentsFeedbacksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudentsFeedbacksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} studentId 
         * @param {CreateStudentFeedbackDto} createStudentFeedbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStudentFeedback(studentId: number, createStudentFeedbackDto: CreateStudentFeedbackDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentFeedbackDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStudentFeedback(studentId, createStudentFeedbackDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} studentId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudentFeedback(studentId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentFeedbackDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudentFeedback(studentId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} studentId 
         * @param {number} id 
         * @param {UpdateStudentFeedbackDto} updateStudentFeedbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStudentFeedback(studentId: number, id: number, updateStudentFeedbackDto: UpdateStudentFeedbackDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentFeedbackDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStudentFeedback(studentId, id, updateStudentFeedbackDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StudentsFeedbacksApi - factory interface
 * @export
 */
export const StudentsFeedbacksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudentsFeedbacksApiFp(configuration)
    return {
        /**
         * 
         * @param {number} studentId 
         * @param {CreateStudentFeedbackDto} createStudentFeedbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudentFeedback(studentId: number, createStudentFeedbackDto: CreateStudentFeedbackDto, options?: any): AxiosPromise<StudentFeedbackDto> {
            return localVarFp.createStudentFeedback(studentId, createStudentFeedbackDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} studentId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentFeedback(studentId: number, id: number, options?: any): AxiosPromise<StudentFeedbackDto> {
            return localVarFp.getStudentFeedback(studentId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} studentId 
         * @param {number} id 
         * @param {UpdateStudentFeedbackDto} updateStudentFeedbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStudentFeedback(studentId: number, id: number, updateStudentFeedbackDto: UpdateStudentFeedbackDto, options?: any): AxiosPromise<StudentFeedbackDto> {
            return localVarFp.updateStudentFeedback(studentId, id, updateStudentFeedbackDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudentsFeedbacksApi - object-oriented interface
 * @export
 * @class StudentsFeedbacksApi
 * @extends {BaseAPI}
 */
export class StudentsFeedbacksApi extends BaseAPI {
    /**
     * 
     * @param {number} studentId 
     * @param {CreateStudentFeedbackDto} createStudentFeedbackDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsFeedbacksApi
     */
    public createStudentFeedback(studentId: number, createStudentFeedbackDto: CreateStudentFeedbackDto, options?: AxiosRequestConfig) {
        return StudentsFeedbacksApiFp(this.configuration).createStudentFeedback(studentId, createStudentFeedbackDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} studentId 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsFeedbacksApi
     */
    public getStudentFeedback(studentId: number, id: number, options?: AxiosRequestConfig) {
        return StudentsFeedbacksApiFp(this.configuration).getStudentFeedback(studentId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} studentId 
     * @param {number} id 
     * @param {UpdateStudentFeedbackDto} updateStudentFeedbackDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsFeedbacksApi
     */
    public updateStudentFeedback(studentId: number, id: number, updateStudentFeedbackDto: UpdateStudentFeedbackDto, options?: AxiosRequestConfig) {
        return StudentsFeedbacksApiFp(this.configuration).updateStudentFeedback(studentId, id, updateStudentFeedbackDto, options).then((request) => request(this.axios, this.basePath));
    }
}


