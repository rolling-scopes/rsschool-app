/* tslint:disable */
/* eslint-disable */
/**
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface ActivityDto
 */
export interface ActivityDto {
    /**
     *
     * @type {number}
     * @memberof ActivityDto
     */
    'lastActivityTime': number;
    /**
     *
     * @type {boolean}
     * @memberof ActivityDto
     */
    'isActive': boolean;
}
/**
 *
 * @export
 * @interface AlertDto
 */
export interface AlertDto {
    /**
     *
     * @type {number}
     * @memberof AlertDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof AlertDto
     */
    'type': string;
    /**
     *
     * @type {string}
     * @memberof AlertDto
     */
    'text': string;
    /**
     *
     * @type {boolean}
     * @memberof AlertDto
     */
    'enabled': boolean;
    /**
     *
     * @type {number}
     * @memberof AlertDto
     */
    'courseId': number | null;
    /**
     *
     * @type {string}
     * @memberof AlertDto
     */
    'updatedDate': string;
    /**
     *
     * @type {string}
     * @memberof AlertDto
     */
    'createdDate': string;
}
/**
 *
 * @export
 * @interface ApplicantResumeDto
 */
export interface ApplicantResumeDto {
    /**
     *
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'uuid': string;
    /**
     *
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'avatarLink': string | null;
    /**
     *
     * @type {Array<number>}
     * @memberof ApplicantResumeDto
     */
    'visibleCourses': Array<number>;
    /**
     *
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'desiredPosition': string | null;
    /**
     *
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'email': string | null;
    /**
     *
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'englishLevel': ApplicantResumeDtoEnglishLevelEnum;
    /**
     *
     * @type {number}
     * @memberof ApplicantResumeDto
     */
    'expires': number | null;
    /**
     *
     * @type {boolean}
     * @memberof ApplicantResumeDto
     */
    'fullTime': boolean;
    /**
     *
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'githubId': string;
    /**
     *
     * @type {number}
     * @memberof ApplicantResumeDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'linkedin': string | null;
    /**
     *
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'locations': string | null;
    /**
     *
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'militaryService': ApplicantResumeDtoMilitaryServiceEnum;
    /**
     *
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'name': string | null;
    /**
     *
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'notes': string | null;
    /**
     *
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'phone': string | null;
    /**
     *
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'selfIntroLink': string | null;
    /**
     *
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'skype': string | null;
    /**
     *
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'startFrom': string | null;
    /**
     *
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'telegram': string | null;
    /**
     *
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'website': string | null;
}

export const ApplicantResumeDtoEnglishLevelEnum = {
    Unknown: 'unknown',
    A0: 'a0',
    A1: 'a1',
    A2: 'a2',
    B1: 'b1',
    B2: 'b2',
    C1: 'c1',
    C2: 'c2'
} as const;

export type ApplicantResumeDtoEnglishLevelEnum = typeof ApplicantResumeDtoEnglishLevelEnum[keyof typeof ApplicantResumeDtoEnglishLevelEnum];
export const ApplicantResumeDtoMilitaryServiceEnum = {
    Served: 'served',
    Liable: 'liable',
    NotLiable: 'notLiable'
} as const;

export type ApplicantResumeDtoMilitaryServiceEnum = typeof ApplicantResumeDtoMilitaryServiceEnum[keyof typeof ApplicantResumeDtoMilitaryServiceEnum];

/**
 *
 * @export
 * @interface ApproveMentorDto
 */
export interface ApproveMentorDto {
    /**
     *
     * @type {Array<string>}
     * @memberof ApproveMentorDto
     */
    'preselectedCourses': Array<string>;
}
/**
 *
 * @export
 * @interface Attributes
 */
export interface Attributes {
    /**
     *
     * @type {string}
     * @memberof Attributes
     */
    'template'?: string | null;
}
/**
 *
 * @export
 * @interface AuthConnectionDto
 */
export interface AuthConnectionDto {
    /**
     *
     * @type {string}
     * @memberof AuthConnectionDto
     */
    'channelId': string;
    /**
     *
     * @type {string}
     * @memberof AuthConnectionDto
     */
    'externalId': string;
}
/**
 *
 * @export
 * @interface AvailableReviewStatsDto
 */
export interface AvailableReviewStatsDto {
    /**
     *
     * @type {string}
     * @memberof AvailableReviewStatsDto
     */
    'name': string;
    /**
     *
     * @type {number}
     * @memberof AvailableReviewStatsDto
     */
    'id': number;
    /**
     *
     * @type {number}
     * @memberof AvailableReviewStatsDto
     */
    'checksCount': number;
    /**
     *
     * @type {number}
     * @memberof AvailableReviewStatsDto
     */
    'completedChecksCount': number;
}
/**
 *
 * @export
 * @interface AvailableStudentDto
 */
export interface AvailableStudentDto {
    /**
     *
     * @type {number}
     * @memberof AvailableStudentDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof AvailableStudentDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof AvailableStudentDto
     */
    'githubId': string;
    /**
     *
     * @type {string}
     * @memberof AvailableStudentDto
     */
    'cityName': string | null;
    /**
     *
     * @type {string}
     * @memberof AvailableStudentDto
     */
    'countryName': string | null;
    /**
     *
     * @type {boolean}
     * @memberof AvailableStudentDto
     */
    'isGoodCandidate': boolean;
    /**
     *
     * @type {string}
     * @memberof AvailableStudentDto
     */
    'rating': string | null;
    /**
     *
     * @type {number}
     * @memberof AvailableStudentDto
     */
    'totalScore': number;
    /**
     *
     * @type {string}
     * @memberof AvailableStudentDto
     */
    'registeredDate': string;
    /**
     *
     * @type {number}
     * @memberof AvailableStudentDto
     */
    'maxScore': number;
    /**
     *
     * @type {number}
     * @memberof AvailableStudentDto
     */
    'feedbackVersion': number;
}
/**
 *
 * @export
 * @interface BadgeDto
 */
export interface BadgeDto {
    /**
     *
     * @type {string}
     * @memberof BadgeDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof BadgeDto
     */
    'id': BadgeDtoIdEnum;
}

export const BadgeDtoIdEnum = {
    Congratulations: 'Congratulations',
    ExpertHelp: 'Expert_help',
    GreatSpeaker: 'Great_speaker',
    GoodJob: 'Good_job',
    HelpingHand: 'Helping_hand',
    Hero: 'Hero',
    ThankYou: 'Thank_you',
    OutstandingWork: 'Outstanding_work',
    TopPerformer: 'Top_performer',
    JobOffer: 'Job_Offer',
    RsActivist: 'RS_activist',
    JuryTeam: 'Jury_Team'
} as const;

export type BadgeDtoIdEnum = typeof BadgeDtoIdEnum[keyof typeof BadgeDtoIdEnum];

/**
 *
 * @export
 * @interface ChannelSettings
 */
export interface ChannelSettings {
    /**
     *
     * @type {string}
     * @memberof ChannelSettings
     */
    'channelId': string;
    /**
     *
     * @type {object}
     * @memberof ChannelSettings
     */
    'template': object;
}
/**
 *
 * @export
 * @interface CheckScheduleChangesDto
 */
export interface CheckScheduleChangesDto {
    /**
     *
     * @type {number}
     * @memberof CheckScheduleChangesDto
     */
    'lastHours': number;
}
/**
 *
 * @export
 * @interface CheckTasksDeadlineDto
 */
export interface CheckTasksDeadlineDto {
    /**
     *
     * @type {number}
     * @memberof CheckTasksDeadlineDto
     */
    'deadlineInHours': number;
}
/**
 *
 * @export
 * @interface CommentMentorRegistryDto
 */
export interface CommentMentorRegistryDto {
    /**
     *
     * @type {string}
     * @memberof CommentMentorRegistryDto
     */
    'comment': string | null;
}
/**
 *
 * @export
 * @interface ConfigurableProfilePermissions
 */
export interface ConfigurableProfilePermissions {
    /**
     *
     * @type {PublicVisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isProfileVisible'?: PublicVisibilitySettings;
    /**
     *
     * @type {VisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isAboutVisible'?: VisibilitySettings;
    /**
     *
     * @type {VisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isEducationVisible'?: VisibilitySettings;
    /**
     *
     * @type {PartialStudentVisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isEnglishVisible'?: PartialStudentVisibilitySettings;
    /**
     *
     * @type {ContactsVisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isEmailVisible'?: ContactsVisibilitySettings;
    /**
     *
     * @type {ContactsVisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isTelegramVisible'?: ContactsVisibilitySettings;
    /**
     *
     * @type {ContactsVisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isSkypeVisible'?: ContactsVisibilitySettings;
    /**
     *
     * @type {ContactsVisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isPhoneVisible'?: ContactsVisibilitySettings;
    /**
     *
     * @type {ContactsVisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isContactsNotesVisible'?: ContactsVisibilitySettings;
    /**
     *
     * @type {VisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isLinkedInVisible'?: VisibilitySettings;
    /**
     *
     * @type {VisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isPublicFeedbackVisible'?: VisibilitySettings;
    /**
     *
     * @type {VisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isMentorStatsVisible'?: VisibilitySettings;
    /**
     *
     * @type {PartialStudentVisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isStudentStatsVisible'?: PartialStudentVisibilitySettings;
}
/**
 *
 * @export
 * @interface ConsentDto
 */
export interface ConsentDto {
    /**
     *
     * @type {boolean}
     * @memberof ConsentDto
     */
    'consent': boolean;
}
/**
 *
 * @export
 * @interface ContactsDto
 */
export interface ContactsDto {
    /**
     *
     * @type {string}
     * @memberof ContactsDto
     */
    'phone'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ContactsDto
     */
    'email'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ContactsDto
     */
    'epamEmail'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ContactsDto
     */
    'skype'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ContactsDto
     */
    'whatsApp'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ContactsDto
     */
    'telegram'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ContactsDto
     */
    'notes'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ContactsDto
     */
    'linkedIn'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ContactsDto
     */
    'discord'?: string | null;
}
/**
 *
 * @export
 * @interface ContactsVisibilitySettings
 */
export interface ContactsVisibilitySettings {
    /**
     *
     * @type {boolean}
     * @memberof ContactsVisibilitySettings
     */
    'all': boolean;
    /**
     *
     * @type {boolean}
     * @memberof ContactsVisibilitySettings
     */
    'student': boolean;
}
/**
 *
 * @export
 * @interface CourseCopyFromDto
 */
export interface CourseCopyFromDto {
    /**
     *
     * @type {number}
     * @memberof CourseCopyFromDto
     */
    'copyFromCourseId': number;
}
/**
 *
 * @export
 * @interface CourseDto
 */
export interface CourseDto {
    /**
     *
     * @type {number}
     * @memberof CourseDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof CourseDto
     */
    'createdDate': string;
    /**
     *
     * @type {string}
     * @memberof CourseDto
     */
    'updatedDate': string;
    /**
     *
     * @type {string}
     * @memberof CourseDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof CourseDto
     */
    'fullName': string;
    /**
     *
     * @type {string}
     * @memberof CourseDto
     */
    'alias': string;
    /**
     *
     * @type {string}
     * @memberof CourseDto
     */
    'description': string;
    /**
     *
     * @type {string}
     * @memberof CourseDto
     */
    'descriptionUrl': string;
    /**
     *
     * @type {number}
     * @memberof CourseDto
     */
    'year': number;
    /**
     *
     * @type {string}
     * @memberof CourseDto
     */
    'startDate': string;
    /**
     *
     * @type {string}
     * @memberof CourseDto
     */
    'endDate': string;
    /**
     *
     * @type {string}
     * @memberof CourseDto
     */
    'registrationEndDate': string;
    /**
     *
     * @type {string}
     * @memberof CourseDto
     */
    'primarySkillId': string;
    /**
     *
     * @type {string}
     * @memberof CourseDto
     */
    'primarySkillName': string;
    /**
     *
     * @type {string}
     * @memberof CourseDto
     */
    'locationName': string;
    /**
     *
     * @type {number}
     * @memberof CourseDto
     */
    'discordServerId': number;
    /**
     *
     * @type {boolean}
     * @memberof CourseDto
     */
    'completed': boolean;
    /**
     *
     * @type {boolean}
     * @memberof CourseDto
     */
    'planned': boolean;
    /**
     *
     * @type {boolean}
     * @memberof CourseDto
     */
    'inviteOnly': boolean;
    /**
     *
     * @type {string}
     * @memberof CourseDto
     */
    'certificateIssuer': string;
    /**
     *
     * @type {boolean}
     * @memberof CourseDto
     */
    'usePrivateRepositories': boolean;
    /**
     *
     * @type {boolean}
     * @memberof CourseDto
     */
    'personalMentoring': boolean;
    /**
     *
     * @type {string}
     * @memberof CourseDto
     */
    'logo': string;
    /**
     *
     * @type {IdNameDto}
     * @memberof CourseDto
     */
    'discipline': IdNameDto | null;
}
/**
 *
 * @export
 * @interface CourseEventDto
 */
export interface CourseEventDto {
    /**
     *
     * @type {number}
     * @memberof CourseEventDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof CourseEventDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof CourseEventDto
     */
    'type': CourseEventDtoTypeEnum;
    /**
     *
     * @type {string}
     * @memberof CourseEventDto
     */
    'description': string;
    /**
     *
     * @type {string}
     * @memberof CourseEventDto
     */
    'descriptionUrl': string;
    /**
     *
     * @type {string}
     * @memberof CourseEventDto
     */
    'dateTime': string;
    /**
     *
     * @type {string}
     * @memberof CourseEventDto
     */
    'endTime': string;
    /**
     *
     * @type {PersonDto}
     * @memberof CourseEventDto
     */
    'organizer': PersonDto;
}

export const CourseEventDtoTypeEnum = {
    LectureOnline: 'lecture_online',
    LectureOffline: 'lecture_offline',
    LectureMixed: 'lecture_mixed',
    LectureSelfStudy: 'lecture_self_study',
    Warmup: 'warmup',
    Info: 'info',
    Workshop: 'workshop',
    Meetup: 'meetup',
    CrossCheckDeadline: 'cross_check_deadline',
    Webinar: 'webinar',
    Special: 'special'
} as const;

export type CourseEventDtoTypeEnum = typeof CourseEventDtoTypeEnum[keyof typeof CourseEventDtoTypeEnum];

/**
 *
 * @export
 * @interface CourseRolesDto
 */
export interface CourseRolesDto {
    /**
     *
     * @type {boolean}
     * @memberof CourseRolesDto
     */
    'isManager': boolean;
    /**
     *
     * @type {boolean}
     * @memberof CourseRolesDto
     */
    'isSupervisor': boolean;
    /**
     *
     * @type {boolean}
     * @memberof CourseRolesDto
     */
    'isDementor': boolean;
}
/**
 *
 * @export
 * @interface CourseScheduleItemDto
 */
export interface CourseScheduleItemDto {
    /**
     *
     * @type {number}
     * @memberof CourseScheduleItemDto
     */
    'score': number | null;
    /**
     *
     * @type {string}
     * @memberof CourseScheduleItemDto
     */
    'name': string;
    /**
     *
     * @type {number}
     * @memberof CourseScheduleItemDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof CourseScheduleItemDto
     */
    'status': CourseScheduleItemDtoStatusEnum;
    /**
     *
     * @type {string}
     * @memberof CourseScheduleItemDto
     */
    'startDate': string;
    /**
     *
     * @type {string}
     * @memberof CourseScheduleItemDto
     */
    'endDate': string;
    /**
     *
     * @type {string}
     * @memberof CourseScheduleItemDto
     */
    'crossCheckEndDate': string;
    /**
     *
     * @type {PersonDto}
     * @memberof CourseScheduleItemDto
     */
    'organizer': PersonDto | null;
    /**
     *
     * @type {number}
     * @memberof CourseScheduleItemDto
     */
    'maxScore': number | null;
    /**
     *
     * @type {number}
     * @memberof CourseScheduleItemDto
     */
    'scoreWeight': number | null;
    /**
     *
     * @type {string}
     * @memberof CourseScheduleItemDto
     */
    'descriptionUrl': string | null;
    /**
     *
     * @type {string}
     * @memberof CourseScheduleItemDto
     */
    'tag': CourseScheduleItemDtoTagEnum;
    /**
     *
     * @type {string}
     * @memberof CourseScheduleItemDto
     */
    'type': CourseScheduleItemDtoTypeEnum;
}

export const CourseScheduleItemDtoStatusEnum = {
    Done: 'done',
    Available: 'available',
    Archived: 'archived',
    Future: 'future',
    Missed: 'missed',
    Review: 'review'
} as const;

export type CourseScheduleItemDtoStatusEnum = typeof CourseScheduleItemDtoStatusEnum[keyof typeof CourseScheduleItemDtoStatusEnum];
export const CourseScheduleItemDtoTagEnum = {
    Lecture: 'lecture',
    Coding: 'coding',
    SelfStudy: 'self-study',
    Interview: 'interview',
    CrossCheckSubmit: 'cross-check-submit',
    CrossCheckReview: 'cross-check-review',
    Test: 'test'
} as const;

export type CourseScheduleItemDtoTagEnum = typeof CourseScheduleItemDtoTagEnum[keyof typeof CourseScheduleItemDtoTagEnum];
export const CourseScheduleItemDtoTypeEnum = {
    CourseTask: 'courseTask',
    CourseEvent: 'courseEvent'
} as const;

export type CourseScheduleItemDtoTypeEnum = typeof CourseScheduleItemDtoTypeEnum[keyof typeof CourseScheduleItemDtoTypeEnum];

/**
 *
 * @export
 * @interface CourseScheduleTokenDto
 */
export interface CourseScheduleTokenDto {
    /**
     *
     * @type {string}
     * @memberof CourseScheduleTokenDto
     */
    'token': string;
}
/**
 *
 * @export
 * @interface CourseStatsDto
 */
export interface CourseStatsDto {
    /**
     *
     * @type {number}
     * @memberof CourseStatsDto
     */
    'studentsActiveCount': number;
    /**
     *
     * @type {number}
     * @memberof CourseStatsDto
     */
    'studentsTotalCount': number;
}
/**
 *
 * @export
 * @interface CourseTaskDetailedDto
 */
export interface CourseTaskDetailedDto {
    /**
     *
     * @type {number}
     * @memberof CourseTaskDetailedDto
     */
    'id': number;
    /**
     *
     * @type {number}
     * @memberof CourseTaskDetailedDto
     */
    'taskId': number;
    /**
     *
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'type': CourseTaskDetailedDtoTypeEnum;
    /**
     *
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'checker': CourseTaskDetailedDtoCheckerEnum;
    /**
     *
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'studentStartDate': string;
    /**
     *
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'studentEndDate': string;
    /**
     *
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'crossCheckEndDate': string | null;
    /**
     *
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'descriptionUrl': string;
    /**
     *
     * @type {PersonDto}
     * @memberof CourseTaskDetailedDto
     */
    'taskOwner': PersonDto | null;
    /**
     *
     * @type {object}
     * @memberof CourseTaskDetailedDto
     */
    'taskSolutions': object | null;
    /**
     *
     * @type {number}
     * @memberof CourseTaskDetailedDto
     */
    'maxScore': number;
    /**
     *
     * @type {number}
     * @memberof CourseTaskDetailedDto
     */
    'scoreWeight': number;
    /**
     *
     * @type {number}
     * @memberof CourseTaskDetailedDto
     */
    'pairsCount': number | null;
    /**
     *
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'crossCheckStatus': string;
    /**
     *
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'submitText': string | null;
    /**
     *
     * @type {Validations}
     * @memberof CourseTaskDetailedDto
     */
    'validations': Validations | null;
    /**
     *
     * @type {object}
     * @memberof CourseTaskDetailedDto
     */
    'publicAttributes': object;
    /**
     *
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'githubRepoName': string;
    /**
     *
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'sourceGithubRepoUrl': string;
    /**
     *
     * @type {number}
     * @memberof CourseTaskDetailedDto
     */
    'resultsCount': number;
}

export const CourseTaskDetailedDtoTypeEnum = {
    Jstask: 'jstask',
    Kotlintask: 'kotlintask',
    Objctask: 'objctask',
    Htmltask: 'htmltask',
    Ipynb: 'ipynb',
    Selfeducation: 'selfeducation',
    Codewars: 'codewars',
    Test: 'test',
    Codejam: 'codejam',
    Interview: 'interview',
    StageInterview: 'stage-interview',
    Cvhtml: 'cv:html',
    Cvmarkdown: 'cv:markdown'
} as const;

export type CourseTaskDetailedDtoTypeEnum = typeof CourseTaskDetailedDtoTypeEnum[keyof typeof CourseTaskDetailedDtoTypeEnum];
export const CourseTaskDetailedDtoCheckerEnum = {
    AutoTest: 'auto-test',
    Assigned: 'assigned',
    Mentor: 'mentor',
    TaskOwner: 'taskOwner',
    CrossCheck: 'crossCheck'
} as const;

export type CourseTaskDetailedDtoCheckerEnum = typeof CourseTaskDetailedDtoCheckerEnum[keyof typeof CourseTaskDetailedDtoCheckerEnum];

/**
 *
 * @export
 * @interface CourseTaskDto
 */
export interface CourseTaskDto {
    /**
     *
     * @type {number}
     * @memberof CourseTaskDto
     */
    'id': number;
    /**
     *
     * @type {number}
     * @memberof CourseTaskDto
     */
    'taskId': number;
    /**
     *
     * @type {string}
     * @memberof CourseTaskDto
     */
    'type': CourseTaskDtoTypeEnum;
    /**
     *
     * @type {string}
     * @memberof CourseTaskDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof CourseTaskDto
     */
    'checker': CourseTaskDtoCheckerEnum;
    /**
     *
     * @type {string}
     * @memberof CourseTaskDto
     */
    'studentStartDate': string;
    /**
     *
     * @type {string}
     * @memberof CourseTaskDto
     */
    'studentEndDate': string;
    /**
     *
     * @type {string}
     * @memberof CourseTaskDto
     */
    'crossCheckEndDate': string | null;
    /**
     *
     * @type {string}
     * @memberof CourseTaskDto
     */
    'descriptionUrl': string;
    /**
     *
     * @type {PersonDto}
     * @memberof CourseTaskDto
     */
    'taskOwner': PersonDto | null;
    /**
     *
     * @type {object}
     * @memberof CourseTaskDto
     */
    'taskSolutions': object | null;
    /**
     *
     * @type {number}
     * @memberof CourseTaskDto
     */
    'maxScore': number;
    /**
     *
     * @type {number}
     * @memberof CourseTaskDto
     */
    'scoreWeight': number;
    /**
     *
     * @type {number}
     * @memberof CourseTaskDto
     */
    'pairsCount': number | null;
    /**
     *
     * @type {string}
     * @memberof CourseTaskDto
     */
    'crossCheckStatus': string;
    /**
     *
     * @type {string}
     * @memberof CourseTaskDto
     */
    'submitText': string | null;
    /**
     *
     * @type {Validations}
     * @memberof CourseTaskDto
     */
    'validations': Validations | null;
}

export const CourseTaskDtoTypeEnum = {
    Jstask: 'jstask',
    Kotlintask: 'kotlintask',
    Objctask: 'objctask',
    Htmltask: 'htmltask',
    Ipynb: 'ipynb',
    Selfeducation: 'selfeducation',
    Codewars: 'codewars',
    Test: 'test',
    Codejam: 'codejam',
    Interview: 'interview',
    StageInterview: 'stage-interview',
    Cvhtml: 'cv:html',
    Cvmarkdown: 'cv:markdown'
} as const;

export type CourseTaskDtoTypeEnum = typeof CourseTaskDtoTypeEnum[keyof typeof CourseTaskDtoTypeEnum];
export const CourseTaskDtoCheckerEnum = {
    AutoTest: 'auto-test',
    Assigned: 'assigned',
    Mentor: 'mentor',
    TaskOwner: 'taskOwner',
    CrossCheck: 'crossCheck'
} as const;

export type CourseTaskDtoCheckerEnum = typeof CourseTaskDtoCheckerEnum[keyof typeof CourseTaskDtoCheckerEnum];

/**
 *
 * @export
 * @interface CourseUserDto
 */
export interface CourseUserDto {
    /**
     *
     * @type {number}
     * @memberof CourseUserDto
     */
    'id': number;
    /**
     *
     * @type {number}
     * @memberof CourseUserDto
     */
    'courseId': number;
    /**
     *
     * @type {string}
     * @memberof CourseUserDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof CourseUserDto
     */
    'githubId': string;
    /**
     *
     * @type {boolean}
     * @memberof CourseUserDto
     */
    'isManager': boolean;
    /**
     *
     * @type {boolean}
     * @memberof CourseUserDto
     */
    'isSupervisor': boolean;
    /**
     *
     * @type {boolean}
     * @memberof CourseUserDto
     */
    'isJuryActivist': boolean;
    /**
     *
     * @type {boolean}
     * @memberof CourseUserDto
     */
    'isDementor': boolean;
}
/**
 *
 * @export
 * @interface CreateActivityDto
 */
export interface CreateActivityDto {
    /**
     *
     * @type {boolean}
     * @memberof CreateActivityDto
     */
    'isActive': boolean;
}
/**
 *
 * @export
 * @interface CreateActivityWebhookDto
 */
export interface CreateActivityWebhookDto {
    /**
     *
     * @type {SenderDto}
     * @memberof CreateActivityWebhookDto
     */
    'sender': SenderDto;
}
/**
 *
 * @export
 * @interface CreateAlertDto
 */
export interface CreateAlertDto {
    /**
     *
     * @type {string}
     * @memberof CreateAlertDto
     */
    'type': string;
    /**
     *
     * @type {string}
     * @memberof CreateAlertDto
     */
    'text': string;
    /**
     *
     * @type {boolean}
     * @memberof CreateAlertDto
     */
    'enabled'?: boolean;
    /**
     *
     * @type {number}
     * @memberof CreateAlertDto
     */
    'courseId'?: number;
}
/**
 *
 * @export
 * @interface CreateCourseEventDto
 */
export interface CreateCourseEventDto {
    /**
     *
     * @type {number}
     * @memberof CreateCourseEventDto
     */
    'eventId': number;
    /**
     *
     * @type {string}
     * @memberof CreateCourseEventDto
     */
    'special'?: string;
    /**
     *
     * @type {string}
     * @memberof CreateCourseEventDto
     */
    'dateTime'?: string;
    /**
     *
     * @type {string}
     * @memberof CreateCourseEventDto
     */
    'endTime'?: string;
    /**
     *
     * @type {number}
     * @memberof CreateCourseEventDto
     */
    'duration'?: number;
    /**
     *
     * @type {string}
     * @memberof CreateCourseEventDto
     */
    'place'?: string;
    /**
     *
     * @type {Organizer}
     * @memberof CreateCourseEventDto
     */
    'organizer'?: Organizer;
    /**
     *
     * @type {number}
     * @memberof CreateCourseEventDto
     */
    'organizerId'?: number;
    /**
     *
     * @type {string}
     * @memberof CreateCourseEventDto
     */
    'broadcastUrl'?: string;
    /**
     *
     * @type {string}
     * @memberof CreateCourseEventDto
     */
    'coordinator'?: string;
    /**
     *
     * @type {string}
     * @memberof CreateCourseEventDto
     */
    'comment'?: string;
}
/**
 *
 * @export
 * @interface CreateCourseTaskDto
 */
export interface CreateCourseTaskDto {
    /**
     *
     * @type {number}
     * @memberof CreateCourseTaskDto
     */
    'taskId': number;
    /**
     *
     * @type {number}
     * @memberof CreateCourseTaskDto
     */
    'maxScore'?: number;
    /**
     *
     * @type {number}
     * @memberof CreateCourseTaskDto
     */
    'scoreWeight'?: number;
    /**
     *
     * @type {string}
     * @memberof CreateCourseTaskDto
     */
    'checker': CreateCourseTaskDtoCheckerEnum;
    /**
     *
     * @type {string}
     * @memberof CreateCourseTaskDto
     */
    'studentStartDate': string;
    /**
     *
     * @type {string}
     * @memberof CreateCourseTaskDto
     */
    'studentEndDate': string;
    /**
     *
     * @type {string}
     * @memberof CreateCourseTaskDto
     */
    'crossCheckEndDate'?: string;
    /**
     *
     * @type {number}
     * @memberof CreateCourseTaskDto
     */
    'taskOwnerId'?: number;
    /**
     *
     * @type {number}
     * @memberof CreateCourseTaskDto
     */
    'pairsCount'?: number;
    /**
     *
     * @type {string}
     * @memberof CreateCourseTaskDto
     */
    'type': CreateCourseTaskDtoTypeEnum;
    /**
     *
     * @type {string}
     * @memberof CreateCourseTaskDto
     */
    'submitText': string;
    /**
     *
     * @type {object}
     * @memberof CreateCourseTaskDto
     */
    'validations': object;
}

export const CreateCourseTaskDtoCheckerEnum = {
    AutoTest: 'auto-test',
    Assigned: 'assigned',
    Mentor: 'mentor',
    TaskOwner: 'taskOwner',
    CrossCheck: 'crossCheck'
} as const;

export type CreateCourseTaskDtoCheckerEnum = typeof CreateCourseTaskDtoCheckerEnum[keyof typeof CreateCourseTaskDtoCheckerEnum];
export const CreateCourseTaskDtoTypeEnum = {
    Jstask: 'jstask',
    Kotlintask: 'kotlintask',
    Objctask: 'objctask',
    Htmltask: 'htmltask',
    Ipynb: 'ipynb',
    Selfeducation: 'selfeducation',
    Codewars: 'codewars',
    Test: 'test',
    Codejam: 'codejam',
    Interview: 'interview',
    StageInterview: 'stage-interview',
    Cvhtml: 'cv:html',
    Cvmarkdown: 'cv:markdown'
} as const;

export type CreateCourseTaskDtoTypeEnum = typeof CreateCourseTaskDtoTypeEnum[keyof typeof CreateCourseTaskDtoTypeEnum];

/**
 *
 * @export
 * @interface CreateDisciplineDto
 */
export interface CreateDisciplineDto {
    /**
     *
     * @type {string}
     * @memberof CreateDisciplineDto
     */
    'name': string;
}
/**
 *
 * @export
 * @interface CreateDiscordServerDto
 */
export interface CreateDiscordServerDto {
    /**
     *
     * @type {string}
     * @memberof CreateDiscordServerDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof CreateDiscordServerDto
     */
    'gratitudeUrl': string;
    /**
     *
     * @type {string}
     * @memberof CreateDiscordServerDto
     */
    'mentorsChatUrl': string;
}
/**
 *
 * @export
 * @interface CreateEventDto
 */
export interface CreateEventDto {
    /**
     *
     * @type {string}
     * @memberof CreateEventDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof CreateEventDto
     */
    'type': string;
    /**
     *
     * @type {number}
     * @memberof CreateEventDto
     */
    'disciplineId': number;
    /**
     *
     * @type {string}
     * @memberof CreateEventDto
     */
    'descriptionUrl': string;
    /**
     *
     * @type {string}
     * @memberof CreateEventDto
     */
    'description': string;
}
/**
 *
 * @export
 * @interface CreateGratitudeDto
 */
export interface CreateGratitudeDto {
    /**
     *
     * @type {Array<number>}
     * @memberof CreateGratitudeDto
     */
    'userIds': Array<number>;
    /**
     *
     * @type {number}
     * @memberof CreateGratitudeDto
     */
    'courseId': number;
    /**
     *
     * @type {string}
     * @memberof CreateGratitudeDto
     */
    'comment': string;
    /**
     *
     * @type {string}
     * @memberof CreateGratitudeDto
     */
    'badgeId': string;
}
/**
 *
 * @export
 * @interface CreatePromptDto
 */
export interface CreatePromptDto {
    /**
     *
     * @type {string}
     * @memberof CreatePromptDto
     */
    'type': string;
    /**
     *
     * @type {string}
     * @memberof CreatePromptDto
     */
    'text': string;
    /**
     *
     * @type {number}
     * @memberof CreatePromptDto
     */
    'temperature': number;
}
/**
 *
 * @export
 * @interface CreateStudentFeedbackDto
 */
export interface CreateStudentFeedbackDto {
    /**
     *
     * @type {StudentFeedbackContentDto}
     * @memberof CreateStudentFeedbackDto
     */
    'content': StudentFeedbackContentDto;
    /**
     *
     * @type {string}
     * @memberof CreateStudentFeedbackDto
     */
    'recommendation': CreateStudentFeedbackDtoRecommendationEnum;
    /**
     *
     * @type {string}
     * @memberof CreateStudentFeedbackDto
     */
    'englishLevel': CreateStudentFeedbackDtoEnglishLevelEnum;
}

export const CreateStudentFeedbackDtoRecommendationEnum = {
    Hire: 'hire',
    NotHire: 'not-hire'
} as const;

export type CreateStudentFeedbackDtoRecommendationEnum = typeof CreateStudentFeedbackDtoRecommendationEnum[keyof typeof CreateStudentFeedbackDtoRecommendationEnum];
export const CreateStudentFeedbackDtoEnglishLevelEnum = {
    Unknown: 'unknown',
    A0: 'a0',
    A1: 'a1',
    A2: 'a2',
    B1: 'b1',
    B2: 'b2',
    C1: 'c1',
    C2: 'c2'
} as const;

export type CreateStudentFeedbackDtoEnglishLevelEnum = typeof CreateStudentFeedbackDtoEnglishLevelEnum[keyof typeof CreateStudentFeedbackDtoEnglishLevelEnum];

/**
 *
 * @export
 * @interface CreateTaskDto
 */
export interface CreateTaskDto {
    /**
     *
     * @type {string}
     * @memberof CreateTaskDto
     */
    'name': string;
    /**
     *
     * @type {object}
     * @memberof CreateTaskDto
     */
    'attributes': object;
    /**
     *
     * @type {string}
     * @memberof CreateTaskDto
     */
    'descriptionUrl': string;
    /**
     *
     * @type {string}
     * @memberof CreateTaskDto
     */
    'description': string;
    /**
     *
     * @type {string}
     * @memberof CreateTaskDto
     */
    'githubRepoName': string;
    /**
     *
     * @type {string}
     * @memberof CreateTaskDto
     */
    'sourceGithubRepoUrl': string;
    /**
     *
     * @type {number}
     * @memberof CreateTaskDto
     */
    'disciplineId': number;
    /**
     *
     * @type {boolean}
     * @memberof CreateTaskDto
     */
    'githubPrRequired': boolean;
    /**
     *
     * @type {string}
     * @memberof CreateTaskDto
     */
    'type': string;
    /**
     *
     * @type {Array<string>}
     * @memberof CreateTaskDto
     */
    'skills': Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof CreateTaskDto
     */
    'tags': Array<string>;
}
/**
 *
 * @export
 * @interface CreateTaskVerificationDto
 */
export interface CreateTaskVerificationDto {
    /**
     *
     * @type {number}
     * @memberof CreateTaskVerificationDto
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface CreateTeamDistributionDto
 */
export interface CreateTeamDistributionDto {
    /**
     *
     * @type {string}
     * @memberof CreateTeamDistributionDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof CreateTeamDistributionDto
     */
    'startDate': string;
    /**
     *
     * @type {string}
     * @memberof CreateTeamDistributionDto
     */
    'endDate': string;
    /**
     *
     * @type {string}
     * @memberof CreateTeamDistributionDto
     */
    'description': string;
    /**
     *
     * @type {string}
     * @memberof CreateTeamDistributionDto
     */
    'descriptionUrl': string;
    /**
     *
     * @type {number}
     * @memberof CreateTeamDistributionDto
     */
    'minTeamSize': number;
    /**
     *
     * @type {number}
     * @memberof CreateTeamDistributionDto
     */
    'maxTeamSize': number;
    /**
     *
     * @type {number}
     * @memberof CreateTeamDistributionDto
     */
    'strictTeamSize': number;
    /**
     *
     * @type {boolean}
     * @memberof CreateTeamDistributionDto
     */
    'strictTeamSizeMode': boolean;
    /**
     *
     * @type {number}
     * @memberof CreateTeamDistributionDto
     */
    'minTotalScore': number;
}
/**
 *
 * @export
 * @interface CreateTeamDto
 */
export interface CreateTeamDto {
    /**
     *
     * @type {string}
     * @memberof CreateTeamDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof CreateTeamDto
     */
    'description': string;
    /**
     *
     * @type {string}
     * @memberof CreateTeamDto
     */
    'chatLink': string;
    /**
     *
     * @type {Array<number>}
     * @memberof CreateTeamDto
     */
    'studentIds'?: Array<number>;
}
/**
 *
 * @export
 * @interface CreateUserGroupDto
 */
export interface CreateUserGroupDto {
    /**
     *
     * @type {string}
     * @memberof CreateUserGroupDto
     */
    'name': string;
    /**
     *
     * @type {Array<number>}
     * @memberof CreateUserGroupDto
     */
    'users': Array<number>;
    /**
     *
     * @type {Array<string>}
     * @memberof CreateUserGroupDto
     */
    'roles': Array<CreateUserGroupDtoRolesEnum>;
}

export const CreateUserGroupDtoRolesEnum = {
    TaskOwner: 'taskOwner',
    Manager: 'manager',
    Supervisor: 'supervisor',
    Student: 'student',
    Mentor: 'mentor',
    Dementor: 'dementor'
} as const;

export type CreateUserGroupDtoRolesEnum = typeof CreateUserGroupDtoRolesEnum[keyof typeof CreateUserGroupDtoRolesEnum];

/**
 *
 * @export
 * @interface CriteriaDto
 */
export interface CriteriaDto {
    /**
     *
     * @type {number}
     * @memberof CriteriaDto
     */
    'max'?: number;
    /**
     *
     * @type {string}
     * @memberof CriteriaDto
     */
    'type': CriteriaDtoTypeEnum;
    /**
     *
     * @type {string}
     * @memberof CriteriaDto
     */
    'text': string;
    /**
     *
     * @type {string}
     * @memberof CriteriaDto
     */
    'key': string;
    /**
     *
     * @type {number}
     * @memberof CriteriaDto
     */
    'index': number;
}

export const CriteriaDtoTypeEnum = {
    Title: 'title',
    Subtask: 'subtask',
    Penalty: 'penalty'
} as const;

export type CriteriaDtoTypeEnum = typeof CriteriaDtoTypeEnum[keyof typeof CriteriaDtoTypeEnum];

/**
 *
 * @export
 * @interface CrossCheckAuthorDto
 */
export interface CrossCheckAuthorDto {
    /**
     *
     * @type {number}
     * @memberof CrossCheckAuthorDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof CrossCheckAuthorDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof CrossCheckAuthorDto
     */
    'githubId': string;
    /**
     *
     * @type {Discord}
     * @memberof CrossCheckAuthorDto
     */
    'discord': Discord | null;
}
/**
 *
 * @export
 * @interface CrossCheckCriteriaDataDto
 */
export interface CrossCheckCriteriaDataDto {
    /**
     *
     * @type {string}
     * @memberof CrossCheckCriteriaDataDto
     */
    'key': string;
    /**
     *
     * @type {number}
     * @memberof CrossCheckCriteriaDataDto
     */
    'max'?: number;
    /**
     *
     * @type {string}
     * @memberof CrossCheckCriteriaDataDto
     */
    'text': string;
    /**
     *
     * @type {string}
     * @memberof CrossCheckCriteriaDataDto
     */
    'type': CrossCheckCriteriaDataDtoTypeEnum;
    /**
     *
     * @type {number}
     * @memberof CrossCheckCriteriaDataDto
     */
    'point'?: number;
    /**
     *
     * @type {string}
     * @memberof CrossCheckCriteriaDataDto
     */
    'textComment'?: string;
}

export const CrossCheckCriteriaDataDtoTypeEnum = {
    Title: 'title',
    Subtask: 'subtask',
    Penalty: 'penalty'
} as const;

export type CrossCheckCriteriaDataDtoTypeEnum = typeof CrossCheckCriteriaDataDtoTypeEnum[keyof typeof CrossCheckCriteriaDataDtoTypeEnum];

/**
 *
 * @export
 * @interface CrossCheckFeedbackDto
 */
export interface CrossCheckFeedbackDto {
    /**
     *
     * @type {string}
     * @memberof CrossCheckFeedbackDto
     */
    'url'?: string;
    /**
     *
     * @type {Array<CrossCheckSolutionReviewDto>}
     * @memberof CrossCheckFeedbackDto
     */
    'reviews'?: Array<CrossCheckSolutionReviewDto>;
}
/**
 *
 * @export
 * @interface CrossCheckMessageAuthorDto
 */
export interface CrossCheckMessageAuthorDto {
    /**
     *
     * @type {string}
     * @memberof CrossCheckMessageAuthorDto
     */
    'githubId': string;
    /**
     *
     * @type {number}
     * @memberof CrossCheckMessageAuthorDto
     */
    'id': number;
}
/**
 *
 * @export
 * @interface CrossCheckMessageDto
 */
export interface CrossCheckMessageDto {
    /**
     *
     * @type {CrossCheckMessageAuthorDto}
     * @memberof CrossCheckMessageDto
     */
    'author': CrossCheckMessageAuthorDto | null;
    /**
     *
     * @type {string}
     * @memberof CrossCheckMessageDto
     */
    'content': string;
    /**
     *
     * @type {string}
     * @memberof CrossCheckMessageDto
     */
    'timestamp': string;
    /**
     *
     * @type {boolean}
     * @memberof CrossCheckMessageDto
     */
    'isReviewerRead': boolean;
    /**
     *
     * @type {boolean}
     * @memberof CrossCheckMessageDto
     */
    'isStudentRead': boolean;
    /**
     *
     * @type {string}
     * @memberof CrossCheckMessageDto
     */
    'role': CrossCheckMessageDtoRoleEnum;
}

export const CrossCheckMessageDtoRoleEnum = {
    Reviewer: 'reviewer',
    Student: 'student'
} as const;

export type CrossCheckMessageDtoRoleEnum = typeof CrossCheckMessageDtoRoleEnum[keyof typeof CrossCheckMessageDtoRoleEnum];

/**
 *
 * @export
 * @interface CrossCheckPairDto
 */
export interface CrossCheckPairDto {
    /**
     *
     * @type {PersonDto}
     * @memberof CrossCheckPairDto
     */
    'student': PersonDto;
    /**
     *
     * @type {PersonDto}
     * @memberof CrossCheckPairDto
     */
    'checker': PersonDto;
    /**
     *
     * @type {IdNameDto}
     * @memberof CrossCheckPairDto
     */
    'task': IdNameDto;
    /**
     *
     * @type {number}
     * @memberof CrossCheckPairDto
     */
    'score': number;
    /**
     *
     * @type {number}
     * @memberof CrossCheckPairDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof CrossCheckPairDto
     */
    'comment': string;
    /**
     *
     * @type {string}
     * @memberof CrossCheckPairDto
     */
    'url': string;
    /**
     *
     * @type {string}
     * @memberof CrossCheckPairDto
     */
    'reviewedDate': string;
    /**
     *
     * @type {string}
     * @memberof CrossCheckPairDto
     */
    'submittedDate': string;
    /**
     *
     * @type {Array<HistoricalScoreDto>}
     * @memberof CrossCheckPairDto
     */
    'historicalScores': Array<HistoricalScoreDto>;
    /**
     *
     * @type {Array<CrossCheckMessageDto>}
     * @memberof CrossCheckPairDto
     */
    'messages': Array<CrossCheckMessageDto>;
}
/**
 *
 * @export
 * @interface CrossCheckPairResponseDto
 */
export interface CrossCheckPairResponseDto {
    /**
     *
     * @type {Array<CrossCheckPairDto>}
     * @memberof CrossCheckPairResponseDto
     */
    'items': Array<CrossCheckPairDto>;
    /**
     *
     * @type {PaginationDto}
     * @memberof CrossCheckPairResponseDto
     */
    'pagination': PaginationDto;
}
/**
 *
 * @export
 * @interface CrossCheckSolutionReviewDto
 */
export interface CrossCheckSolutionReviewDto {
    /**
     *
     * @type {number}
     * @memberof CrossCheckSolutionReviewDto
     */
    'id': number;
    /**
     *
     * @type {number}
     * @memberof CrossCheckSolutionReviewDto
     */
    'dateTime': number;
    /**
     *
     * @type {string}
     * @memberof CrossCheckSolutionReviewDto
     */
    'comment': string;
    /**
     *
     * @type {Array<CrossCheckCriteriaDataDto>}
     * @memberof CrossCheckSolutionReviewDto
     */
    'criteria'?: Array<CrossCheckCriteriaDataDto>;
    /**
     *
     * @type {CrossCheckAuthorDto}
     * @memberof CrossCheckSolutionReviewDto
     */
    'author': CrossCheckAuthorDto | null;
    /**
     *
     * @type {number}
     * @memberof CrossCheckSolutionReviewDto
     */
    'score': number;
    /**
     *
     * @type {Array<CrossCheckMessageDto>}
     * @memberof CrossCheckSolutionReviewDto
     */
    'messages': Array<CrossCheckMessageDto>;
}
/**
 *
 * @export
 * @interface DisciplineDto
 */
export interface DisciplineDto {
    /**
     *
     * @type {string}
     * @memberof DisciplineDto
     */
    'name': string;
    /**
     *
     * @type {number}
     * @memberof DisciplineDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof DisciplineDto
     */
    'createdDate': string;
    /**
     *
     * @type {string}
     * @memberof DisciplineDto
     */
    'updatedDate': string;
}
/**
 *
 * @export
 * @interface Discord
 */
export interface Discord {
    /**
     *
     * @type {string}
     * @memberof Discord
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof Discord
     */
    'username': string;
    /**
     *
     * @type {string}
     * @memberof Discord
     */
    'discriminator': string;
}
/**
 *
 * @export
 * @interface DiscordServerDto
 */
export interface DiscordServerDto {
    /**
     *
     * @type {number}
     * @memberof DiscordServerDto
     */
    'id': number;
    /**
     *
     * @type {number}
     * @memberof DiscordServerDto
     */
    'createdDate': number;
    /**
     *
     * @type {number}
     * @memberof DiscordServerDto
     */
    'updatedDate': number;
    /**
     *
     * @type {string}
     * @memberof DiscordServerDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof DiscordServerDto
     */
    'gratitudeUrl': string;
    /**
     *
     * @type {string}
     * @memberof DiscordServerDto
     */
    'mentorsChatUrl': string | null;
}
/**
 *
 * @export
 * @interface Education
 */
export interface Education {
    /**
     *
     * @type {string}
     * @memberof Education
     */
    'university': string;
    /**
     *
     * @type {string}
     * @memberof Education
     */
    'faculty': string;
    /**
     *
     * @type {number}
     * @memberof Education
     */
    'graduationYear': number;
}
/**
 *
 * @export
 * @interface EmploymentRecordDto
 */
export interface EmploymentRecordDto {
    /**
     *
     * @type {string}
     * @memberof EmploymentRecordDto
     */
    'title': string;
    /**
     *
     * @type {string}
     * @memberof EmploymentRecordDto
     */
    'dateTo': string;
    /**
     *
     * @type {string}
     * @memberof EmploymentRecordDto
     */
    'dateFrom': string;
    /**
     *
     * @type {string}
     * @memberof EmploymentRecordDto
     */
    'companyName': string;
    /**
     *
     * @type {boolean}
     * @memberof EmploymentRecordDto
     */
    'toPresent': boolean;
    /**
     *
     * @type {string}
     * @memberof EmploymentRecordDto
     */
    'officeLocation': string;
}
/**
 *
 * @export
 * @interface EndorsementDto
 */
export interface EndorsementDto {
    /**
     *
     * @type {string}
     * @memberof EndorsementDto
     */
    'summary': string;
    /**
     *
     * @type {object}
     * @memberof EndorsementDto
     */
    'data': object | null;
}
/**
 *
 * @export
 * @interface EventDto
 */
export interface EventDto {
    /**
     *
     * @type {number}
     * @memberof EventDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof EventDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof EventDto
     */
    'descriptionUrl': string | null;
    /**
     *
     * @type {string}
     * @memberof EventDto
     */
    'description': string | null;
    /**
     *
     * @type {string}
     * @memberof EventDto
     */
    'type': EventDtoTypeEnum;
    /**
     *
     * @type {IdNameDto}
     * @memberof EventDto
     */
    'discipline': IdNameDto | null;
}

export const EventDtoTypeEnum = {
    LectureOnline: 'lecture_online',
    LectureOffline: 'lecture_offline',
    LectureMixed: 'lecture_mixed',
    LectureSelfStudy: 'lecture_self_study',
    Warmup: 'warmup',
    Info: 'info',
    Workshop: 'workshop',
    Meetup: 'meetup',
    CrossCheckDeadline: 'cross_check_deadline',
    Webinar: 'webinar',
    Special: 'special'
} as const;

export type EventDtoTypeEnum = typeof EventDtoTypeEnum[keyof typeof EventDtoTypeEnum];

/**
 *
 * @export
 * @interface FeedbackCourseDto
 */
export interface FeedbackCourseDto {
    /**
     *
     * @type {string}
     * @memberof FeedbackCourseDto
     */
    'name': string;
    /**
     *
     * @type {number}
     * @memberof FeedbackCourseDto
     */
    'id': number;
}
/**
 *
 * @export
 * @interface FeedbackDto
 */
export interface FeedbackDto {
    /**
     *
     * @type {string}
     * @memberof FeedbackDto
     */
    'date': string;
    /**
     *
     * @type {string}
     * @memberof FeedbackDto
     */
    'recommendation': string;
    /**
     *
     * @type {string}
     * @memberof FeedbackDto
     */
    'englishLevel': string;
    /**
     *
     * @type {string}
     * @memberof FeedbackDto
     */
    'recommendationComment': string;
    /**
     *
     * @type {string}
     * @memberof FeedbackDto
     */
    'suggestions': string;
    /**
     *
     * @type {Array<FeedbackSoftSkill>}
     * @memberof FeedbackDto
     */
    'softSkills': Array<FeedbackSoftSkill>;
    /**
     *
     * @type {ResumeCourseMentor}
     * @memberof FeedbackDto
     */
    'mentor': ResumeCourseMentor;
    /**
     *
     * @type {FeedbackCourseDto}
     * @memberof FeedbackDto
     */
    'course': FeedbackCourseDto;
}
/**
 *
 * @export
 * @interface FeedbackSoftSkill
 */
export interface FeedbackSoftSkill {
    /**
     *
     * @type {string}
     * @memberof FeedbackSoftSkill
     */
    'value': FeedbackSoftSkillValueEnum;
    /**
     *
     * @type {string}
     * @memberof FeedbackSoftSkill
     */
    'id': FeedbackSoftSkillIdEnum;
}

export const FeedbackSoftSkillValueEnum = {
    None: 'None',
    Poor: 'Poor',
    Fair: 'Fair',
    Good: 'Good',
    Great: 'Great',
    Excellent: 'Excellent'
} as const;

export type FeedbackSoftSkillValueEnum = typeof FeedbackSoftSkillValueEnum[keyof typeof FeedbackSoftSkillValueEnum];
export const FeedbackSoftSkillIdEnum = {
    Responsible: 'skill.soft.responsible',
    TeamPlayer: 'skill.soft.team-player',
    Communicable: 'skill.soft.communicable'
} as const;

export type FeedbackSoftSkillIdEnum = typeof FeedbackSoftSkillIdEnum[keyof typeof FeedbackSoftSkillIdEnum];

/**
 *
 * @export
 * @interface FormDataDto
 */
export interface FormDataDto {
    /**
     *
     * @type {string}
     * @memberof FormDataDto
     */
    'avatarLink': string | null;
    /**
     *
     * @type {Array<number>}
     * @memberof FormDataDto
     */
    'visibleCourses': Array<number>;
    /**
     *
     * @type {string}
     * @memberof FormDataDto
     */
    'desiredPosition': string | null;
    /**
     *
     * @type {string}
     * @memberof FormDataDto
     */
    'email': string | null;
    /**
     *
     * @type {string}
     * @memberof FormDataDto
     */
    'englishLevel': FormDataDtoEnglishLevelEnum;
    /**
     *
     * @type {boolean}
     * @memberof FormDataDto
     */
    'fullTime': boolean;
    /**
     *
     * @type {string}
     * @memberof FormDataDto
     */
    'githubUsername': string | null;
    /**
     *
     * @type {string}
     * @memberof FormDataDto
     */
    'linkedin': string | null;
    /**
     *
     * @type {string}
     * @memberof FormDataDto
     */
    'locations': string | null;
    /**
     *
     * @type {string}
     * @memberof FormDataDto
     */
    'militaryService': FormDataDtoMilitaryServiceEnum;
    /**
     *
     * @type {string}
     * @memberof FormDataDto
     */
    'name': string | null;
    /**
     *
     * @type {string}
     * @memberof FormDataDto
     */
    'notes': string | null;
    /**
     *
     * @type {string}
     * @memberof FormDataDto
     */
    'phone': string | null;
    /**
     *
     * @type {string}
     * @memberof FormDataDto
     */
    'selfIntroLink': string | null;
    /**
     *
     * @type {string}
     * @memberof FormDataDto
     */
    'skype': string | null;
    /**
     *
     * @type {string}
     * @memberof FormDataDto
     */
    'startFrom': string | null;
    /**
     *
     * @type {string}
     * @memberof FormDataDto
     */
    'telegram': string | null;
    /**
     *
     * @type {string}
     * @memberof FormDataDto
     */
    'website': string | null;
}

export const FormDataDtoEnglishLevelEnum = {
    Unknown: 'unknown',
    A0: 'a0',
    A1: 'a1',
    A2: 'a2',
    B1: 'b1',
    B2: 'b2',
    C1: 'c1',
    C2: 'c2'
} as const;

export type FormDataDtoEnglishLevelEnum = typeof FormDataDtoEnglishLevelEnum[keyof typeof FormDataDtoEnglishLevelEnum];
export const FormDataDtoMilitaryServiceEnum = {
    Served: 'served',
    Liable: 'liable',
    NotLiable: 'notLiable'
} as const;

export type FormDataDtoMilitaryServiceEnum = typeof FormDataDtoMilitaryServiceEnum[keyof typeof FormDataDtoMilitaryServiceEnum];

/**
 *
 * @export
 * @interface GeneralInfo
 */
export interface GeneralInfo {
    /**
     *
     * @type {string}
     * @memberof GeneralInfo
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof GeneralInfo
     */
    'githubId': string;
    /**
     *
     * @type {string}
     * @memberof GeneralInfo
     */
    'aboutMyself'?: string | null;
    /**
     *
     * @type {Location}
     * @memberof GeneralInfo
     */
    'location': Location;
    /**
     *
     * @type {Array<Education>}
     * @memberof GeneralInfo
     */
    'educationHistory'?: Array<Education> | null;
    /**
     *
     * @type {string}
     * @memberof GeneralInfo
     */
    'englishLevel'?: string | null;
}
/**
 *
 * @export
 * @interface GiveConsentDto
 */
export interface GiveConsentDto {
    /**
     *
     * @type {boolean}
     * @memberof GiveConsentDto
     */
    'consent': boolean;
    /**
     *
     * @type {number}
     * @memberof GiveConsentDto
     */
    'expires': number;
}
/**
 *
 * @export
 * @interface GratitudeDto
 */
export interface GratitudeDto {
    /**
     *
     * @type {PersonDto}
     * @memberof GratitudeDto
     */
    'user': PersonDto;
    /**
     *
     * @type {number}
     * @memberof GratitudeDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof GratitudeDto
     */
    'badgeId': GratitudeDtoBadgeIdEnum;
    /**
     *
     * @type {string}
     * @memberof GratitudeDto
     */
    'comment': string;
    /**
     *
     * @type {number}
     * @memberof GratitudeDto
     */
    'courseId': number;
    /**
     *
     * @type {string}
     * @memberof GratitudeDto
     */
    'date': string;
}

export const GratitudeDtoBadgeIdEnum = {
    Congratulations: 'Congratulations',
    ExpertHelp: 'Expert_help',
    GreatSpeaker: 'Great_speaker',
    GoodJob: 'Good_job',
    HelpingHand: 'Helping_hand',
    Hero: 'Hero',
    ThankYou: 'Thank_you',
    OutstandingWork: 'Outstanding_work',
    TopPerformer: 'Top_performer',
    JobOffer: 'Job_Offer',
    RsActivist: 'RS_activist',
    JuryTeam: 'Jury_Team'
} as const;

export type GratitudeDtoBadgeIdEnum = typeof GratitudeDtoBadgeIdEnum[keyof typeof GratitudeDtoBadgeIdEnum];

/**
 *
 * @export
 * @interface HistoricalScoreDto
 */
export interface HistoricalScoreDto {
    /**
     *
     * @type {string}
     * @memberof HistoricalScoreDto
     */
    'comment': string;
    /**
     *
     * @type {string}
     * @memberof HistoricalScoreDto
     */
    'dateTime': string;
    /**
     *
     * @type {Array<CrossCheckCriteriaDataDto>}
     * @memberof HistoricalScoreDto
     */
    'criteria'?: Array<CrossCheckCriteriaDataDto>;
}
/**
 *
 * @export
 * @interface IdNameDto
 */
export interface IdNameDto {
    /**
     *
     * @type {string}
     * @memberof IdNameDto
     */
    'name': string;
    /**
     *
     * @type {number}
     * @memberof IdNameDto
     */
    'id': number;
}
/**
 *
 * @export
 * @interface InterviewDto
 */
export interface InterviewDto {
    /**
     *
     * @type {number}
     * @memberof InterviewDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof InterviewDto
     */
    'type': string;
    /**
     *
     * @type {string}
     * @memberof InterviewDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof InterviewDto
     */
    'startDate': string;
    /**
     *
     * @type {string}
     * @memberof InterviewDto
     */
    'endDate': string;
    /**
     *
     * @type {string}
     * @memberof InterviewDto
     */
    'description': string | null;
    /**
     *
     * @type {string}
     * @memberof InterviewDto
     */
    'descriptionUrl': string;
    /**
     *
     * @type {Attributes}
     * @memberof InterviewDto
     */
    'attributes': Attributes;
}
/**
 *
 * @export
 * @interface InterviewFeedbackDto
 */
export interface InterviewFeedbackDto {
    /**
     *
     * @type {number}
     * @memberof InterviewFeedbackDto
     */
    'version'?: number;
    /**
     *
     * @type {object}
     * @memberof InterviewFeedbackDto
     */
    'json'?: object;
    /**
     *
     * @type {boolean}
     * @memberof InterviewFeedbackDto
     */
    'isCompleted': boolean;
    /**
     *
     * @type {number}
     * @memberof InterviewFeedbackDto
     */
    'maxScore': number;
}
/**
 *
 * @export
 * @interface JoinTeamDto
 */
export interface JoinTeamDto {
    /**
     *
     * @type {string}
     * @memberof JoinTeamDto
     */
    'password': string;
}
/**
 *
 * @export
 * @interface LeaveCourseRequestDto
 */
export interface LeaveCourseRequestDto {
    /**
     *
     * @type {string}
     * @memberof LeaveCourseRequestDto
     */
    'comment'?: string;
}
/**
 *
 * @export
 * @interface Location
 */
export interface Location {
    /**
     *
     * @type {string}
     * @memberof Location
     */
    'cityName'?: string | null;
    /**
     *
     * @type {string}
     * @memberof Location
     */
    'countryName'?: string | null;
}
/**
 *
 * @export
 * @interface MentorDashboardDto
 */
export interface MentorDashboardDto {
    /**
     *
     * @type {string}
     * @memberof MentorDashboardDto
     */
    'studentGithubId': string;
    /**
     *
     * @type {string}
     * @memberof MentorDashboardDto
     */
    'studentName': string;
    /**
     *
     * @type {string}
     * @memberof MentorDashboardDto
     */
    'taskName': string;
    /**
     *
     * @type {string}
     * @memberof MentorDashboardDto
     */
    'taskDescriptionUrl': string;
    /**
     *
     * @type {number}
     * @memberof MentorDashboardDto
     */
    'courseTaskId': number;
    /**
     *
     * @type {number}
     * @memberof MentorDashboardDto
     */
    'maxScore': number;
    /**
     *
     * @type {number}
     * @memberof MentorDashboardDto
     */
    'resultScore': number | null;
    /**
     *
     * @type {string}
     * @memberof MentorDashboardDto
     */
    'solutionUrl': string;
    /**
     *
     * @type {string}
     * @memberof MentorDashboardDto
     */
    'status': string;
    /**
     *
     * @type {string}
     * @memberof MentorDashboardDto
     */
    'endDate': string;
}
/**
 *
 * @export
 * @interface MentorDetailsDto
 */
export interface MentorDetailsDto {
    /**
     *
     * @type {number}
     * @memberof MentorDetailsDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof MentorDetailsDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof MentorDetailsDto
     */
    'githubId': string;
    /**
     *
     * @type {boolean}
     * @memberof MentorDetailsDto
     */
    'isActive': boolean;
    /**
     *
     * @type {string}
     * @memberof MentorDetailsDto
     */
    'cityName': string;
    /**
     *
     * @type {string}
     * @memberof MentorDetailsDto
     */
    'countryName': string;
    /**
     *
     * @type {number}
     * @memberof MentorDetailsDto
     */
    'maxStudentsLimit': number;
    /**
     *
     * @type {Array<StudentId>}
     * @memberof MentorDetailsDto
     */
    'students': Array<StudentId>;
    /**
     *
     * @type {object}
     * @memberof MentorDetailsDto
     */
    'interviews'?: object;
    /**
     *
     * @type {object}
     * @memberof MentorDetailsDto
     */
    'screenings'?: object;
    /**
     *
     * @type {object}
     * @memberof MentorDetailsDto
     */
    'taskResultsStats'?: object;
    /**
     *
     * @type {string}
     * @memberof MentorDetailsDto
     */
    'studentsPreference': MentorDetailsDtoStudentsPreferenceEnum;
    /**
     *
     * @type {number}
     * @memberof MentorDetailsDto
     */
    'studentsCount'?: number;
    /**
     *
     * @type {string}
     * @memberof MentorDetailsDto
     */
    'contactsEpamEmail': string;
}

export const MentorDetailsDtoStudentsPreferenceEnum = {
    Any: 'any',
    Country: 'country',
    City: 'city'
} as const;

export type MentorDetailsDtoStudentsPreferenceEnum = typeof MentorDetailsDtoStudentsPreferenceEnum[keyof typeof MentorDetailsDtoStudentsPreferenceEnum];

/**
 *
 * @export
 * @interface MentorDto
 */
export interface MentorDto {
    /**
     *
     * @type {number}
     * @memberof MentorDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof MentorDto
     */
    'githubId': string;
    /**
     *
     * @type {string}
     * @memberof MentorDto
     */
    'name': string;
}
/**
 *
 * @export
 * @interface MentorOptionsDto
 */
export interface MentorOptionsDto {
    /**
     *
     * @type {number}
     * @memberof MentorOptionsDto
     */
    'maxStudentsLimit': number;
    /**
     *
     * @type {string}
     * @memberof MentorOptionsDto
     */
    'preferedStudentsLocation': MentorOptionsDtoPreferedStudentsLocationEnum;
    /**
     *
     * @type {Array<StudentsDto>}
     * @memberof MentorOptionsDto
     */
    'students': Array<StudentsDto>;
}

export const MentorOptionsDtoPreferedStudentsLocationEnum = {
    Any: 'any',
    Country: 'country',
    City: 'city'
} as const;

export type MentorOptionsDtoPreferedStudentsLocationEnum = typeof MentorOptionsDtoPreferedStudentsLocationEnum[keyof typeof MentorOptionsDtoPreferedStudentsLocationEnum];

/**
 *
 * @export
 * @interface MentorRegistryDto
 */
export interface MentorRegistryDto {
    /**
     *
     * @type {number}
     * @memberof MentorRegistryDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof MentorRegistryDto
     */
    'githubId': string;
    /**
     *
     * @type {string}
     * @memberof MentorRegistryDto
     */
    'cityName': string | null;
    /**
     *
     * @type {Array<number>}
     * @memberof MentorRegistryDto
     */
    'preferedCourses': Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof MentorRegistryDto
     */
    'preselectedCourses': Array<number>;
    /**
     *
     * @type {number}
     * @memberof MentorRegistryDto
     */
    'maxStudentsLimit': number;
    /**
     *
     * @type {string}
     * @memberof MentorRegistryDto
     */
    'preferedStudentsLocation': string;
    /**
     *
     * @type {string}
     * @memberof MentorRegistryDto
     */
    'name': string;
    /**
     *
     * @type {Array<string>}
     * @memberof MentorRegistryDto
     */
    'technicalMentoring': Array<string>;
    /**
     *
     * @type {Array<number>}
     * @memberof MentorRegistryDto
     */
    'courses': Array<number>;
    /**
     *
     * @type {string}
     * @memberof MentorRegistryDto
     */
    'sendDate': string;
    /**
     *
     * @type {string}
     * @memberof MentorRegistryDto
     */
    'receivedDate': string;
    /**
     *
     * @type {boolean}
     * @memberof MentorRegistryDto
     */
    'hasCertificate': boolean;
    /**
     *
     * @type {boolean}
     * @memberof MentorRegistryDto
     */
    'englishMentoring': boolean;
    /**
     *
     * @type {string}
     * @memberof MentorRegistryDto
     */
    'primaryEmail': string;
    /**
     *
     * @type {Array<string>}
     * @memberof MentorRegistryDto
     */
    'languagesMentoring': Array<string>;
    /**
     *
     * @type {string}
     * @memberof MentorRegistryDto
     */
    'contactsEpamEmail': string | null;
    /**
     *
     * @type {string}
     * @memberof MentorRegistryDto
     */
    'comment': string | null;
}
/**
 *
 * @export
 * @interface MentorStudentDto
 */
export interface MentorStudentDto {
    /**
     *
     * @type {string}
     * @memberof MentorStudentDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof MentorStudentDto
     */
    'githubId': string;
    /**
     *
     * @type {number}
     * @memberof MentorStudentDto
     */
    'id': number;
    /**
     *
     * @type {boolean}
     * @memberof MentorStudentDto
     */
    'active': boolean;
    /**
     *
     * @type {string}
     * @memberof MentorStudentDto
     */
    'cityName': string | null;
    /**
     *
     * @type {string}
     * @memberof MentorStudentDto
     */
    'countryName': string | null;
    /**
     *
     * @type {number}
     * @memberof MentorStudentDto
     */
    'totalScore': number;
    /**
     *
     * @type {number}
     * @memberof MentorStudentDto
     */
    'rank': number;
    /**
     *
     * @type {Array<StudentFeedback>}
     * @memberof MentorStudentDto
     */
    'feedbacks': Array<StudentFeedback>;
    /**
     *
     * @type {string}
     * @memberof MentorStudentDto
     */
    'repoUrl': string | null;
}
/**
 *
 * @export
 * @interface NotificationConnectionDto
 */
export interface NotificationConnectionDto {
    /**
     *
     * @type {string}
     * @memberof NotificationConnectionDto
     */
    'channelId': string;
    /**
     *
     * @type {string}
     * @memberof NotificationConnectionDto
     */
    'externalId': string;
    /**
     *
     * @type {number}
     * @memberof NotificationConnectionDto
     */
    'userId': number;
    /**
     *
     * @type {boolean}
     * @memberof NotificationConnectionDto
     */
    'enabled': boolean;
}
/**
 *
 * @export
 * @interface NotificationConnectionExistsDto
 */
export interface NotificationConnectionExistsDto {
    /**
     *
     * @type {string}
     * @memberof NotificationConnectionExistsDto
     */
    'channelId': string;
    /**
     *
     * @type {string}
     * @memberof NotificationConnectionExistsDto
     */
    'externalId'?: string;
    /**
     *
     * @type {number}
     * @memberof NotificationConnectionExistsDto
     */
    'userId'?: number;
}
/**
 *
 * @export
 * @interface NotificationDto
 */
export interface NotificationDto {
    /**
     *
     * @type {string}
     * @memberof NotificationDto
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof NotificationDto
     */
    'name': string;
    /**
     *
     * @type {boolean}
     * @memberof NotificationDto
     */
    'enabled': boolean;
    /**
     *
     * @type {NotificationType}
     * @memberof NotificationDto
     */
    'type': NotificationType;
    /**
     *
     * @type {Array<ChannelSettings>}
     * @memberof NotificationDto
     */
    'channels': Array<ChannelSettings>;
    /**
     *
     * @type {string}
     * @memberof NotificationDto
     */
    'parentId': string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const NotificationType = {
    Event: 'event',
    Message: 'message'
} as const;

export type NotificationType = typeof NotificationType[keyof typeof NotificationType];


/**
 *
 * @export
 * @interface NotificationUserConnectionsDto
 */
export interface NotificationUserConnectionsDto {
    /**
     *
     * @type {object}
     * @memberof NotificationUserConnectionsDto
     */
    'connections': object;
}
/**
 *
 * @export
 * @interface NotificationUserSettingsDto
 */
export interface NotificationUserSettingsDto {
    /**
     *
     * @type {string}
     * @memberof NotificationUserSettingsDto
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof NotificationUserSettingsDto
     */
    'name': string;
    /**
     *
     * @type {boolean}
     * @memberof NotificationUserSettingsDto
     */
    'enabled': boolean;
    /**
     *
     * @type {object}
     * @memberof NotificationUserSettingsDto
     */
    'settings': object;
}
/**
 *
 * @export
 * @interface Organizer
 */
export interface Organizer {
    /**
     *
     * @type {number}
     * @memberof Organizer
     */
    'id': number;
}
/**
 *
 * @export
 * @interface PaginationDto
 */
export interface PaginationDto {
    /**
     *
     * @type {number}
     * @memberof PaginationDto
     */
    'pageSize': number;
    /**
     *
     * @type {number}
     * @memberof PaginationDto
     */
    'current': number;
    /**
     *
     * @type {number}
     * @memberof PaginationDto
     */
    'total': number;
    /**
     *
     * @type {number}
     * @memberof PaginationDto
     */
    'totalPages': number;
}
/**
 *
 * @export
 * @interface PaginationMetaDto
 */
export interface PaginationMetaDto {
    /**
     *
     * @type {number}
     * @memberof PaginationMetaDto
     */
    'itemCount': number;
    /**
     *
     * @type {number}
     * @memberof PaginationMetaDto
     */
    'total': number;
    /**
     *
     * @type {number}
     * @memberof PaginationMetaDto
     */
    'current': number;
    /**
     *
     * @type {number}
     * @memberof PaginationMetaDto
     */
    'pageSize': number;
    /**
     *
     * @type {number}
     * @memberof PaginationMetaDto
     */
    'totalPages': number;
}
/**
 *
 * @export
 * @interface PartialStudentVisibilitySettings
 */
export interface PartialStudentVisibilitySettings {
    /**
     *
     * @type {boolean}
     * @memberof PartialStudentVisibilitySettings
     */
    'all': boolean;
    /**
     *
     * @type {boolean}
     * @memberof PartialStudentVisibilitySettings
     */
    'student': boolean;
}
/**
 *
 * @export
 * @interface PersonDto
 */
export interface PersonDto {
    /**
     *
     * @type {string}
     * @memberof PersonDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof PersonDto
     */
    'githubId': string;
    /**
     *
     * @type {number}
     * @memberof PersonDto
     */
    'id': number;
}
/**
 *
 * @export
 * @interface PersonalProfileDto
 */
export interface PersonalProfileDto {
    /**
     *
     * @type {number}
     * @memberof PersonalProfileDto
     */
    'userId': number;
    /**
     *
     * @type {string}
     * @memberof PersonalProfileDto
     */
    'githubId': string;
    /**
     *
     * @type {string}
     * @memberof PersonalProfileDto
     */
    'primaryEmail': string | null;
    /**
     *
     * @type {boolean}
     * @memberof PersonalProfileDto
     */
    'isActiveStudent': boolean;
}
/**
 *
 * @export
 * @interface ProfileCourseDto
 */
export interface ProfileCourseDto {
    /**
     *
     * @type {number}
     * @memberof ProfileCourseDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'createdDate': string;
    /**
     *
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'updatedDate': string;
    /**
     *
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'fullName': string;
    /**
     *
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'alias': string;
    /**
     *
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'description': string;
    /**
     *
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'descriptionUrl': string;
    /**
     *
     * @type {number}
     * @memberof ProfileCourseDto
     */
    'year': number;
    /**
     *
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'startDate': string;
    /**
     *
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'endDate': string;
    /**
     *
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'registrationEndDate': string;
    /**
     *
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'primarySkillId': string;
    /**
     *
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'primarySkillName': string;
    /**
     *
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'locationName': string;
    /**
     *
     * @type {number}
     * @memberof ProfileCourseDto
     */
    'discordServerId': number;
    /**
     *
     * @type {boolean}
     * @memberof ProfileCourseDto
     */
    'completed': boolean;
    /**
     *
     * @type {boolean}
     * @memberof ProfileCourseDto
     */
    'planned': boolean;
    /**
     *
     * @type {boolean}
     * @memberof ProfileCourseDto
     */
    'inviteOnly': boolean;
    /**
     *
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'certificateIssuer': string;
    /**
     *
     * @type {boolean}
     * @memberof ProfileCourseDto
     */
    'usePrivateRepositories': boolean;
    /**
     *
     * @type {boolean}
     * @memberof ProfileCourseDto
     */
    'personalMentoring': boolean;
    /**
     *
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'logo': string;
    /**
     *
     * @type {IdNameDto}
     * @memberof ProfileCourseDto
     */
    'discipline': IdNameDto | null;
}
/**
 *
 * @export
 * @interface ProfileDto
 */
export interface ProfileDto {
    /**
     *
     * @type {string}
     * @memberof ProfileDto
     */
    'publicCvUrl': string | null;
}
/**
 *
 * @export
 * @interface ProfileInfoDto
 */
export interface ProfileInfoDto {
    /**
     *
     * @type {ConfigurableProfilePermissions}
     * @memberof ProfileInfoDto
     */
    'permissionsSettings': ConfigurableProfilePermissions;
    /**
     *
     * @type {GeneralInfo}
     * @memberof ProfileInfoDto
     */
    'generalInfo': GeneralInfo;
    /**
     *
     * @type {ContactsDto}
     * @memberof ProfileInfoDto
     */
    'contacts': ContactsDto;
    /**
     *
     * @type {Discord}
     * @memberof ProfileInfoDto
     */
    'discord'?: Discord | null;
    /**
     *
     * @type {boolean}
     * @memberof ProfileInfoDto
     */
    'isPermissionsSettingsChanged': boolean;
    /**
     *
     * @type {boolean}
     * @memberof ProfileInfoDto
     */
    'isProfileSettingsChanged': boolean;
}
/**
 *
 * @export
 * @interface PromptDto
 */
export interface PromptDto {
    /**
     *
     * @type {number}
     * @memberof PromptDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof PromptDto
     */
    'type': string;
    /**
     *
     * @type {string}
     * @memberof PromptDto
     */
    'text': string;
    /**
     *
     * @type {number}
     * @memberof PromptDto
     */
    'temperature': number;
}
/**
 *
 * @export
 * @interface PublicVisibilitySettings
 */
export interface PublicVisibilitySettings {
    /**
     *
     * @type {boolean}
     * @memberof PublicVisibilitySettings
     */
    'all': boolean;
}
/**
 *
 * @export
 * @interface PutInterviewFeedbackDto
 */
export interface PutInterviewFeedbackDto {
    /**
     *
     * @type {number}
     * @memberof PutInterviewFeedbackDto
     */
    'version': number;
    /**
     *
     * @type {object}
     * @memberof PutInterviewFeedbackDto
     */
    'json': object;
    /**
     *
     * @type {string}
     * @memberof PutInterviewFeedbackDto
     */
    'decision'?: string;
    /**
     *
     * @type {boolean}
     * @memberof PutInterviewFeedbackDto
     */
    'isGoodCandidate'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PutInterviewFeedbackDto
     */
    'isCompleted': boolean;
    /**
     *
     * @type {number}
     * @memberof PutInterviewFeedbackDto
     */
    'score'?: number;
}
/**
 *
 * @export
 * @interface ResumeCourseDto
 */
export interface ResumeCourseDto {
    /**
     *
     * @type {number}
     * @memberof ResumeCourseDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof ResumeCourseDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof ResumeCourseDto
     */
    'fullName': string;
    /**
     *
     * @type {number}
     * @memberof ResumeCourseDto
     */
    'rank': number;
    /**
     *
     * @type {number}
     * @memberof ResumeCourseDto
     */
    'totalScore': number;
    /**
     *
     * @type {string}
     * @memberof ResumeCourseDto
     */
    'certificateId': string | null;
    /**
     *
     * @type {boolean}
     * @memberof ResumeCourseDto
     */
    'completed': boolean;
    /**
     *
     * @type {ResumeCourseMentor}
     * @memberof ResumeCourseDto
     */
    'mentor': ResumeCourseMentor | null;
    /**
     *
     * @type {string}
     * @memberof ResumeCourseDto
     */
    'locationName': string;
}
/**
 *
 * @export
 * @interface ResumeCourseMentor
 */
export interface ResumeCourseMentor {
    /**
     *
     * @type {string}
     * @memberof ResumeCourseMentor
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof ResumeCourseMentor
     */
    'githubId': string;
    /**
     *
     * @type {number}
     * @memberof ResumeCourseMentor
     */
    'id': number;
}
/**
 *
 * @export
 * @interface ResumeDto
 */
export interface ResumeDto {
    /**
     *
     * @type {string}
     * @memberof ResumeDto
     */
    'uuid': string;
    /**
     *
     * @type {string}
     * @memberof ResumeDto
     */
    'avatarLink': string | null;
    /**
     *
     * @type {Array<number>}
     * @memberof ResumeDto
     */
    'visibleCourses': Array<number>;
    /**
     *
     * @type {Array<ResumeCourseDto>}
     * @memberof ResumeDto
     */
    'courses': Array<ResumeCourseDto>;
    /**
     *
     * @type {string}
     * @memberof ResumeDto
     */
    'desiredPosition': string | null;
    /**
     *
     * @type {string}
     * @memberof ResumeDto
     */
    'email': string | null;
    /**
     *
     * @type {string}
     * @memberof ResumeDto
     */
    'englishLevel': ResumeDtoEnglishLevelEnum;
    /**
     *
     * @type {number}
     * @memberof ResumeDto
     */
    'expires': number | null;
    /**
     *
     * @type {Array<GratitudeDto>}
     * @memberof ResumeDto
     */
    'gratitudes': Array<GratitudeDto>;
    /**
     *
     * @type {Array<FeedbackDto>}
     * @memberof ResumeDto
     */
    'feedbacks': Array<FeedbackDto>;
    /**
     *
     * @type {boolean}
     * @memberof ResumeDto
     */
    'fullTime': boolean;
    /**
     *
     * @type {string}
     * @memberof ResumeDto
     */
    'githubUsername': string | null;
    /**
     *
     * @type {number}
     * @memberof ResumeDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof ResumeDto
     */
    'linkedin': string | null;
    /**
     *
     * @type {string}
     * @memberof ResumeDto
     */
    'locations': string | null;
    /**
     *
     * @type {string}
     * @memberof ResumeDto
     */
    'militaryService': ResumeDtoMilitaryServiceEnum;
    /**
     *
     * @type {string}
     * @memberof ResumeDto
     */
    'name': string | null;
    /**
     *
     * @type {string}
     * @memberof ResumeDto
     */
    'notes': string | null;
    /**
     *
     * @type {string}
     * @memberof ResumeDto
     */
    'phone': string | null;
    /**
     *
     * @type {string}
     * @memberof ResumeDto
     */
    'selfIntroLink': string | null;
    /**
     *
     * @type {string}
     * @memberof ResumeDto
     */
    'skype': string | null;
    /**
     *
     * @type {string}
     * @memberof ResumeDto
     */
    'startFrom': string | null;
    /**
     *
     * @type {string}
     * @memberof ResumeDto
     */
    'telegram': string | null;
    /**
     *
     * @type {string}
     * @memberof ResumeDto
     */
    'website': string | null;
}

export const ResumeDtoEnglishLevelEnum = {
    Unknown: 'unknown',
    A0: 'a0',
    A1: 'a1',
    A2: 'a2',
    B1: 'b1',
    B2: 'b2',
    C1: 'c1',
    C2: 'c2'
} as const;

export type ResumeDtoEnglishLevelEnum = typeof ResumeDtoEnglishLevelEnum[keyof typeof ResumeDtoEnglishLevelEnum];
export const ResumeDtoMilitaryServiceEnum = {
    Served: 'served',
    Liable: 'liable',
    NotLiable: 'notLiable'
} as const;

export type ResumeDtoMilitaryServiceEnum = typeof ResumeDtoMilitaryServiceEnum[keyof typeof ResumeDtoMilitaryServiceEnum];

/**
 *
 * @export
 * @interface SaveCertificateDto
 */
export interface SaveCertificateDto {
    /**
     *
     * @type {string}
     * @memberof SaveCertificateDto
     */
    'publicId': string;
    /**
     *
     * @type {number}
     * @memberof SaveCertificateDto
     */
    'studentId': number;
    /**
     *
     * @type {string}
     * @memberof SaveCertificateDto
     */
    's3Bucket': string;
    /**
     *
     * @type {string}
     * @memberof SaveCertificateDto
     */
    's3Key': string;
    /**
     *
     * @type {string}
     * @memberof SaveCertificateDto
     */
    'issueDate': string;
}
/**
 *
 * @export
 * @interface SaveTaskSolutionDto
 */
export interface SaveTaskSolutionDto {
    /**
     *
     * @type {string}
     * @memberof SaveTaskSolutionDto
     */
    'url': string;
}
/**
 *
 * @export
 * @interface ScoreDto
 */
export interface ScoreDto {
    /**
     *
     * @type {Array<ScoreStudentDto>}
     * @memberof ScoreDto
     */
    'content': Array<ScoreStudentDto>;
    /**
     *
     * @type {PaginationMetaDto}
     * @memberof ScoreDto
     */
    'pagination': PaginationMetaDto;
}
/**
 *
 * @export
 * @interface ScoreStudentDto
 */
export interface ScoreStudentDto {
    /**
     *
     * @type {string}
     * @memberof ScoreStudentDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof ScoreStudentDto
     */
    'githubId': string;
    /**
     *
     * @type {number}
     * @memberof ScoreStudentDto
     */
    'id': number;
    /**
     *
     * @type {boolean}
     * @memberof ScoreStudentDto
     */
    'active': boolean;
    /**
     *
     * @type {string}
     * @memberof ScoreStudentDto
     */
    'cityName': string | null;
    /**
     *
     * @type {string}
     * @memberof ScoreStudentDto
     */
    'countryName': string | null;
    /**
     *
     * @type {number}
     * @memberof ScoreStudentDto
     */
    'totalScore': number;
    /**
     *
     * @type {number}
     * @memberof ScoreStudentDto
     */
    'rank': number;
    /**
     *
     * @type {MentorDto}
     * @memberof ScoreStudentDto
     */
    'mentor': MentorDto | null;
    /**
     *
     * @type {string}
     * @memberof ScoreStudentDto
     */
    'totalScoreChangeDate': string;
    /**
     *
     * @type {number}
     * @memberof ScoreStudentDto
     */
    'crossCheckScore': number;
    /**
     *
     * @type {string}
     * @memberof ScoreStudentDto
     */
    'repositoryLastActivityDate': string;
    /**
     *
     * @type {Array<TaskResultsDto>}
     * @memberof ScoreStudentDto
     */
    'taskResults': Array<TaskResultsDto>;
    /**
     *
     * @type {boolean}
     * @memberof ScoreStudentDto
     */
    'isActive': boolean;
    /**
     *
     * @type {ContactsDto}
     * @memberof ScoreStudentDto
     */
    'contacts': ContactsDto;
}
/**
 *
 * @export
 * @interface SearchMentorDto
 */
export interface SearchMentorDto {
    /**
     *
     * @type {number}
     * @memberof SearchMentorDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof SearchMentorDto
     */
    'githubId': string;
    /**
     *
     * @type {string}
     * @memberof SearchMentorDto
     */
    'name': string;
}
/**
 *
 * @export
 * @interface SelfEducationQuestionSelectedAnswersDto
 */
export interface SelfEducationQuestionSelectedAnswersDto {
    /**
     *
     * @type {Array<string>}
     * @memberof SelfEducationQuestionSelectedAnswersDto
     */
    'answers': Array<string>;
    /**
     *
     * @type {string}
     * @memberof SelfEducationQuestionSelectedAnswersDto
     */
    'question': string;
    /**
     *
     * @type {boolean}
     * @memberof SelfEducationQuestionSelectedAnswersDto
     */
    'multiple': boolean;
    /**
     *
     * @type {string}
     * @memberof SelfEducationQuestionSelectedAnswersDto
     */
    'questionImage': string;
    /**
     *
     * @type {string}
     * @memberof SelfEducationQuestionSelectedAnswersDto
     */
    'answersType': string;
    /**
     *
     * @type {Array<number>}
     * @memberof SelfEducationQuestionSelectedAnswersDto
     */
    'selectedAnswers': Array<number>;
}
/**
 *
 * @export
 * @interface SendUserNotificationDto
 */
export interface SendUserNotificationDto {
    /**
     *
     * @type {string}
     * @memberof SendUserNotificationDto
     */
    'notificationId': string;
    /**
     *
     * @type {number}
     * @memberof SendUserNotificationDto
     */
    'userId': number;
    /**
     *
     * @type {object}
     * @memberof SendUserNotificationDto
     */
    'data': object;
    /**
     *
     * @type {number}
     * @memberof SendUserNotificationDto
     */
    'expireDate': number;
}
/**
 *
 * @export
 * @interface SenderDto
 */
export interface SenderDto {
    /**
     *
     * @type {SenderLoginDto}
     * @memberof SenderDto
     */
    'login': SenderLoginDto;
}
/**
 *
 * @export
 * @interface SenderLoginDto
 */
export interface SenderLoginDto {
    /**
     *
     * @type {string}
     * @memberof SenderLoginDto
     */
    'githubId': string;
}
/**
 *
 * @export
 * @interface SoftSkillEntry
 */
export interface SoftSkillEntry {
    /**
     *
     * @type {string}
     * @memberof SoftSkillEntry
     */
    'id': SoftSkillEntryIdEnum;
    /**
     *
     * @type {string}
     * @memberof SoftSkillEntry
     */
    'value': SoftSkillEntryValueEnum;
}

export const SoftSkillEntryIdEnum = {
    Responsible: 'skill.soft.responsible',
    TeamPlayer: 'skill.soft.team-player',
    Communicable: 'skill.soft.communicable'
} as const;

export type SoftSkillEntryIdEnum = typeof SoftSkillEntryIdEnum[keyof typeof SoftSkillEntryIdEnum];
export const SoftSkillEntryValueEnum = {
    None: 'None',
    Poor: 'Poor',
    Fair: 'Fair',
    Good: 'Good',
    Great: 'Great',
    Excellent: 'Excellent'
} as const;

export type SoftSkillEntryValueEnum = typeof SoftSkillEntryValueEnum[keyof typeof SoftSkillEntryValueEnum];

/**
 *
 * @export
 * @interface StatusDto
 */
export interface StatusDto {
    /**
     *
     * @type {number}
     * @memberof StatusDto
     */
    'expires': number;
}
/**
 *
 * @export
 * @interface StudentDto
 */
export interface StudentDto {
    /**
     *
     * @type {string}
     * @memberof StudentDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof StudentDto
     */
    'githubId': string;
    /**
     *
     * @type {number}
     * @memberof StudentDto
     */
    'id': number;
    /**
     *
     * @type {boolean}
     * @memberof StudentDto
     */
    'active': boolean;
    /**
     *
     * @type {string}
     * @memberof StudentDto
     */
    'cityName': string | null;
    /**
     *
     * @type {string}
     * @memberof StudentDto
     */
    'countryName': string | null;
    /**
     *
     * @type {number}
     * @memberof StudentDto
     */
    'totalScore': number;
    /**
     *
     * @type {number}
     * @memberof StudentDto
     */
    'rank': number;
}
/**
 *
 * @export
 * @interface StudentFeedback
 */
export interface StudentFeedback {
    /**
     *
     * @type {number}
     * @memberof StudentFeedback
     */
    'id': number;
}
/**
 *
 * @export
 * @interface StudentFeedbackContentDto
 */
export interface StudentFeedbackContentDto {
    /**
     *
     * @type {string}
     * @memberof StudentFeedbackContentDto
     */
    'suggestions': string;
    /**
     *
     * @type {string}
     * @memberof StudentFeedbackContentDto
     */
    'recommendationComment': string;
    /**
     *
     * @type {Array<SoftSkillEntry>}
     * @memberof StudentFeedbackContentDto
     */
    'softSkills': Array<SoftSkillEntry>;
}
/**
 *
 * @export
 * @interface StudentFeedbackDto
 */
export interface StudentFeedbackDto {
    /**
     *
     * @type {number}
     * @memberof StudentFeedbackDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof StudentFeedbackDto
     */
    'createdDate': string;
    /**
     *
     * @type {string}
     * @memberof StudentFeedbackDto
     */
    'updatedDate': string;
    /**
     *
     * @type {StudentFeedbackContentDto}
     * @memberof StudentFeedbackDto
     */
    'content': StudentFeedbackContentDto;
    /**
     *
     * @type {string}
     * @memberof StudentFeedbackDto
     */
    'recommendation': StudentFeedbackDtoRecommendationEnum;
    /**
     *
     * @type {PersonDto}
     * @memberof StudentFeedbackDto
     */
    'author': PersonDto;
    /**
     *
     * @type {PersonDto}
     * @memberof StudentFeedbackDto
     */
    'mentor': PersonDto | null;
    /**
     *
     * @type {string}
     * @memberof StudentFeedbackDto
     */
    'englishLevel': StudentFeedbackDtoEnglishLevelEnum;
}

export const StudentFeedbackDtoRecommendationEnum = {
    Hire: 'hire',
    NotHire: 'not-hire'
} as const;

export type StudentFeedbackDtoRecommendationEnum = typeof StudentFeedbackDtoRecommendationEnum[keyof typeof StudentFeedbackDtoRecommendationEnum];
export const StudentFeedbackDtoEnglishLevelEnum = {
    Unknown: 'unknown',
    A0: 'a0',
    A1: 'a1',
    A2: 'a2',
    B1: 'b1',
    B2: 'b2',
    C1: 'c1',
    C2: 'c2'
} as const;

export type StudentFeedbackDtoEnglishLevelEnum = typeof StudentFeedbackDtoEnglishLevelEnum[keyof typeof StudentFeedbackDtoEnglishLevelEnum];

/**
 *
 * @export
 * @interface StudentId
 */
export interface StudentId {
    /**
     *
     * @type {number}
     * @memberof StudentId
     */
    'id': number;
}
/**
 *
 * @export
 * @interface StudentsDto
 */
export interface StudentsDto {
    /**
     *
     * @type {number}
     * @memberof StudentsDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof StudentsDto
     */
    'githubId': string;
    /**
     *
     * @type {string}
     * @memberof StudentsDto
     */
    'name': string;
}
/**
 *
 * @export
 * @interface TaskCriteriaDto
 */
export interface TaskCriteriaDto {
    /**
     *
     * @type {Array<CriteriaDto>}
     * @memberof TaskCriteriaDto
     */
    'criteria': Array<CriteriaDto>;
}
/**
 *
 * @export
 * @interface TaskDto
 */
export interface TaskDto {
    /**
     *
     * @type {string}
     * @memberof TaskDto
     */
    'type': TaskDtoTypeEnum;
    /**
     *
     * @type {string}
     * @memberof TaskDto
     */
    'name': string;
    /**
     *
     * @type {number}
     * @memberof TaskDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof TaskDto
     */
    'descriptionUrl': string;
    /**
     *
     * @type {string}
     * @memberof TaskDto
     */
    'description': string;
    /**
     *
     * @type {string}
     * @memberof TaskDto
     */
    'githubRepoName': string;
    /**
     *
     * @type {string}
     * @memberof TaskDto
     */
    'sourceGithubRepoUrl': string;
    /**
     *
     * @type {IdNameDto}
     * @memberof TaskDto
     */
    'discipline': IdNameDto;
    /**
     *
     * @type {boolean}
     * @memberof TaskDto
     */
    'githubPrRequired': boolean;
    /**
     *
     * @type {string}
     * @memberof TaskDto
     */
    'createdDate': string;
    /**
     *
     * @type {string}
     * @memberof TaskDto
     */
    'updatedDate': string;
    /**
     *
     * @type {Array<string>}
     * @memberof TaskDto
     */
    'tags': Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof TaskDto
     */
    'skills': Array<string>;
    /**
     *
     * @type {object}
     * @memberof TaskDto
     */
    'attributes': object;
    /**
     *
     * @type {Array<UsedCourseDto>}
     * @memberof TaskDto
     */
    'courses': Array<UsedCourseDto>;
}

export const TaskDtoTypeEnum = {
    Jstask: 'jstask',
    Kotlintask: 'kotlintask',
    Objctask: 'objctask',
    Htmltask: 'htmltask',
    Ipynb: 'ipynb',
    Selfeducation: 'selfeducation',
    Codewars: 'codewars',
    Test: 'test',
    Codejam: 'codejam',
    Interview: 'interview',
    StageInterview: 'stage-interview',
    Cvhtml: 'cv:html',
    Cvmarkdown: 'cv:markdown'
} as const;

export type TaskDtoTypeEnum = typeof TaskDtoTypeEnum[keyof typeof TaskDtoTypeEnum];

/**
 *
 * @export
 * @interface TaskResultsDto
 */
export interface TaskResultsDto {
    /**
     *
     * @type {number}
     * @memberof TaskResultsDto
     */
    'courseTaskId': number;
    /**
     *
     * @type {number}
     * @memberof TaskResultsDto
     */
    'score': number;
}
/**
 *
 * @export
 * @interface TaskSolutionDto
 */
export interface TaskSolutionDto {
    /**
     *
     * @type {number}
     * @memberof TaskSolutionDto
     */
    'id': number;
    /**
     *
     * @type {number}
     * @memberof TaskSolutionDto
     */
    'courseTaskId': number;
    /**
     *
     * @type {string}
     * @memberof TaskSolutionDto
     */
    'url': string;
}
/**
 *
 * @export
 * @interface TaskVerificationAttemptDto
 */
export interface TaskVerificationAttemptDto {
    /**
     *
     * @type {number}
     * @memberof TaskVerificationAttemptDto
     */
    'createdDate': number;
    /**
     *
     * @type {number}
     * @memberof TaskVerificationAttemptDto
     */
    'courseTaskId': number;
    /**
     *
     * @type {number}
     * @memberof TaskVerificationAttemptDto
     */
    'score': number;
    /**
     *
     * @type {number}
     * @memberof TaskVerificationAttemptDto
     */
    'maxScore': number;
    /**
     *
     * @type {Array<SelfEducationQuestionSelectedAnswersDto>}
     * @memberof TaskVerificationAttemptDto
     */
    'questions': Array<SelfEducationQuestionSelectedAnswersDto>;
}
/**
 *
 * @export
 * @interface TeamDistributionDetailedDto
 */
export interface TeamDistributionDetailedDto {
    /**
     *
     * @type {number}
     * @memberof TeamDistributionDetailedDto
     */
    'id': number;
    /**
     *
     * @type {number}
     * @memberof TeamDistributionDetailedDto
     */
    'courseId': number;
    /**
     *
     * @type {string}
     * @memberof TeamDistributionDetailedDto
     */
    'name': string;
    /**
     *
     * @type {number}
     * @memberof TeamDistributionDetailedDto
     */
    'studentsWithoutTeamCount': number;
    /**
     *
     * @type {number}
     * @memberof TeamDistributionDetailedDto
     */
    'teamsCount': number;
    /**
     *
     * @type {TeamDto}
     * @memberof TeamDistributionDetailedDto
     */
    'myTeam': TeamDto;
    /**
     *
     * @type {number}
     * @memberof TeamDistributionDetailedDto
     */
    'minTeamSize': number;
    /**
     *
     * @type {number}
     * @memberof TeamDistributionDetailedDto
     */
    'maxTeamSize': number;
    /**
     *
     * @type {number}
     * @memberof TeamDistributionDetailedDto
     */
    'strictTeamSize': number;
    /**
     *
     * @type {boolean}
     * @memberof TeamDistributionDetailedDto
     */
    'strictTeamSizeMode': boolean;
}
/**
 *
 * @export
 * @interface TeamDistributionDto
 */
export interface TeamDistributionDto {
    /**
     *
     * @type {number}
     * @memberof TeamDistributionDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof TeamDistributionDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof TeamDistributionDto
     */
    'registrationStatus': TeamDistributionDtoRegistrationStatusEnum;
    /**
     *
     * @type {string}
     * @memberof TeamDistributionDto
     */
    'startDate': string;
    /**
     *
     * @type {string}
     * @memberof TeamDistributionDto
     */
    'endDate': string;
    /**
     *
     * @type {string}
     * @memberof TeamDistributionDto
     */
    'description': string;
    /**
     *
     * @type {string}
     * @memberof TeamDistributionDto
     */
    'descriptionUrl': string;
    /**
     *
     * @type {number}
     * @memberof TeamDistributionDto
     */
    'minTeamSize': number;
    /**
     *
     * @type {number}
     * @memberof TeamDistributionDto
     */
    'maxTeamSize': number;
    /**
     *
     * @type {number}
     * @memberof TeamDistributionDto
     */
    'strictTeamSize': number;
    /**
     *
     * @type {boolean}
     * @memberof TeamDistributionDto
     */
    'strictTeamSizeMode': boolean;
    /**
     *
     * @type {number}
     * @memberof TeamDistributionDto
     */
    'minTotalScore': number;
}

export const TeamDistributionDtoRegistrationStatusEnum = {
    Available: 'available',
    Unavailable: 'unavailable',
    Future: 'future',
    Completed: 'completed',
    Distributed: 'distributed',
    Closed: 'closed'
} as const;

export type TeamDistributionDtoRegistrationStatusEnum = typeof TeamDistributionDtoRegistrationStatusEnum[keyof typeof TeamDistributionDtoRegistrationStatusEnum];

/**
 *
 * @export
 * @interface TeamDistributionStudentDto
 */
export interface TeamDistributionStudentDto {
    /**
     *
     * @type {number}
     * @memberof TeamDistributionStudentDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof TeamDistributionStudentDto
     */
    'fullName': string;
    /**
     *
     * @type {string}
     * @memberof TeamDistributionStudentDto
     */
    'cvLink': string;
    /**
     *
     * @type {Discord}
     * @memberof TeamDistributionStudentDto
     */
    'discord': Discord | null;
    /**
     *
     * @type {string}
     * @memberof TeamDistributionStudentDto
     */
    'telegram': string;
    /**
     *
     * @type {string}
     * @memberof TeamDistributionStudentDto
     */
    'email': string;
    /**
     *
     * @type {string}
     * @memberof TeamDistributionStudentDto
     */
    'githubId': string;
    /**
     *
     * @type {number}
     * @memberof TeamDistributionStudentDto
     */
    'rank': number;
    /**
     *
     * @type {number}
     * @memberof TeamDistributionStudentDto
     */
    'totalScore': number;
    /**
     *
     * @type {string}
     * @memberof TeamDistributionStudentDto
     */
    'location': string;
    /**
     *
     * @type {string}
     * @memberof TeamDistributionStudentDto
     */
    'cvUuid': string;
}
/**
 *
 * @export
 * @interface TeamDto
 */
export interface TeamDto {
    /**
     *
     * @type {number}
     * @memberof TeamDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof TeamDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof TeamDto
     */
    'chatLink': string;
    /**
     *
     * @type {string}
     * @memberof TeamDto
     */
    'description': string;
    /**
     *
     * @type {number}
     * @memberof TeamDto
     */
    'teamLeadId': number;
    /**
     *
     * @type {number}
     * @memberof TeamDto
     */
    'teamDistributionId': number;
    /**
     *
     * @type {Array<TeamDistributionStudentDto>}
     * @memberof TeamDto
     */
    'students': Array<TeamDistributionStudentDto>;
}
/**
 *
 * @export
 * @interface TeamInfoDto
 */
export interface TeamInfoDto {
    /**
     *
     * @type {number}
     * @memberof TeamInfoDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof TeamInfoDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof TeamInfoDto
     */
    'chatLink': string;
    /**
     *
     * @type {string}
     * @memberof TeamInfoDto
     */
    'description': string;
    /**
     *
     * @type {number}
     * @memberof TeamInfoDto
     */
    'teamLeadId': number;
    /**
     *
     * @type {number}
     * @memberof TeamInfoDto
     */
    'teamDistributionId': number;
}
/**
 *
 * @export
 * @interface TeamPasswordDto
 */
export interface TeamPasswordDto {
    /**
     *
     * @type {string}
     * @memberof TeamPasswordDto
     */
    'password': string;
}
/**
 *
 * @export
 * @interface TeamsDto
 */
export interface TeamsDto {
    /**
     *
     * @type {Array<TeamDto>}
     * @memberof TeamsDto
     */
    'content': Array<TeamDto>;
    /**
     *
     * @type {PaginationMetaDto}
     * @memberof TeamsDto
     */
    'pagination': PaginationMetaDto;
}
/**
 *
 * @export
 * @interface UpdateCourseDto
 */
export interface UpdateCourseDto {
    /**
     *
     * @type {string}
     * @memberof UpdateCourseDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof UpdateCourseDto
     */
    'fullName': string;
    /**
     *
     * @type {string}
     * @memberof UpdateCourseDto
     */
    'alias': string;
    /**
     *
     * @type {string}
     * @memberof UpdateCourseDto
     */
    'description'?: string;
    /**
     *
     * @type {number}
     * @memberof UpdateCourseDto
     */
    'year'?: number;
    /**
     *
     * @type {string}
     * @memberof UpdateCourseDto
     */
    'startDate'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateCourseDto
     */
    'endDate'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateCourseDto
     */
    'registrationEndDate'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateCourseDto
     */
    'locationName'?: string;
    /**
     *
     * @type {number}
     * @memberof UpdateCourseDto
     */
    'discordServerId'?: number;
    /**
     *
     * @type {boolean}
     * @memberof UpdateCourseDto
     */
    'completed'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof UpdateCourseDto
     */
    'planned'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof UpdateCourseDto
     */
    'inviteOnly'?: boolean;
    /**
     *
     * @type {string}
     * @memberof UpdateCourseDto
     */
    'certificateIssuer'?: string;
    /**
     *
     * @type {boolean}
     * @memberof UpdateCourseDto
     */
    'usePrivateRepositories'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof UpdateCourseDto
     */
    'personalMentoring'?: boolean;
    /**
     *
     * @type {string}
     * @memberof UpdateCourseDto
     */
    'logo'?: string;
    /**
     *
     * @type {number}
     * @memberof UpdateCourseDto
     */
    'disciplineId'?: number;
}
/**
 *
 * @export
 * @interface UpdateCourseEventDto
 */
export interface UpdateCourseEventDto {
    /**
     *
     * @type {string}
     * @memberof UpdateCourseEventDto
     */
    'special'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateCourseEventDto
     */
    'dateTime'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateCourseEventDto
     */
    'endTime'?: string;
    /**
     *
     * @type {number}
     * @memberof UpdateCourseEventDto
     */
    'duration'?: number;
    /**
     *
     * @type {string}
     * @memberof UpdateCourseEventDto
     */
    'place'?: string;
    /**
     *
     * @type {Organizer}
     * @memberof UpdateCourseEventDto
     */
    'organizer'?: Organizer;
    /**
     *
     * @type {number}
     * @memberof UpdateCourseEventDto
     */
    'organizerId'?: number;
    /**
     *
     * @type {string}
     * @memberof UpdateCourseEventDto
     */
    'broadcastUrl'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateCourseEventDto
     */
    'coordinator'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateCourseEventDto
     */
    'comment'?: string;
}
/**
 *
 * @export
 * @interface UpdateCourseTaskDto
 */
export interface UpdateCourseTaskDto {
    /**
     *
     * @type {string}
     * @memberof UpdateCourseTaskDto
     */
    'type'?: UpdateCourseTaskDtoTypeEnum;
    /**
     *
     * @type {string}
     * @memberof UpdateCourseTaskDto
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateCourseTaskDto
     */
    'checker'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateCourseTaskDto
     */
    'studentStartDate': string;
    /**
     *
     * @type {string}
     * @memberof UpdateCourseTaskDto
     */
    'studentEndDate': string;
    /**
     *
     * @type {string}
     * @memberof UpdateCourseTaskDto
     */
    'descriptionUrl'?: string;
    /**
     *
     * @type {number}
     * @memberof UpdateCourseTaskDto
     */
    'taskOwnerId'?: number;
    /**
     *
     * @type {number}
     * @memberof UpdateCourseTaskDto
     */
    'maxScore'?: number;
    /**
     *
     * @type {number}
     * @memberof UpdateCourseTaskDto
     */
    'scoreWeight'?: number;
    /**
     *
     * @type {number}
     * @memberof UpdateCourseTaskDto
     */
    'pairsCount'?: number;
    /**
     *
     * @type {number}
     * @memberof UpdateCourseTaskDto
     */
    'taskId'?: number;
    /**
     *
     * @type {string}
     * @memberof UpdateCourseTaskDto
     */
    'crossCheckEndDate'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateCourseTaskDto
     */
    'submitText': string;
    /**
     *
     * @type {object}
     * @memberof UpdateCourseTaskDto
     */
    'validations': object;
}

export const UpdateCourseTaskDtoTypeEnum = {
    Jstask: 'jstask',
    Kotlintask: 'kotlintask',
    Objctask: 'objctask',
    Htmltask: 'htmltask',
    Ipynb: 'ipynb',
    Selfeducation: 'selfeducation',
    Codewars: 'codewars',
    Test: 'test',
    Codejam: 'codejam',
    Interview: 'interview',
    StageInterview: 'stage-interview',
    Cvhtml: 'cv:html',
    Cvmarkdown: 'cv:markdown'
} as const;

export type UpdateCourseTaskDtoTypeEnum = typeof UpdateCourseTaskDtoTypeEnum[keyof typeof UpdateCourseTaskDtoTypeEnum];

/**
 *
 * @export
 * @interface UpdateCourseUserDto
 */
export interface UpdateCourseUserDto {
    /**
     *
     * @type {boolean}
     * @memberof UpdateCourseUserDto
     */
    'isManager': boolean;
    /**
     *
     * @type {boolean}
     * @memberof UpdateCourseUserDto
     */
    'isSupervisor': boolean;
    /**
     *
     * @type {boolean}
     * @memberof UpdateCourseUserDto
     */
    'isDementor': boolean;
    /**
     *
     * @type {number}
     * @memberof UpdateCourseUserDto
     */
    'userId': number;
}
/**
 *
 * @export
 * @interface UpdateDisciplineDto
 */
export interface UpdateDisciplineDto {
    /**
     *
     * @type {string}
     * @memberof UpdateDisciplineDto
     */
    'name': string;
}
/**
 *
 * @export
 * @interface UpdateDiscordServerDto
 */
export interface UpdateDiscordServerDto {
    /**
     *
     * @type {string}
     * @memberof UpdateDiscordServerDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof UpdateDiscordServerDto
     */
    'gratitudeUrl': string;
    /**
     *
     * @type {string}
     * @memberof UpdateDiscordServerDto
     */
    'mentorsChatUrl': string;
}
/**
 *
 * @export
 * @interface UpdateEventDto
 */
export interface UpdateEventDto {
    /**
     *
     * @type {string}
     * @memberof UpdateEventDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof UpdateEventDto
     */
    'type': string;
    /**
     *
     * @type {number}
     * @memberof UpdateEventDto
     */
    'disciplineId': number;
    /**
     *
     * @type {string}
     * @memberof UpdateEventDto
     */
    'descriptionUrl': string;
    /**
     *
     * @type {string}
     * @memberof UpdateEventDto
     */
    'description': string;
}
/**
 *
 * @export
 * @interface UpdateNotificationDto
 */
export interface UpdateNotificationDto {
    /**
     *
     * @type {string}
     * @memberof UpdateNotificationDto
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof UpdateNotificationDto
     */
    'name': string;
    /**
     *
     * @type {boolean}
     * @memberof UpdateNotificationDto
     */
    'enabled': boolean;
    /**
     *
     * @type {Array<ChannelSettings>}
     * @memberof UpdateNotificationDto
     */
    'channels': Array<ChannelSettings>;
    /**
     *
     * @type {NotificationType}
     * @memberof UpdateNotificationDto
     */
    'type': NotificationType;
    /**
     *
     * @type {string}
     * @memberof UpdateNotificationDto
     */
    'parentId': string;
}
/**
 *
 * @export
 * @interface UpdateNotificationUserSettingsDto
 */
export interface UpdateNotificationUserSettingsDto {
    /**
     *
     * @type {string}
     * @memberof UpdateNotificationUserSettingsDto
     */
    'notificationId': string;
    /**
     *
     * @type {boolean}
     * @memberof UpdateNotificationUserSettingsDto
     */
    'enabled': boolean;
    /**
     *
     * @type {string}
     * @memberof UpdateNotificationUserSettingsDto
     */
    'channelId': string;
}
/**
 *
 * @export
 * @interface UpdateProfileInfoDto
 */
export interface UpdateProfileInfoDto {
    /**
     *
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'githubId'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'aboutMyself'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'cityName'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'countryName'?: string | null;
    /**
     *
     * @type {Array<Education>}
     * @memberof UpdateProfileInfoDto
     */
    'educationHistory'?: Array<Education> | null;
    /**
     *
     * @type {Array<EmploymentRecordDto>}
     * @memberof UpdateProfileInfoDto
     */
    'employmentHistory'?: Array<EmploymentRecordDto> | null;
    /**
     *
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'englishLevel'?: string | null;
    /**
     *
     * @type {Array<string>}
     * @memberof UpdateProfileInfoDto
     */
    'languages'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'contactsPhone'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'contactsEmail'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'contactsEpamEmail'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'contactsSkype'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'contactsWhatsApp'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'contactsTelegram'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'contactsNotes'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'contactsLinkedIn'?: string | null;
    /**
     *
     * @type {Discord}
     * @memberof UpdateProfileInfoDto
     */
    'discord'?: Discord | null;
}
/**
 *
 * @export
 * @interface UpdatePromptDto
 */
export interface UpdatePromptDto {
    /**
     *
     * @type {number}
     * @memberof UpdatePromptDto
     */
    'temperature': number;
    /**
     *
     * @type {string}
     * @memberof UpdatePromptDto
     */
    'type': string;
    /**
     *
     * @type {string}
     * @memberof UpdatePromptDto
     */
    'text': string;
}
/**
 *
 * @export
 * @interface UpdateStudentFeedbackDto
 */
export interface UpdateStudentFeedbackDto {
    /**
     *
     * @type {StudentFeedbackContentDto}
     * @memberof UpdateStudentFeedbackDto
     */
    'content': StudentFeedbackContentDto;
    /**
     *
     * @type {string}
     * @memberof UpdateStudentFeedbackDto
     */
    'recommendation': UpdateStudentFeedbackDtoRecommendationEnum;
    /**
     *
     * @type {string}
     * @memberof UpdateStudentFeedbackDto
     */
    'englishLevel': UpdateStudentFeedbackDtoEnglishLevelEnum;
}

export const UpdateStudentFeedbackDtoRecommendationEnum = {
    Hire: 'hire',
    NotHire: 'not-hire'
} as const;

export type UpdateStudentFeedbackDtoRecommendationEnum = typeof UpdateStudentFeedbackDtoRecommendationEnum[keyof typeof UpdateStudentFeedbackDtoRecommendationEnum];
export const UpdateStudentFeedbackDtoEnglishLevelEnum = {
    Unknown: 'unknown',
    A0: 'a0',
    A1: 'a1',
    A2: 'a2',
    B1: 'b1',
    B2: 'b2',
    C1: 'c1',
    C2: 'c2'
} as const;

export type UpdateStudentFeedbackDtoEnglishLevelEnum = typeof UpdateStudentFeedbackDtoEnglishLevelEnum[keyof typeof UpdateStudentFeedbackDtoEnglishLevelEnum];

/**
 *
 * @export
 * @interface UpdateTaskDto
 */
export interface UpdateTaskDto {
    /**
     *
     * @type {string}
     * @memberof UpdateTaskDto
     */
    'name': string;
    /**
     *
     * @type {object}
     * @memberof UpdateTaskDto
     */
    'attributes': object;
    /**
     *
     * @type {string}
     * @memberof UpdateTaskDto
     */
    'descriptionUrl': string;
    /**
     *
     * @type {string}
     * @memberof UpdateTaskDto
     */
    'description': string;
    /**
     *
     * @type {string}
     * @memberof UpdateTaskDto
     */
    'githubRepoName': string;
    /**
     *
     * @type {string}
     * @memberof UpdateTaskDto
     */
    'sourceGithubRepoUrl': string;
    /**
     *
     * @type {number}
     * @memberof UpdateTaskDto
     */
    'disciplineId': number;
    /**
     *
     * @type {boolean}
     * @memberof UpdateTaskDto
     */
    'githubPrRequired': boolean;
    /**
     *
     * @type {string}
     * @memberof UpdateTaskDto
     */
    'type': string;
    /**
     *
     * @type {Array<string>}
     * @memberof UpdateTaskDto
     */
    'skills': Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof UpdateTaskDto
     */
    'tags': Array<string>;
}
/**
 *
 * @export
 * @interface UpdateTeamDistributionDto
 */
export interface UpdateTeamDistributionDto {
    /**
     *
     * @type {string}
     * @memberof UpdateTeamDistributionDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof UpdateTeamDistributionDto
     */
    'startDate': string;
    /**
     *
     * @type {string}
     * @memberof UpdateTeamDistributionDto
     */
    'endDate': string;
    /**
     *
     * @type {string}
     * @memberof UpdateTeamDistributionDto
     */
    'description': string;
    /**
     *
     * @type {string}
     * @memberof UpdateTeamDistributionDto
     */
    'descriptionUrl': string;
    /**
     *
     * @type {number}
     * @memberof UpdateTeamDistributionDto
     */
    'minTeamSize': number;
    /**
     *
     * @type {number}
     * @memberof UpdateTeamDistributionDto
     */
    'maxTeamSize': number;
    /**
     *
     * @type {number}
     * @memberof UpdateTeamDistributionDto
     */
    'strictTeamSize': number;
    /**
     *
     * @type {boolean}
     * @memberof UpdateTeamDistributionDto
     */
    'strictTeamSizeMode': boolean;
    /**
     *
     * @type {number}
     * @memberof UpdateTeamDistributionDto
     */
    'minTotalScore': number;
}
/**
 *
 * @export
 * @interface UpdateTeamDto
 */
export interface UpdateTeamDto {
    /**
     *
     * @type {string}
     * @memberof UpdateTeamDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof UpdateTeamDto
     */
    'description': string;
    /**
     *
     * @type {string}
     * @memberof UpdateTeamDto
     */
    'chatLink': string;
    /**
     *
     * @type {Array<number>}
     * @memberof UpdateTeamDto
     */
    'studentIds'?: Array<number>;
}
/**
 *
 * @export
 * @interface UpdateUserDto
 */
export interface UpdateUserDto {
    /**
     *
     * @type {string}
     * @memberof UpdateUserDto
     */
    'firstName'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateUserDto
     */
    'lastName'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateUserDto
     */
    'primaryEmail'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateUserDto
     */
    'cityName'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateUserDto
     */
    'countryName'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateUserDto
     */
    'contactsNotes'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateUserDto
     */
    'contactsPhone'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateUserDto
     */
    'contactsEmail'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateUserDto
     */
    'contactsEpamEmail'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateUserDto
     */
    'contactsSkype'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateUserDto
     */
    'contactsWhatsApp'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateUserDto
     */
    'contactsTelegram'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateUserDto
     */
    'contactsLinkedIn'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateUserDto
     */
    'notes'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateUserDto
     */
    'aboutMyself'?: string | null;
    /**
     *
     * @type {Array<string>}
     * @memberof UpdateUserDto
     */
    'languages'?: Array<UpdateUserDtoLanguagesEnum>;
}

export const UpdateUserDtoLanguagesEnum = {
    En: 'EN',
    Zh: 'ZH',
    Hi: 'HI',
    Es: 'ES',
    Fr: 'FR',
    Ar: 'AR',
    Bn: 'BN',
    Ru: 'RU',
    Pt: 'PT',
    Id: 'ID',
    Ur: 'UR',
    Ja: 'JA',
    De: 'DE',
    Pa: 'PA',
    Te: 'TE',
    Tr: 'TR',
    Ko: 'KO',
    Mr: 'MR',
    Ky: 'KY',
    Kk: 'KK',
    Uz: 'UZ',
    Ka: 'KA',
    Pl: 'PL',
    Lt: 'LT',
    Lv: 'LV',
    Be: 'BE',
    Uk: 'UK'
} as const;

export type UpdateUserDtoLanguagesEnum = typeof UpdateUserDtoLanguagesEnum[keyof typeof UpdateUserDtoLanguagesEnum];

/**
 *
 * @export
 * @interface UpdateUserGroupDto
 */
export interface UpdateUserGroupDto {
    /**
     *
     * @type {string}
     * @memberof UpdateUserGroupDto
     */
    'name': string;
    /**
     *
     * @type {Array<number>}
     * @memberof UpdateUserGroupDto
     */
    'users': Array<number>;
    /**
     *
     * @type {Array<string>}
     * @memberof UpdateUserGroupDto
     */
    'roles': Array<UpdateUserGroupDtoRolesEnum>;
}

export const UpdateUserGroupDtoRolesEnum = {
    TaskOwner: 'taskOwner',
    Manager: 'manager',
    Supervisor: 'supervisor',
    Student: 'student',
    Mentor: 'mentor',
    Dementor: 'dementor'
} as const;

export type UpdateUserGroupDtoRolesEnum = typeof UpdateUserGroupDtoRolesEnum[keyof typeof UpdateUserGroupDtoRolesEnum];

/**
 *
 * @export
 * @interface UpsertNotificationConnectionDto
 */
export interface UpsertNotificationConnectionDto {
    /**
     *
     * @type {string}
     * @memberof UpsertNotificationConnectionDto
     */
    'channelId': string;
    /**
     *
     * @type {string}
     * @memberof UpsertNotificationConnectionDto
     */
    'externalId': string;
    /**
     *
     * @type {number}
     * @memberof UpsertNotificationConnectionDto
     */
    'userId': number;
    /**
     *
     * @type {boolean}
     * @memberof UpsertNotificationConnectionDto
     */
    'enabled': boolean;
}
/**
 *
 * @export
 * @interface UsedCourseDto
 */
export interface UsedCourseDto {
    /**
     *
     * @type {string}
     * @memberof UsedCourseDto
     */
    'name': string;
    /**
     *
     * @type {boolean}
     * @memberof UsedCourseDto
     */
    'isActive': boolean;
}
/**
 *
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     *
     * @type {number}
     * @memberof UserDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof UserDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof UserDto
     */
    'githubId': string;
}
/**
 *
 * @export
 * @interface UserGroupDto
 */
export interface UserGroupDto {
    /**
     *
     * @type {number}
     * @memberof UserGroupDto
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof UserGroupDto
     */
    'name': string;
    /**
     *
     * @type {Array<UserDto>}
     * @memberof UserGroupDto
     */
    'users': Array<UserDto>;
    /**
     *
     * @type {Array<string>}
     * @memberof UserGroupDto
     */
    'roles': Array<UserGroupDtoRolesEnum>;
}

export const UserGroupDtoRolesEnum = {
    TaskOwner: 'taskOwner',
    Manager: 'manager',
    Supervisor: 'supervisor',
    Student: 'student',
    Mentor: 'mentor',
    Dementor: 'dementor'
} as const;

export type UserGroupDtoRolesEnum = typeof UserGroupDtoRolesEnum[keyof typeof UserGroupDtoRolesEnum];

/**
 *
 * @export
 * @interface UserNotificationsDto
 */
export interface UserNotificationsDto {
    /**
     *
     * @type {Array<NotificationUserSettingsDto>}
     * @memberof UserNotificationsDto
     */
    'notifications': Array<NotificationUserSettingsDto>;
    /**
     *
     * @type {object}
     * @memberof UserNotificationsDto
     */
    'connections': object;
}
/**
 *
 * @export
 * @interface Validations
 */
export interface Validations {
    /**
     *
     * @type {boolean}
     * @memberof Validations
     */
    'githubIdInUrl': boolean;
}
/**
 *
 * @export
 * @interface VisibilityDto
 */
export interface VisibilityDto {
    /**
     *
     * @type {boolean}
     * @memberof VisibilityDto
     */
    'isHidden': boolean;
}
/**
 *
 * @export
 * @interface VisibilitySettings
 */
export interface VisibilitySettings {
    /**
     *
     * @type {boolean}
     * @memberof VisibilitySettings
     */
    'all': boolean;
    /**
     *
     * @type {boolean}
     * @memberof VisibilitySettings
     */
    'mentor': boolean;
    /**
     *
     * @type {boolean}
     * @memberof VisibilitySettings
     */
    'student': boolean;
}

/**
 * ActivityApi - axios parameter creator
 * @export
 */
export const ActivityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {CreateActivityDto} createActivityDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActivity: async (createActivityDto: CreateActivityDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createActivityDto' is not null or undefined
            assertParamExists('createActivity', 'createActivityDto', createActivityDto)
            const localVarPath = `/activity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createActivityDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {CreateActivityWebhookDto} createActivityWebhookDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActivityWebhook: async (createActivityWebhookDto: CreateActivityWebhookDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createActivityWebhookDto' is not null or undefined
            assertParamExists('createActivityWebhook', 'createActivityWebhookDto', createActivityWebhookDto)
            const localVarPath = `/activity/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createActivityWebhookDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/activity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityApi - functional programming interface
 * @export
 */
export const ActivityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivityApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {CreateActivityDto} createActivityDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createActivity(createActivityDto: CreateActivityDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createActivity(createActivityDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {CreateActivityWebhookDto} createActivityWebhookDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createActivityWebhook(createActivityWebhookDto: CreateActivityWebhookDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createActivityWebhook(createActivityWebhookDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivity(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivity(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActivityApi - factory interface
 * @export
 */
export const ActivityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivityApiFp(configuration)
    return {
        /**
         *
         * @param {CreateActivityDto} createActivityDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActivity(createActivityDto: CreateActivityDto, options?: any): AxiosPromise<ActivityDto> {
            return localVarFp.createActivity(createActivityDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {CreateActivityWebhookDto} createActivityWebhookDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActivityWebhook(createActivityWebhookDto: CreateActivityWebhookDto, options?: any): AxiosPromise<ActivityDto> {
            return localVarFp.createActivityWebhook(createActivityWebhookDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity(options?: any): AxiosPromise<ActivityDto> {
            return localVarFp.getActivity(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivityApi - object-oriented interface
 * @export
 * @class ActivityApi
 * @extends {BaseAPI}
 */
export class ActivityApi extends BaseAPI {
    /**
     *
     * @param {CreateActivityDto} createActivityDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public createActivity(createActivityDto: CreateActivityDto, options?: AxiosRequestConfig) {
        return ActivityApiFp(this.configuration).createActivity(createActivityDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {CreateActivityWebhookDto} createActivityWebhookDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public createActivityWebhook(createActivityWebhookDto: CreateActivityWebhookDto, options?: AxiosRequestConfig) {
        return ActivityApiFp(this.configuration).createActivityWebhook(createActivityWebhookDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public getActivity(options?: AxiosRequestConfig) {
        return ActivityApiFp(this.configuration).getActivity(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AlertsApi - axios parameter creator
 * @export
 */
export const AlertsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {CreateAlertDto} createAlertDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlert: async (createAlertDto: CreateAlertDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAlertDto' is not null or undefined
            assertParamExists('createAlert', 'createAlertDto', createAlertDto)
            const localVarPath = `/alerts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAlertDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAlert', 'id', id)
            const localVarPath = `/alerts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {boolean} enabled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlerts: async (enabled: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enabled' is not null or undefined
            assertParamExists('getAlerts', 'enabled', enabled)
            const localVarPath = `/alerts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlert: async (id: number, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAlert', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateAlert', 'body', body)
            const localVarPath = `/alerts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertsApi - functional programming interface
 * @export
 */
export const AlertsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlertsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {CreateAlertDto} createAlertDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlert(createAlertDto: CreateAlertDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlert(createAlertDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlert(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlert(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {boolean} enabled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlerts(enabled: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AlertDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlerts(enabled, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAlert(id: number, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAlert(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AlertsApi - factory interface
 * @export
 */
export const AlertsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlertsApiFp(configuration)
    return {
        /**
         *
         * @param {CreateAlertDto} createAlertDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlert(createAlertDto: CreateAlertDto, options?: any): AxiosPromise<AlertDto> {
            return localVarFp.createAlert(createAlertDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAlert(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {boolean} enabled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlerts(enabled: boolean, options?: any): AxiosPromise<Array<AlertDto>> {
            return localVarFp.getAlerts(enabled, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlert(id: number, body: object, options?: any): AxiosPromise<AlertDto> {
            return localVarFp.updateAlert(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
export class AlertsApi extends BaseAPI {
    /**
     *
     * @param {CreateAlertDto} createAlertDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public createAlert(createAlertDto: CreateAlertDto, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).createAlert(createAlertDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public deleteAlert(id: number, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).deleteAlert(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {boolean} enabled
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public getAlerts(enabled: boolean, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).getAlerts(enabled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public updateAlert(id: number, body: object, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).updateAlert(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {AuthConnectionDto} authConnectionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerCreateConnectLinkViaGithub: async (authConnectionDto: AuthConnectionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authConnectionDto' is not null or undefined
            assertParamExists('authControllerCreateConnectLinkViaGithub', 'authConnectionDto', authConnectionDto)
            const localVarPath = `/auth/github/connect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authConnectionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubCallback: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/github/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubLogin: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/github/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubLogout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/github/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {AuthConnectionDto} authConnectionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerCreateConnectLinkViaGithub(authConnectionDto: AuthConnectionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerCreateConnectLinkViaGithub(authConnectionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async githubCallback(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.githubCallback(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async githubLogin(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.githubLogin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async githubLogout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.githubLogout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         *
         * @param {AuthConnectionDto} authConnectionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerCreateConnectLinkViaGithub(authConnectionDto: AuthConnectionDto, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerCreateConnectLinkViaGithub(authConnectionDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubCallback(options?: any): AxiosPromise<void> {
            return localVarFp.githubCallback(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubLogin(options?: any): AxiosPromise<void> {
            return localVarFp.githubLogin(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubLogout(options?: any): AxiosPromise<void> {
            return localVarFp.githubLogout(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     *
     * @param {AuthConnectionDto} authConnectionDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerCreateConnectLinkViaGithub(authConnectionDto: AuthConnectionDto, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerCreateConnectLinkViaGithub(authConnectionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public githubCallback(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).githubCallback(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public githubLogin(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).githubLogin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public githubLogout(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).githubLogout(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CertificateApi - axios parameter creator
 * @export
 */
export const CertificateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} publicId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCertificate: async (publicId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicId' is not null or undefined
            assertParamExists('getCertificate', 'publicId', publicId)
            const localVarPath = `/certificate/{publicId}`
                .replace(`{${"publicId"}}`, encodeURIComponent(String(publicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {SaveCertificateDto} saveCertificateDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCertificate: async (saveCertificateDto: SaveCertificateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saveCertificateDto' is not null or undefined
            assertParamExists('saveCertificate', 'saveCertificateDto', saveCertificateDto)
            const localVarPath = `/certificate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveCertificateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CertificateApi - functional programming interface
 * @export
 */
export const CertificateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CertificateApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} publicId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCertificate(publicId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCertificate(publicId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {SaveCertificateDto} saveCertificateDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveCertificate(saveCertificateDto: SaveCertificateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveCertificate(saveCertificateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CertificateApi - factory interface
 * @export
 */
export const CertificateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CertificateApiFp(configuration)
    return {
        /**
         *
         * @param {string} publicId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCertificate(publicId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getCertificate(publicId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {SaveCertificateDto} saveCertificateDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCertificate(saveCertificateDto: SaveCertificateDto, options?: any): AxiosPromise<void> {
            return localVarFp.saveCertificate(saveCertificateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CertificateApi - object-oriented interface
 * @export
 * @class CertificateApi
 * @extends {BaseAPI}
 */
export class CertificateApi extends BaseAPI {
    /**
     *
     * @param {string} publicId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificateApi
     */
    public getCertificate(publicId: string, options?: AxiosRequestConfig) {
        return CertificateApiFp(this.configuration).getCertificate(publicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {SaveCertificateDto} saveCertificateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificateApi
     */
    public saveCertificate(saveCertificateDto: SaveCertificateDto, options?: AxiosRequestConfig) {
        return CertificateApiFp(this.configuration).saveCertificate(saveCertificateDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CourseMentorsApi - axios parameter creator
 * @export
 */
export const CourseMentorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMentorsDetails: async (courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getMentorsDetails', 'courseId', courseId)
            const localVarPath = `/course/{courseId}/mentors/details`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMentorsDetailsCsv: async (courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getMentorsDetailsCsv', 'courseId', courseId)
            const localVarPath = `/course/{courseId}/mentors/details/csv`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {string} searchText
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMentors: async (courseId: number, searchText: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('searchMentors', 'courseId', courseId)
            // verify required parameter 'searchText' is not null or undefined
            assertParamExists('searchMentors', 'searchText', searchText)
            const localVarPath = `/course/{courseId}/mentors/search/{searchText}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"searchText"}}`, encodeURIComponent(String(searchText)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseMentorsApi - functional programming interface
 * @export
 */
export const CourseMentorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseMentorsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMentorsDetails(courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MentorDetailsDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMentorsDetails(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMentorsDetailsCsv(courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMentorsDetailsCsv(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {string} searchText
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMentors(courseId: number, searchText: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchMentorDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMentors(courseId, searchText, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CourseMentorsApi - factory interface
 * @export
 */
export const CourseMentorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseMentorsApiFp(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMentorsDetails(courseId: number, options?: any): AxiosPromise<Array<MentorDetailsDto>> {
            return localVarFp.getMentorsDetails(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMentorsDetailsCsv(courseId: number, options?: any): AxiosPromise<void> {
            return localVarFp.getMentorsDetailsCsv(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {string} searchText
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMentors(courseId: number, searchText: string, options?: any): AxiosPromise<Array<SearchMentorDto>> {
            return localVarFp.searchMentors(courseId, searchText, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CourseMentorsApi - object-oriented interface
 * @export
 * @class CourseMentorsApi
 * @extends {BaseAPI}
 */
export class CourseMentorsApi extends BaseAPI {
    /**
     *
     * @param {number} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseMentorsApi
     */
    public getMentorsDetails(courseId: number, options?: AxiosRequestConfig) {
        return CourseMentorsApiFp(this.configuration).getMentorsDetails(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseMentorsApi
     */
    public getMentorsDetailsCsv(courseId: number, options?: AxiosRequestConfig) {
        return CourseMentorsApiFp(this.configuration).getMentorsDetailsCsv(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {string} searchText
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseMentorsApi
     */
    public searchMentors(courseId: number, searchText: string, options?: AxiosRequestConfig) {
        return CourseMentorsApiFp(this.configuration).searchMentors(courseId, searchText, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CourseStatsApi - axios parameter creator
 * @export
 */
export const CourseStatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseStats: async (courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getCourseStats', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/stats`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseStatsApi - functional programming interface
 * @export
 */
export const CourseStatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseStatsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseStats(courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseStatsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseStats(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CourseStatsApi - factory interface
 * @export
 */
export const CourseStatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseStatsApiFp(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseStats(courseId: number, options?: any): AxiosPromise<CourseStatsDto> {
            return localVarFp.getCourseStats(courseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CourseStatsApi - object-oriented interface
 * @export
 * @class CourseStatsApi
 * @extends {BaseAPI}
 */
export class CourseStatsApi extends BaseAPI {
    /**
     *
     * @param {number} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseStatsApi
     */
    public getCourseStats(courseId: number, options?: AxiosRequestConfig) {
        return CourseStatsApiFp(this.configuration).getCourseStats(courseId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CourseTaskVerificationsApi - axios parameter creator
 * @export
 */
export const CourseTaskVerificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} courseId
         * @param {number} courseTaskId
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskVerification: async (courseId: number, courseTaskId: number, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('createTaskVerification', 'courseId', courseId)
            // verify required parameter 'courseTaskId' is not null or undefined
            assertParamExists('createTaskVerification', 'courseTaskId', courseTaskId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createTaskVerification', 'body', body)
            const localVarPath = `/courses/{courseId}/tasks/{courseTaskId}/verifications`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"courseTaskId"}}`, encodeURIComponent(String(courseTaskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {number} courseTaskId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnswers: async (courseId: number, courseTaskId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getAnswers', 'courseId', courseId)
            // verify required parameter 'courseTaskId' is not null or undefined
            assertParamExists('getAnswers', 'courseTaskId', courseTaskId)
            const localVarPath = `/courses/{courseId}/tasks/{courseTaskId}/verifications/answers`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"courseTaskId"}}`, encodeURIComponent(String(courseTaskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseTaskVerificationsApi - functional programming interface
 * @export
 */
export const CourseTaskVerificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseTaskVerificationsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {number} courseTaskId
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTaskVerification(courseId: number, courseTaskId: number, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTaskVerificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTaskVerification(courseId, courseTaskId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {number} courseTaskId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnswers(courseId: number, courseTaskId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskVerificationAttemptDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnswers(courseId, courseTaskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CourseTaskVerificationsApi - factory interface
 * @export
 */
export const CourseTaskVerificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseTaskVerificationsApiFp(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {number} courseTaskId
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskVerification(courseId: number, courseTaskId: number, body: object, options?: any): AxiosPromise<CreateTaskVerificationDto> {
            return localVarFp.createTaskVerification(courseId, courseTaskId, body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {number} courseTaskId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnswers(courseId: number, courseTaskId: number, options?: any): AxiosPromise<Array<TaskVerificationAttemptDto>> {
            return localVarFp.getAnswers(courseId, courseTaskId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CourseTaskVerificationsApi - object-oriented interface
 * @export
 * @class CourseTaskVerificationsApi
 * @extends {BaseAPI}
 */
export class CourseTaskVerificationsApi extends BaseAPI {
    /**
     *
     * @param {number} courseId
     * @param {number} courseTaskId
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseTaskVerificationsApi
     */
    public createTaskVerification(courseId: number, courseTaskId: number, body: object, options?: AxiosRequestConfig) {
        return CourseTaskVerificationsApiFp(this.configuration).createTaskVerification(courseId, courseTaskId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {number} courseTaskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseTaskVerificationsApi
     */
    public getAnswers(courseId: number, courseTaskId: number, options?: AxiosRequestConfig) {
        return CourseTaskVerificationsApiFp(this.configuration).getAnswers(courseId, courseTaskId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CourseUsersApi - axios parameter creator
 * @export
 */
export const CourseUsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseUsers: async (courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getCourseUsers', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/users`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {string} githubId
         * @param {CourseRolesDto} courseRolesDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCourseUser: async (courseId: number, githubId: string, courseRolesDto: CourseRolesDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('putCourseUser', 'courseId', courseId)
            // verify required parameter 'githubId' is not null or undefined
            assertParamExists('putCourseUser', 'githubId', githubId)
            // verify required parameter 'courseRolesDto' is not null or undefined
            assertParamExists('putCourseUser', 'courseRolesDto', courseRolesDto)
            const localVarPath = `/courses/{courseId}/users/{githubId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"githubId"}}`, encodeURIComponent(String(githubId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(courseRolesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {Array<UpdateCourseUserDto>} updateCourseUserDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCourseUsers: async (courseId: number, updateCourseUserDto: Array<UpdateCourseUserDto>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('putCourseUsers', 'courseId', courseId)
            // verify required parameter 'updateCourseUserDto' is not null or undefined
            assertParamExists('putCourseUsers', 'updateCourseUserDto', updateCourseUserDto)
            const localVarPath = `/courses/{courseId}/users`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCourseUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseUsersApi - functional programming interface
 * @export
 */
export const CourseUsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseUsersApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseUsers(courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CourseUserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseUsers(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {string} githubId
         * @param {CourseRolesDto} courseRolesDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCourseUser(courseId: number, githubId: string, courseRolesDto: CourseRolesDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putCourseUser(courseId, githubId, courseRolesDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {Array<UpdateCourseUserDto>} updateCourseUserDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCourseUsers(courseId: number, updateCourseUserDto: Array<UpdateCourseUserDto>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putCourseUsers(courseId, updateCourseUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CourseUsersApi - factory interface
 * @export
 */
export const CourseUsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseUsersApiFp(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseUsers(courseId: number, options?: any): AxiosPromise<Array<CourseUserDto>> {
            return localVarFp.getCourseUsers(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {string} githubId
         * @param {CourseRolesDto} courseRolesDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCourseUser(courseId: number, githubId: string, courseRolesDto: CourseRolesDto, options?: any): AxiosPromise<void> {
            return localVarFp.putCourseUser(courseId, githubId, courseRolesDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {Array<UpdateCourseUserDto>} updateCourseUserDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCourseUsers(courseId: number, updateCourseUserDto: Array<UpdateCourseUserDto>, options?: any): AxiosPromise<void> {
            return localVarFp.putCourseUsers(courseId, updateCourseUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CourseUsersApi - object-oriented interface
 * @export
 * @class CourseUsersApi
 * @extends {BaseAPI}
 */
export class CourseUsersApi extends BaseAPI {
    /**
     *
     * @param {number} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseUsersApi
     */
    public getCourseUsers(courseId: number, options?: AxiosRequestConfig) {
        return CourseUsersApiFp(this.configuration).getCourseUsers(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {string} githubId
     * @param {CourseRolesDto} courseRolesDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseUsersApi
     */
    public putCourseUser(courseId: number, githubId: string, courseRolesDto: CourseRolesDto, options?: AxiosRequestConfig) {
        return CourseUsersApiFp(this.configuration).putCourseUser(courseId, githubId, courseRolesDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {Array<UpdateCourseUserDto>} updateCourseUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseUsersApi
     */
    public putCourseUsers(courseId: number, updateCourseUserDto: Array<UpdateCourseUserDto>, options?: AxiosRequestConfig) {
        return CourseUsersApiFp(this.configuration).putCourseUsers(courseId, updateCourseUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CoursesApi - axios parameter creator
 * @export
 */
export const CoursesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourse: async (courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getCourse', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/courses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {LeaveCourseRequestDto} [leaveCourseRequestDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveCourse: async (courseId: number, leaveCourseRequestDto?: LeaveCourseRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('leaveCourse', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/leave`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(leaveCourseRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejoinCourse: async (courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('rejoinCourse', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/rejoin`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {UpdateCourseDto} updateCourseDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourse: async (courseId: number, updateCourseDto: UpdateCourseDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('updateCourse', 'courseId', courseId)
            // verify required parameter 'updateCourseDto' is not null or undefined
            assertParamExists('updateCourse', 'updateCourseDto', updateCourseDto)
            const localVarPath = `/courses/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCourseDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoursesApi - functional programming interface
 * @export
 */
export const CoursesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoursesApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourse(courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourse(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourses(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CourseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourses(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {LeaveCourseRequestDto} [leaveCourseRequestDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveCourse(courseId: number, leaveCourseRequestDto?: LeaveCourseRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveCourse(courseId, leaveCourseRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejoinCourse(courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejoinCourse(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {UpdateCourseDto} updateCourseDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCourse(courseId: number, updateCourseDto: UpdateCourseDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCourse(courseId, updateCourseDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CoursesApi - factory interface
 * @export
 */
export const CoursesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoursesApiFp(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourse(courseId: number, options?: any): AxiosPromise<CourseDto> {
            return localVarFp.getCourse(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses(options?: any): AxiosPromise<Array<CourseDto>> {
            return localVarFp.getCourses(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {LeaveCourseRequestDto} [leaveCourseRequestDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveCourse(courseId: number, leaveCourseRequestDto?: LeaveCourseRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.leaveCourse(courseId, leaveCourseRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejoinCourse(courseId: number, options?: any): AxiosPromise<void> {
            return localVarFp.rejoinCourse(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {UpdateCourseDto} updateCourseDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourse(courseId: number, updateCourseDto: UpdateCourseDto, options?: any): AxiosPromise<CourseDto> {
            return localVarFp.updateCourse(courseId, updateCourseDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoursesApi - object-oriented interface
 * @export
 * @class CoursesApi
 * @extends {BaseAPI}
 */
export class CoursesApi extends BaseAPI {
    /**
     *
     * @param {number} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public getCourse(courseId: number, options?: AxiosRequestConfig) {
        return CoursesApiFp(this.configuration).getCourse(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public getCourses(options?: AxiosRequestConfig) {
        return CoursesApiFp(this.configuration).getCourses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {LeaveCourseRequestDto} [leaveCourseRequestDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public leaveCourse(courseId: number, leaveCourseRequestDto?: LeaveCourseRequestDto, options?: AxiosRequestConfig) {
        return CoursesApiFp(this.configuration).leaveCourse(courseId, leaveCourseRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public rejoinCourse(courseId: number, options?: AxiosRequestConfig) {
        return CoursesApiFp(this.configuration).rejoinCourse(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {UpdateCourseDto} updateCourseDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public updateCourse(courseId: number, updateCourseDto: UpdateCourseDto, options?: AxiosRequestConfig) {
        return CoursesApiFp(this.configuration).updateCourse(courseId, updateCourseDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CoursesEventsApi - axios parameter creator
 * @export
 */
export const CoursesEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} courseId
         * @param {CreateCourseEventDto} createCourseEventDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseEvent: async (courseId: number, createCourseEventDto: CreateCourseEventDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('createCourseEvent', 'courseId', courseId)
            // verify required parameter 'createCourseEventDto' is not null or undefined
            assertParamExists('createCourseEvent', 'createCourseEventDto', createCourseEventDto)
            const localVarPath = `/courses/{courseId}/events`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCourseEventDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseEventId
         * @param {any} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseEvent: async (courseEventId: number, courseId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseEventId' is not null or undefined
            assertParamExists('deleteCourseEvent', 'courseEventId', courseEventId)
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('deleteCourseEvent', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/events/{courseEventId}`
                .replace(`{${"courseEventId"}}`, encodeURIComponent(String(courseEventId)))
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {number} courseEventId
         * @param {UpdateCourseEventDto} updateCourseEventDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseEvent: async (courseId: number, courseEventId: number, updateCourseEventDto: UpdateCourseEventDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('updateCourseEvent', 'courseId', courseId)
            // verify required parameter 'courseEventId' is not null or undefined
            assertParamExists('updateCourseEvent', 'courseEventId', courseEventId)
            // verify required parameter 'updateCourseEventDto' is not null or undefined
            assertParamExists('updateCourseEvent', 'updateCourseEventDto', updateCourseEventDto)
            const localVarPath = `/courses/{courseId}/events/{courseEventId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"courseEventId"}}`, encodeURIComponent(String(courseEventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCourseEventDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoursesEventsApi - functional programming interface
 * @export
 */
export const CoursesEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoursesEventsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {CreateCourseEventDto} createCourseEventDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCourseEvent(courseId: number, createCourseEventDto: CreateCourseEventDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CourseEventDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCourseEvent(courseId, createCourseEventDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseEventId
         * @param {any} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCourseEvent(courseEventId: number, courseId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCourseEvent(courseEventId, courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {number} courseEventId
         * @param {UpdateCourseEventDto} updateCourseEventDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCourseEvent(courseId: number, courseEventId: number, updateCourseEventDto: UpdateCourseEventDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCourseEvent(courseId, courseEventId, updateCourseEventDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CoursesEventsApi - factory interface
 * @export
 */
export const CoursesEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoursesEventsApiFp(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {CreateCourseEventDto} createCourseEventDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseEvent(courseId: number, createCourseEventDto: CreateCourseEventDto, options?: any): AxiosPromise<Array<CourseEventDto>> {
            return localVarFp.createCourseEvent(courseId, createCourseEventDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseEventId
         * @param {any} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseEvent(courseEventId: number, courseId: any, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCourseEvent(courseEventId, courseId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {number} courseEventId
         * @param {UpdateCourseEventDto} updateCourseEventDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseEvent(courseId: number, courseEventId: number, updateCourseEventDto: UpdateCourseEventDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateCourseEvent(courseId, courseEventId, updateCourseEventDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoursesEventsApi - object-oriented interface
 * @export
 * @class CoursesEventsApi
 * @extends {BaseAPI}
 */
export class CoursesEventsApi extends BaseAPI {
    /**
     *
     * @param {number} courseId
     * @param {CreateCourseEventDto} createCourseEventDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesEventsApi
     */
    public createCourseEvent(courseId: number, createCourseEventDto: CreateCourseEventDto, options?: AxiosRequestConfig) {
        return CoursesEventsApiFp(this.configuration).createCourseEvent(courseId, createCourseEventDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseEventId
     * @param {any} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesEventsApi
     */
    public deleteCourseEvent(courseEventId: number, courseId: any, options?: AxiosRequestConfig) {
        return CoursesEventsApiFp(this.configuration).deleteCourseEvent(courseEventId, courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {number} courseEventId
     * @param {UpdateCourseEventDto} updateCourseEventDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesEventsApi
     */
    public updateCourseEvent(courseId: number, courseEventId: number, updateCourseEventDto: UpdateCourseEventDto, options?: AxiosRequestConfig) {
        return CoursesEventsApiFp(this.configuration).updateCourseEvent(courseId, courseEventId, updateCourseEventDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CoursesInterviewsApi - axios parameter creator
 * @export
 */
export const CoursesInterviewsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} courseId
         * @param {number} interviewId
         * @param {string} type
         * @param {PutInterviewFeedbackDto} putInterviewFeedbackDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInterviewFeedback: async (courseId: number, interviewId: number, type: string, putInterviewFeedbackDto: PutInterviewFeedbackDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('createInterviewFeedback', 'courseId', courseId)
            // verify required parameter 'interviewId' is not null or undefined
            assertParamExists('createInterviewFeedback', 'interviewId', interviewId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createInterviewFeedback', 'type', type)
            // verify required parameter 'putInterviewFeedbackDto' is not null or undefined
            assertParamExists('createInterviewFeedback', 'putInterviewFeedbackDto', putInterviewFeedbackDto)
            const localVarPath = `/courses/{courseId}/interviews/{interviewId}/{type}/feedback`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"interviewId"}}`, encodeURIComponent(String(interviewId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(putInterviewFeedbackDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {number} interviewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableStudents: async (courseId: number, interviewId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getAvailableStudents', 'courseId', courseId)
            // verify required parameter 'interviewId' is not null or undefined
            assertParamExists('getAvailableStudents', 'interviewId', interviewId)
            const localVarPath = `/courses/{courseId}/interviews/{interviewId}/students/available`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"interviewId"}}`, encodeURIComponent(String(interviewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} interviewId
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterview: async (interviewId: number, courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'interviewId' is not null or undefined
            assertParamExists('getInterview', 'interviewId', interviewId)
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getInterview', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/interviews/{interviewId}`
                .replace(`{${"interviewId"}}`, encodeURIComponent(String(interviewId)))
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {number} interviewId
         * @param {string} type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterviewFeedback: async (courseId: number, interviewId: number, type: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getInterviewFeedback', 'courseId', courseId)
            // verify required parameter 'interviewId' is not null or undefined
            assertParamExists('getInterviewFeedback', 'interviewId', interviewId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getInterviewFeedback', 'type', type)
            const localVarPath = `/courses/{courseId}/interviews/{interviewId}/{type}/feedback`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"interviewId"}}`, encodeURIComponent(String(interviewId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {boolean} [disabled]
         * @param {Array<string>} [types]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterviews: async (courseId: number, disabled?: boolean, types?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getInterviews', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/interviews`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (disabled !== undefined) {
                localVarQueryParameter['disabled'] = disabled;
            }

            if (types) {
                localVarQueryParameter['types'] = types;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoursesInterviewsApi - functional programming interface
 * @export
 */
export const CoursesInterviewsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoursesInterviewsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {number} interviewId
         * @param {string} type
         * @param {PutInterviewFeedbackDto} putInterviewFeedbackDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInterviewFeedback(courseId: number, interviewId: number, type: string, putInterviewFeedbackDto: PutInterviewFeedbackDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInterviewFeedback(courseId, interviewId, type, putInterviewFeedbackDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {number} interviewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableStudents(courseId: number, interviewId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AvailableStudentDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableStudents(courseId, interviewId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} interviewId
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInterview(interviewId: number, courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterviewDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInterview(interviewId, courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {number} interviewId
         * @param {string} type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInterviewFeedback(courseId: number, interviewId: number, type: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterviewFeedbackDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInterviewFeedback(courseId, interviewId, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {boolean} [disabled]
         * @param {Array<string>} [types]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInterviews(courseId: number, disabled?: boolean, types?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InterviewDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInterviews(courseId, disabled, types, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CoursesInterviewsApi - factory interface
 * @export
 */
export const CoursesInterviewsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoursesInterviewsApiFp(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {number} interviewId
         * @param {string} type
         * @param {PutInterviewFeedbackDto} putInterviewFeedbackDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInterviewFeedback(courseId: number, interviewId: number, type: string, putInterviewFeedbackDto: PutInterviewFeedbackDto, options?: any): AxiosPromise<void> {
            return localVarFp.createInterviewFeedback(courseId, interviewId, type, putInterviewFeedbackDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {number} interviewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableStudents(courseId: number, interviewId: number, options?: any): AxiosPromise<Array<AvailableStudentDto>> {
            return localVarFp.getAvailableStudents(courseId, interviewId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} interviewId
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterview(interviewId: number, courseId: number, options?: any): AxiosPromise<InterviewDto> {
            return localVarFp.getInterview(interviewId, courseId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {number} interviewId
         * @param {string} type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterviewFeedback(courseId: number, interviewId: number, type: string, options?: any): AxiosPromise<InterviewFeedbackDto> {
            return localVarFp.getInterviewFeedback(courseId, interviewId, type, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {boolean} [disabled]
         * @param {Array<string>} [types]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterviews(courseId: number, disabled?: boolean, types?: Array<string>, options?: any): AxiosPromise<Array<InterviewDto>> {
            return localVarFp.getInterviews(courseId, disabled, types, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoursesInterviewsApi - object-oriented interface
 * @export
 * @class CoursesInterviewsApi
 * @extends {BaseAPI}
 */
export class CoursesInterviewsApi extends BaseAPI {
    /**
     *
     * @param {number} courseId
     * @param {number} interviewId
     * @param {string} type
     * @param {PutInterviewFeedbackDto} putInterviewFeedbackDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesInterviewsApi
     */
    public createInterviewFeedback(courseId: number, interviewId: number, type: string, putInterviewFeedbackDto: PutInterviewFeedbackDto, options?: AxiosRequestConfig) {
        return CoursesInterviewsApiFp(this.configuration).createInterviewFeedback(courseId, interviewId, type, putInterviewFeedbackDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {number} interviewId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesInterviewsApi
     */
    public getAvailableStudents(courseId: number, interviewId: number, options?: AxiosRequestConfig) {
        return CoursesInterviewsApiFp(this.configuration).getAvailableStudents(courseId, interviewId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} interviewId
     * @param {number} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesInterviewsApi
     */
    public getInterview(interviewId: number, courseId: number, options?: AxiosRequestConfig) {
        return CoursesInterviewsApiFp(this.configuration).getInterview(interviewId, courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {number} interviewId
     * @param {string} type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesInterviewsApi
     */
    public getInterviewFeedback(courseId: number, interviewId: number, type: string, options?: AxiosRequestConfig) {
        return CoursesInterviewsApiFp(this.configuration).getInterviewFeedback(courseId, interviewId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {boolean} [disabled]
     * @param {Array<string>} [types]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesInterviewsApi
     */
    public getInterviews(courseId: number, disabled?: boolean, types?: Array<string>, options?: AxiosRequestConfig) {
        return CoursesInterviewsApiFp(this.configuration).getInterviews(courseId, disabled, types, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CoursesScheduleApi - axios parameter creator
 * @export
 */
export const CoursesScheduleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} courseId
         * @param {CourseCopyFromDto} courseCopyFromDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copySchedule: async (courseId: number, courseCopyFromDto: CourseCopyFromDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('copySchedule', 'courseId', courseId)
            // verify required parameter 'courseCopyFromDto' is not null or undefined
            assertParamExists('copySchedule', 'courseCopyFromDto', courseCopyFromDto)
            const localVarPath = `/courses/{courseId}/schedule/copy`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(courseCopyFromDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedule: async (courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getSchedule', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/schedule`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoursesScheduleApi - functional programming interface
 * @export
 */
export const CoursesScheduleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoursesScheduleApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {CourseCopyFromDto} courseCopyFromDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copySchedule(courseId: number, courseCopyFromDto: CourseCopyFromDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.copySchedule(courseId, courseCopyFromDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchedule(courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CourseScheduleItemDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchedule(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CoursesScheduleApi - factory interface
 * @export
 */
export const CoursesScheduleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoursesScheduleApiFp(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {CourseCopyFromDto} courseCopyFromDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copySchedule(courseId: number, courseCopyFromDto: CourseCopyFromDto, options?: any): AxiosPromise<void> {
            return localVarFp.copySchedule(courseId, courseCopyFromDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedule(courseId: number, options?: any): AxiosPromise<Array<CourseScheduleItemDto>> {
            return localVarFp.getSchedule(courseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoursesScheduleApi - object-oriented interface
 * @export
 * @class CoursesScheduleApi
 * @extends {BaseAPI}
 */
export class CoursesScheduleApi extends BaseAPI {
    /**
     *
     * @param {number} courseId
     * @param {CourseCopyFromDto} courseCopyFromDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesScheduleApi
     */
    public copySchedule(courseId: number, courseCopyFromDto: CourseCopyFromDto, options?: AxiosRequestConfig) {
        return CoursesScheduleApiFp(this.configuration).copySchedule(courseId, courseCopyFromDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesScheduleApi
     */
    public getSchedule(courseId: number, options?: AxiosRequestConfig) {
        return CoursesScheduleApiFp(this.configuration).getSchedule(courseId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CoursesScheduleIcalApi - axios parameter creator
 * @export
 */
export const CoursesScheduleIcalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} courseId
         * @param {string} token
         * @param {string} timezone
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleICalendar: async (courseId: number, token: string, timezone: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getScheduleICalendar', 'courseId', courseId)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getScheduleICalendar', 'token', token)
            // verify required parameter 'timezone' is not null or undefined
            assertParamExists('getScheduleICalendar', 'timezone', timezone)
            const localVarPath = `/courses/{courseId}/icalendar/{token}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleICalendarToken: async (courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getScheduleICalendarToken', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/icalendar/token`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoursesScheduleIcalApi - functional programming interface
 * @export
 */
export const CoursesScheduleIcalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoursesScheduleIcalApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {string} token
         * @param {string} timezone
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScheduleICalendar(courseId: number, token: string, timezone: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScheduleICalendar(courseId, token, timezone, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScheduleICalendarToken(courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseScheduleTokenDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScheduleICalendarToken(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CoursesScheduleIcalApi - factory interface
 * @export
 */
export const CoursesScheduleIcalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoursesScheduleIcalApiFp(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {string} token
         * @param {string} timezone
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleICalendar(courseId: number, token: string, timezone: string, options?: any): AxiosPromise<string> {
            return localVarFp.getScheduleICalendar(courseId, token, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleICalendarToken(courseId: number, options?: any): AxiosPromise<CourseScheduleTokenDto> {
            return localVarFp.getScheduleICalendarToken(courseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoursesScheduleIcalApi - object-oriented interface
 * @export
 * @class CoursesScheduleIcalApi
 * @extends {BaseAPI}
 */
export class CoursesScheduleIcalApi extends BaseAPI {
    /**
     *
     * @param {number} courseId
     * @param {string} token
     * @param {string} timezone
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesScheduleIcalApi
     */
    public getScheduleICalendar(courseId: number, token: string, timezone: string, options?: AxiosRequestConfig) {
        return CoursesScheduleIcalApiFp(this.configuration).getScheduleICalendar(courseId, token, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesScheduleIcalApi
     */
    public getScheduleICalendarToken(courseId: number, options?: AxiosRequestConfig) {
        return CoursesScheduleIcalApiFp(this.configuration).getScheduleICalendarToken(courseId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CoursesTaskSolutionsApi - axios parameter creator
 * @export
 */
export const CoursesTaskSolutionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} courseId
         * @param {number} courseTaskId
         * @param {SaveTaskSolutionDto} saveTaskSolutionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskSolution: async (courseId: number, courseTaskId: number, saveTaskSolutionDto: SaveTaskSolutionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('createTaskSolution', 'courseId', courseId)
            // verify required parameter 'courseTaskId' is not null or undefined
            assertParamExists('createTaskSolution', 'courseTaskId', courseTaskId)
            // verify required parameter 'saveTaskSolutionDto' is not null or undefined
            assertParamExists('createTaskSolution', 'saveTaskSolutionDto', saveTaskSolutionDto)
            const localVarPath = `/courses/{courseId}/tasks/{courseTaskId}/solutions`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"courseTaskId"}}`, encodeURIComponent(String(courseTaskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveTaskSolutionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoursesTaskSolutionsApi - functional programming interface
 * @export
 */
export const CoursesTaskSolutionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoursesTaskSolutionsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {number} courseTaskId
         * @param {SaveTaskSolutionDto} saveTaskSolutionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTaskSolution(courseId: number, courseTaskId: number, saveTaskSolutionDto: SaveTaskSolutionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSolutionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTaskSolution(courseId, courseTaskId, saveTaskSolutionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CoursesTaskSolutionsApi - factory interface
 * @export
 */
export const CoursesTaskSolutionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoursesTaskSolutionsApiFp(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {number} courseTaskId
         * @param {SaveTaskSolutionDto} saveTaskSolutionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskSolution(courseId: number, courseTaskId: number, saveTaskSolutionDto: SaveTaskSolutionDto, options?: any): AxiosPromise<TaskSolutionDto> {
            return localVarFp.createTaskSolution(courseId, courseTaskId, saveTaskSolutionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoursesTaskSolutionsApi - object-oriented interface
 * @export
 * @class CoursesTaskSolutionsApi
 * @extends {BaseAPI}
 */
export class CoursesTaskSolutionsApi extends BaseAPI {
    /**
     *
     * @param {number} courseId
     * @param {number} courseTaskId
     * @param {SaveTaskSolutionDto} saveTaskSolutionDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesTaskSolutionsApi
     */
    public createTaskSolution(courseId: number, courseTaskId: number, saveTaskSolutionDto: SaveTaskSolutionDto, options?: AxiosRequestConfig) {
        return CoursesTaskSolutionsApiFp(this.configuration).createTaskSolution(courseId, courseTaskId, saveTaskSolutionDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CoursesTasksApi - axios parameter creator
 * @export
 */
export const CoursesTasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} courseId
         * @param {CreateCourseTaskDto} createCourseTaskDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseTask: async (courseId: number, createCourseTaskDto: CreateCourseTaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('createCourseTask', 'courseId', courseId)
            // verify required parameter 'createCourseTaskDto' is not null or undefined
            assertParamExists('createCourseTask', 'createCourseTaskDto', createCourseTaskDto)
            const localVarPath = `/courses/{courseId}/tasks`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCourseTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {number} courseTaskId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseTask: async (courseId: number, courseTaskId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('deleteCourseTask', 'courseId', courseId)
            // verify required parameter 'courseTaskId' is not null or undefined
            assertParamExists('deleteCourseTask', 'courseTaskId', courseTaskId)
            const localVarPath = `/courses/{courseId}/tasks/{courseTaskId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"courseTaskId"}}`, encodeURIComponent(String(courseTaskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableCrossCheckReviewStats: async (courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getAvailableCrossCheckReviewStats', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/cross-checks/available-review-stats`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {number} courseTaskId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseTask: async (courseId: number, courseTaskId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getCourseTask', 'courseId', courseId)
            // verify required parameter 'courseTaskId' is not null or undefined
            assertParamExists('getCourseTask', 'courseTaskId', courseTaskId)
            const localVarPath = `/courses/{courseId}/tasks/{courseTaskId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"courseTaskId"}}`, encodeURIComponent(String(courseTaskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {'started' | 'inprogress' | 'finished'} [status]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseTasks: async (courseId: number, status?: 'started' | 'inprogress' | 'finished', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getCourseTasks', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/tasks`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseTasksDetailed: async (courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getCourseTasksDetailed', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/tasks/detailed`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {'started' | 'inprogress' | 'finished'} [status]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseTasksWithStudentSolution: async (courseId: number, status?: 'started' | 'inprogress' | 'finished', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getCourseTasksWithStudentSolution', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/tasks/solutions`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {number} courseTaskId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrossCheckCsv: async (courseId: number, courseTaskId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getCrossCheckCsv', 'courseId', courseId)
            // verify required parameter 'courseTaskId' is not null or undefined
            assertParamExists('getCrossCheckCsv', 'courseTaskId', courseTaskId)
            const localVarPath = `/courses/{courseId}/cross-checks/{courseTaskId}/csv`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"courseTaskId"}}`, encodeURIComponent(String(courseTaskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {number} pageSize
         * @param {number} current
         * @param {string} [orderBy]
         * @param {string} [orderDirection]
         * @param {string} [checker]
         * @param {string} [student]
         * @param {string} [url]
         * @param {string} [task]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrossCheckPairs: async (courseId: number, pageSize: number, current: number, orderBy?: string, orderDirection?: string, checker?: string, student?: string, url?: string, task?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getCrossCheckPairs', 'courseId', courseId)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getCrossCheckPairs', 'pageSize', pageSize)
            // verify required parameter 'current' is not null or undefined
            assertParamExists('getCrossCheckPairs', 'current', current)
            const localVarPath = `/courses/{courseId}/cross-checks/pairs`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (checker !== undefined) {
                localVarQueryParameter['checker'] = checker;
            }

            if (student !== undefined) {
                localVarQueryParameter['student'] = student;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }

            if (task !== undefined) {
                localVarQueryParameter['task'] = task;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {number} courseTaskId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyCrossCheckFeedbacks: async (courseId: number, courseTaskId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getMyCrossCheckFeedbacks', 'courseId', courseId)
            // verify required parameter 'courseTaskId' is not null or undefined
            assertParamExists('getMyCrossCheckFeedbacks', 'courseTaskId', courseTaskId)
            const localVarPath = `/courses/{courseId}/cross-checks/{courseTaskId}/feedbacks/my`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"courseTaskId"}}`, encodeURIComponent(String(courseTaskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {CheckTasksDeadlineDto} checkTasksDeadlineDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyTasksDeadlines: async (checkTasksDeadlineDto: CheckTasksDeadlineDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkTasksDeadlineDto' is not null or undefined
            assertParamExists('notifyTasksDeadlines', 'checkTasksDeadlineDto', checkTasksDeadlineDto)
            const localVarPath = `/tasks/notify/changes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkTasksDeadlineDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {number} courseTaskId
         * @param {UpdateCourseTaskDto} updateCourseTaskDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseTask: async (courseId: number, courseTaskId: number, updateCourseTaskDto: UpdateCourseTaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('updateCourseTask', 'courseId', courseId)
            // verify required parameter 'courseTaskId' is not null or undefined
            assertParamExists('updateCourseTask', 'courseTaskId', courseTaskId)
            // verify required parameter 'updateCourseTaskDto' is not null or undefined
            assertParamExists('updateCourseTask', 'updateCourseTaskDto', updateCourseTaskDto)
            const localVarPath = `/courses/{courseId}/tasks/{courseTaskId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"courseTaskId"}}`, encodeURIComponent(String(courseTaskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCourseTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoursesTasksApi - functional programming interface
 * @export
 */
export const CoursesTasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoursesTasksApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {CreateCourseTaskDto} createCourseTaskDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCourseTask(courseId: number, createCourseTaskDto: CreateCourseTaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseTaskDetailedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCourseTask(courseId, createCourseTaskDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {number} courseTaskId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCourseTask(courseId: number, courseTaskId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCourseTask(courseId, courseTaskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableCrossCheckReviewStats(courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AvailableReviewStatsDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableCrossCheckReviewStats(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {number} courseTaskId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseTask(courseId: number, courseTaskId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseTaskDetailedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseTask(courseId, courseTaskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {'started' | 'inprogress' | 'finished'} [status]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseTasks(courseId: number, status?: 'started' | 'inprogress' | 'finished', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CourseTaskDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseTasks(courseId, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseTasksDetailed(courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CourseTaskDetailedDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseTasksDetailed(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {'started' | 'inprogress' | 'finished'} [status]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseTasksWithStudentSolution(courseId: number, status?: 'started' | 'inprogress' | 'finished', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CourseTaskDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseTasksWithStudentSolution(courseId, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {number} courseTaskId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCrossCheckCsv(courseId: number, courseTaskId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCrossCheckCsv(courseId, courseTaskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {number} pageSize
         * @param {number} current
         * @param {string} [orderBy]
         * @param {string} [orderDirection]
         * @param {string} [checker]
         * @param {string} [student]
         * @param {string} [url]
         * @param {string} [task]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCrossCheckPairs(courseId: number, pageSize: number, current: number, orderBy?: string, orderDirection?: string, checker?: string, student?: string, url?: string, task?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrossCheckPairResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCrossCheckPairs(courseId, pageSize, current, orderBy, orderDirection, checker, student, url, task, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {number} courseTaskId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyCrossCheckFeedbacks(courseId: number, courseTaskId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrossCheckFeedbackDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyCrossCheckFeedbacks(courseId, courseTaskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {CheckTasksDeadlineDto} checkTasksDeadlineDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyTasksDeadlines(checkTasksDeadlineDto: CheckTasksDeadlineDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyTasksDeadlines(checkTasksDeadlineDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {number} courseTaskId
         * @param {UpdateCourseTaskDto} updateCourseTaskDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCourseTask(courseId: number, courseTaskId: number, updateCourseTaskDto: UpdateCourseTaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseTaskDetailedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCourseTask(courseId, courseTaskId, updateCourseTaskDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CoursesTasksApi - factory interface
 * @export
 */
export const CoursesTasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoursesTasksApiFp(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {CreateCourseTaskDto} createCourseTaskDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseTask(courseId: number, createCourseTaskDto: CreateCourseTaskDto, options?: any): AxiosPromise<CourseTaskDetailedDto> {
            return localVarFp.createCourseTask(courseId, createCourseTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {number} courseTaskId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseTask(courseId: number, courseTaskId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCourseTask(courseId, courseTaskId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableCrossCheckReviewStats(courseId: number, options?: any): AxiosPromise<Array<AvailableReviewStatsDto>> {
            return localVarFp.getAvailableCrossCheckReviewStats(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {number} courseTaskId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseTask(courseId: number, courseTaskId: number, options?: any): AxiosPromise<CourseTaskDetailedDto> {
            return localVarFp.getCourseTask(courseId, courseTaskId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {'started' | 'inprogress' | 'finished'} [status]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseTasks(courseId: number, status?: 'started' | 'inprogress' | 'finished', options?: any): AxiosPromise<Array<CourseTaskDto>> {
            return localVarFp.getCourseTasks(courseId, status, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseTasksDetailed(courseId: number, options?: any): AxiosPromise<Array<CourseTaskDetailedDto>> {
            return localVarFp.getCourseTasksDetailed(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {'started' | 'inprogress' | 'finished'} [status]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseTasksWithStudentSolution(courseId: number, status?: 'started' | 'inprogress' | 'finished', options?: any): AxiosPromise<Array<CourseTaskDto>> {
            return localVarFp.getCourseTasksWithStudentSolution(courseId, status, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {number} courseTaskId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrossCheckCsv(courseId: number, courseTaskId: number, options?: any): AxiosPromise<void> {
            return localVarFp.getCrossCheckCsv(courseId, courseTaskId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {number} pageSize
         * @param {number} current
         * @param {string} [orderBy]
         * @param {string} [orderDirection]
         * @param {string} [checker]
         * @param {string} [student]
         * @param {string} [url]
         * @param {string} [task]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrossCheckPairs(courseId: number, pageSize: number, current: number, orderBy?: string, orderDirection?: string, checker?: string, student?: string, url?: string, task?: string, options?: any): AxiosPromise<CrossCheckPairResponseDto> {
            return localVarFp.getCrossCheckPairs(courseId, pageSize, current, orderBy, orderDirection, checker, student, url, task, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {number} courseTaskId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyCrossCheckFeedbacks(courseId: number, courseTaskId: number, options?: any): AxiosPromise<CrossCheckFeedbackDto> {
            return localVarFp.getMyCrossCheckFeedbacks(courseId, courseTaskId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {CheckTasksDeadlineDto} checkTasksDeadlineDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyTasksDeadlines(checkTasksDeadlineDto: CheckTasksDeadlineDto, options?: any): AxiosPromise<void> {
            return localVarFp.notifyTasksDeadlines(checkTasksDeadlineDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {number} courseTaskId
         * @param {UpdateCourseTaskDto} updateCourseTaskDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseTask(courseId: number, courseTaskId: number, updateCourseTaskDto: UpdateCourseTaskDto, options?: any): AxiosPromise<CourseTaskDetailedDto> {
            return localVarFp.updateCourseTask(courseId, courseTaskId, updateCourseTaskDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoursesTasksApi - object-oriented interface
 * @export
 * @class CoursesTasksApi
 * @extends {BaseAPI}
 */
export class CoursesTasksApi extends BaseAPI {
    /**
     *
     * @param {number} courseId
     * @param {CreateCourseTaskDto} createCourseTaskDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesTasksApi
     */
    public createCourseTask(courseId: number, createCourseTaskDto: CreateCourseTaskDto, options?: AxiosRequestConfig) {
        return CoursesTasksApiFp(this.configuration).createCourseTask(courseId, createCourseTaskDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {number} courseTaskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesTasksApi
     */
    public deleteCourseTask(courseId: number, courseTaskId: number, options?: AxiosRequestConfig) {
        return CoursesTasksApiFp(this.configuration).deleteCourseTask(courseId, courseTaskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesTasksApi
     */
    public getAvailableCrossCheckReviewStats(courseId: number, options?: AxiosRequestConfig) {
        return CoursesTasksApiFp(this.configuration).getAvailableCrossCheckReviewStats(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {number} courseTaskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesTasksApi
     */
    public getCourseTask(courseId: number, courseTaskId: number, options?: AxiosRequestConfig) {
        return CoursesTasksApiFp(this.configuration).getCourseTask(courseId, courseTaskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {'started' | 'inprogress' | 'finished'} [status]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesTasksApi
     */
    public getCourseTasks(courseId: number, status?: 'started' | 'inprogress' | 'finished', options?: AxiosRequestConfig) {
        return CoursesTasksApiFp(this.configuration).getCourseTasks(courseId, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesTasksApi
     */
    public getCourseTasksDetailed(courseId: number, options?: AxiosRequestConfig) {
        return CoursesTasksApiFp(this.configuration).getCourseTasksDetailed(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {'started' | 'inprogress' | 'finished'} [status]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesTasksApi
     */
    public getCourseTasksWithStudentSolution(courseId: number, status?: 'started' | 'inprogress' | 'finished', options?: AxiosRequestConfig) {
        return CoursesTasksApiFp(this.configuration).getCourseTasksWithStudentSolution(courseId, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {number} courseTaskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesTasksApi
     */
    public getCrossCheckCsv(courseId: number, courseTaskId: number, options?: AxiosRequestConfig) {
        return CoursesTasksApiFp(this.configuration).getCrossCheckCsv(courseId, courseTaskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {number} pageSize
     * @param {number} current
     * @param {string} [orderBy]
     * @param {string} [orderDirection]
     * @param {string} [checker]
     * @param {string} [student]
     * @param {string} [url]
     * @param {string} [task]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesTasksApi
     */
    public getCrossCheckPairs(courseId: number, pageSize: number, current: number, orderBy?: string, orderDirection?: string, checker?: string, student?: string, url?: string, task?: string, options?: AxiosRequestConfig) {
        return CoursesTasksApiFp(this.configuration).getCrossCheckPairs(courseId, pageSize, current, orderBy, orderDirection, checker, student, url, task, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {number} courseTaskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesTasksApi
     */
    public getMyCrossCheckFeedbacks(courseId: number, courseTaskId: number, options?: AxiosRequestConfig) {
        return CoursesTasksApiFp(this.configuration).getMyCrossCheckFeedbacks(courseId, courseTaskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {CheckTasksDeadlineDto} checkTasksDeadlineDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesTasksApi
     */
    public notifyTasksDeadlines(checkTasksDeadlineDto: CheckTasksDeadlineDto, options?: AxiosRequestConfig) {
        return CoursesTasksApiFp(this.configuration).notifyTasksDeadlines(checkTasksDeadlineDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {number} courseTaskId
     * @param {UpdateCourseTaskDto} updateCourseTaskDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesTasksApi
     */
    public updateCourseTask(courseId: number, courseTaskId: number, updateCourseTaskDto: UpdateCourseTaskDto, options?: AxiosRequestConfig) {
        return CoursesTasksApiFp(this.configuration).updateCourseTask(courseId, courseTaskId, updateCourseTaskDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DisciplinesApi - axios parameter creator
 * @export
 */
export const DisciplinesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {CreateDisciplineDto} createDisciplineDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiscipline: async (createDisciplineDto: CreateDisciplineDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDisciplineDto' is not null or undefined
            assertParamExists('createDiscipline', 'createDisciplineDto', createDisciplineDto)
            const localVarPath = `/disciplines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDisciplineDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscipline: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDiscipline', 'id', id)
            const localVarPath = `/disciplines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisciplines: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/disciplines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {UpdateDisciplineDto} updateDisciplineDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDiscipline: async (id: number, updateDisciplineDto: UpdateDisciplineDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDiscipline', 'id', id)
            // verify required parameter 'updateDisciplineDto' is not null or undefined
            assertParamExists('updateDiscipline', 'updateDisciplineDto', updateDisciplineDto)
            const localVarPath = `/disciplines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDisciplineDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DisciplinesApi - functional programming interface
 * @export
 */
export const DisciplinesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DisciplinesApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {CreateDisciplineDto} createDisciplineDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDiscipline(createDisciplineDto: CreateDisciplineDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisciplineDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDiscipline(createDisciplineDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDiscipline(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDiscipline(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDisciplines(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DisciplineDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDisciplines(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id
         * @param {UpdateDisciplineDto} updateDisciplineDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDiscipline(id: number, updateDisciplineDto: UpdateDisciplineDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisciplineDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDiscipline(id, updateDisciplineDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DisciplinesApi - factory interface
 * @export
 */
export const DisciplinesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DisciplinesApiFp(configuration)
    return {
        /**
         *
         * @param {CreateDisciplineDto} createDisciplineDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiscipline(createDisciplineDto: CreateDisciplineDto, options?: any): AxiosPromise<DisciplineDto> {
            return localVarFp.createDiscipline(createDisciplineDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscipline(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDiscipline(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisciplines(options?: any): AxiosPromise<Array<DisciplineDto>> {
            return localVarFp.getDisciplines(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id
         * @param {UpdateDisciplineDto} updateDisciplineDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDiscipline(id: number, updateDisciplineDto: UpdateDisciplineDto, options?: any): AxiosPromise<DisciplineDto> {
            return localVarFp.updateDiscipline(id, updateDisciplineDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DisciplinesApi - object-oriented interface
 * @export
 * @class DisciplinesApi
 * @extends {BaseAPI}
 */
export class DisciplinesApi extends BaseAPI {
    /**
     *
     * @param {CreateDisciplineDto} createDisciplineDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisciplinesApi
     */
    public createDiscipline(createDisciplineDto: CreateDisciplineDto, options?: AxiosRequestConfig) {
        return DisciplinesApiFp(this.configuration).createDiscipline(createDisciplineDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisciplinesApi
     */
    public deleteDiscipline(id: number, options?: AxiosRequestConfig) {
        return DisciplinesApiFp(this.configuration).deleteDiscipline(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisciplinesApi
     */
    public getDisciplines(options?: AxiosRequestConfig) {
        return DisciplinesApiFp(this.configuration).getDisciplines(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id
     * @param {UpdateDisciplineDto} updateDisciplineDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisciplinesApi
     */
    public updateDiscipline(id: number, updateDisciplineDto: UpdateDisciplineDto, options?: AxiosRequestConfig) {
        return DisciplinesApiFp(this.configuration).updateDiscipline(id, updateDisciplineDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DiscordServersApi - axios parameter creator
 * @export
 */
export const DiscordServersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {CreateDiscordServerDto} createDiscordServerDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiscordServer: async (createDiscordServerDto: CreateDiscordServerDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDiscordServerDto' is not null or undefined
            assertParamExists('createDiscordServer', 'createDiscordServerDto', createDiscordServerDto)
            const localVarPath = `/discord-servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDiscordServerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscordServer: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDiscordServer', 'id', id)
            const localVarPath = `/discord-servers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscordServers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/discord-servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {UpdateDiscordServerDto} updateDiscordServerDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDiscordServer: async (id: number, updateDiscordServerDto: UpdateDiscordServerDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDiscordServer', 'id', id)
            // verify required parameter 'updateDiscordServerDto' is not null or undefined
            assertParamExists('updateDiscordServer', 'updateDiscordServerDto', updateDiscordServerDto)
            const localVarPath = `/discord-servers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDiscordServerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiscordServersApi - functional programming interface
 * @export
 */
export const DiscordServersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DiscordServersApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {CreateDiscordServerDto} createDiscordServerDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDiscordServer(createDiscordServerDto: CreateDiscordServerDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscordServerDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDiscordServer(createDiscordServerDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDiscordServer(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscordServerDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDiscordServer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDiscordServers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DiscordServerDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDiscordServers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id
         * @param {UpdateDiscordServerDto} updateDiscordServerDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDiscordServer(id: number, updateDiscordServerDto: UpdateDiscordServerDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscordServerDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDiscordServer(id, updateDiscordServerDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DiscordServersApi - factory interface
 * @export
 */
export const DiscordServersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DiscordServersApiFp(configuration)
    return {
        /**
         *
         * @param {CreateDiscordServerDto} createDiscordServerDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiscordServer(createDiscordServerDto: CreateDiscordServerDto, options?: any): AxiosPromise<DiscordServerDto> {
            return localVarFp.createDiscordServer(createDiscordServerDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscordServer(id: number, options?: any): AxiosPromise<DiscordServerDto> {
            return localVarFp.deleteDiscordServer(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscordServers(options?: any): AxiosPromise<Array<DiscordServerDto>> {
            return localVarFp.getDiscordServers(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id
         * @param {UpdateDiscordServerDto} updateDiscordServerDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDiscordServer(id: number, updateDiscordServerDto: UpdateDiscordServerDto, options?: any): AxiosPromise<DiscordServerDto> {
            return localVarFp.updateDiscordServer(id, updateDiscordServerDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DiscordServersApi - object-oriented interface
 * @export
 * @class DiscordServersApi
 * @extends {BaseAPI}
 */
export class DiscordServersApi extends BaseAPI {
    /**
     *
     * @param {CreateDiscordServerDto} createDiscordServerDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscordServersApi
     */
    public createDiscordServer(createDiscordServerDto: CreateDiscordServerDto, options?: AxiosRequestConfig) {
        return DiscordServersApiFp(this.configuration).createDiscordServer(createDiscordServerDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscordServersApi
     */
    public deleteDiscordServer(id: number, options?: AxiosRequestConfig) {
        return DiscordServersApiFp(this.configuration).deleteDiscordServer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscordServersApi
     */
    public getDiscordServers(options?: AxiosRequestConfig) {
        return DiscordServersApiFp(this.configuration).getDiscordServers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id
     * @param {UpdateDiscordServerDto} updateDiscordServerDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscordServersApi
     */
    public updateDiscordServer(id: number, updateDiscordServerDto: UpdateDiscordServerDto, options?: AxiosRequestConfig) {
        return DiscordServersApiFp(this.configuration).updateDiscordServer(id, updateDiscordServerDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {CreateEventDto} createEventDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (createEventDto: CreateEventDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createEventDto' is not null or undefined
            assertParamExists('createEvent', 'createEventDto', createEventDto)
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteEvent', 'id', id)
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {UpdateEventDto} updateEventDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent: async (id: number, updateEventDto: UpdateEventDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateEvent', 'id', id)
            // verify required parameter 'updateEventDto' is not null or undefined
            assertParamExists('updateEvent', 'updateEventDto', updateEventDto)
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEventDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {CreateEventDto} createEventDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(createEventDto: CreateEventDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(createEventDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEvent(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEvent(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id
         * @param {UpdateEventDto} updateEventDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEvent(id: number, updateEventDto: UpdateEventDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvent(id, updateEventDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         *
         * @param {CreateEventDto} createEventDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(createEventDto: CreateEventDto, options?: any): AxiosPromise<EventDto> {
            return localVarFp.createEvent(createEventDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEvent(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(options?: any): AxiosPromise<Array<EventDto>> {
            return localVarFp.getEvents(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id
         * @param {UpdateEventDto} updateEventDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent(id: number, updateEventDto: UpdateEventDto, options?: any): AxiosPromise<EventDto> {
            return localVarFp.updateEvent(id, updateEventDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     *
     * @param {CreateEventDto} createEventDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public createEvent(createEventDto: CreateEventDto, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).createEvent(createEventDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public deleteEvent(id: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).deleteEvent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEvents(options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEvents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id
     * @param {UpdateEventDto} updateEventDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateEvent(id: number, updateEventDto: UpdateEventDto, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).updateEvent(id, updateEventDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GratitudesApi - axios parameter creator
 * @export
 */
export const GratitudesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {CreateGratitudeDto} createGratitudeDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGratitude: async (createGratitudeDto: CreateGratitudeDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createGratitudeDto' is not null or undefined
            assertParamExists('createGratitude', 'createGratitudeDto', createGratitudeDto)
            const localVarPath = `/gratitudes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGratitudeDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBadges: async (courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getBadges', 'courseId', courseId)
            const localVarPath = `/gratitudes/badges/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GratitudesApi - functional programming interface
 * @export
 */
export const GratitudesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GratitudesApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {CreateGratitudeDto} createGratitudeDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGratitude(createGratitudeDto: CreateGratitudeDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GratitudeDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGratitude(createGratitudeDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBadges(courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BadgeDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBadges(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GratitudesApi - factory interface
 * @export
 */
export const GratitudesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GratitudesApiFp(configuration)
    return {
        /**
         *
         * @param {CreateGratitudeDto} createGratitudeDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGratitude(createGratitudeDto: CreateGratitudeDto, options?: any): AxiosPromise<GratitudeDto> {
            return localVarFp.createGratitude(createGratitudeDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBadges(courseId: number, options?: any): AxiosPromise<Array<BadgeDto>> {
            return localVarFp.getBadges(courseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GratitudesApi - object-oriented interface
 * @export
 * @class GratitudesApi
 * @extends {BaseAPI}
 */
export class GratitudesApi extends BaseAPI {
    /**
     *
     * @param {CreateGratitudeDto} createGratitudeDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GratitudesApi
     */
    public createGratitude(createGratitudeDto: CreateGratitudeDto, options?: AxiosRequestConfig) {
        return GratitudesApiFp(this.configuration).createGratitude(createGratitudeDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GratitudesApi
     */
    public getBadges(courseId: number, options?: AxiosRequestConfig) {
        return GratitudesApiFp(this.configuration).getBadges(courseId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MentorsApi - axios parameter creator
 * @export
 */
export const MentorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} mentorId
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseStudentsCount: async (mentorId: number, courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mentorId' is not null or undefined
            assertParamExists('getCourseStudentsCount', 'mentorId', mentorId)
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getCourseStudentsCount', 'courseId', courseId)
            const localVarPath = `/mentors/{mentorId}/course/{courseId}/students`
                .replace(`{${"mentorId"}}`, encodeURIComponent(String(mentorId)))
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} mentorId
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMentorDashboardData: async (mentorId: number, courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mentorId' is not null or undefined
            assertParamExists('getMentorDashboardData', 'mentorId', mentorId)
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getMentorDashboardData', 'courseId', courseId)
            const localVarPath = `/mentors/{mentorId}/course/{courseId}/dashboard`
                .replace(`{${"mentorId"}}`, encodeURIComponent(String(mentorId)))
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} mentorId
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMentorOptions: async (mentorId: number, courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mentorId' is not null or undefined
            assertParamExists('getMentorOptions', 'mentorId', mentorId)
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getMentorOptions', 'courseId', courseId)
            const localVarPath = `/mentors/{mentorId}/course/{courseId}/options`
                .replace(`{${"mentorId"}}`, encodeURIComponent(String(mentorId)))
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} mentorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMentorStudents: async (mentorId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mentorId' is not null or undefined
            assertParamExists('getMentorStudents', 'mentorId', mentorId)
            const localVarPath = `/mentors/{mentorId}/students`
                .replace(`{${"mentorId"}}`, encodeURIComponent(String(mentorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} mentorId
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomTask: async (mentorId: number, courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mentorId' is not null or undefined
            assertParamExists('getRandomTask', 'mentorId', mentorId)
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getRandomTask', 'courseId', courseId)
            const localVarPath = `/mentors/{mentorId}/course/{courseId}/random-task`
                .replace(`{${"mentorId"}}`, encodeURIComponent(String(mentorId)))
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MentorsApi - functional programming interface
 * @export
 */
export const MentorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MentorsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {number} mentorId
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseStudentsCount(mentorId: number, courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseStudentsCount(mentorId, courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} mentorId
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMentorDashboardData(mentorId: number, courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MentorDashboardDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMentorDashboardData(mentorId, courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} mentorId
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMentorOptions(mentorId: number, courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MentorOptionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMentorOptions(mentorId, courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} mentorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMentorStudents(mentorId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MentorStudentDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMentorStudents(mentorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} mentorId
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRandomTask(mentorId: number, courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRandomTask(mentorId, courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MentorsApi - factory interface
 * @export
 */
export const MentorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MentorsApiFp(configuration)
    return {
        /**
         *
         * @param {number} mentorId
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseStudentsCount(mentorId: number, courseId: number, options?: any): AxiosPromise<number> {
            return localVarFp.getCourseStudentsCount(mentorId, courseId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} mentorId
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMentorDashboardData(mentorId: number, courseId: number, options?: any): AxiosPromise<Array<MentorDashboardDto>> {
            return localVarFp.getMentorDashboardData(mentorId, courseId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} mentorId
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMentorOptions(mentorId: number, courseId: number, options?: any): AxiosPromise<MentorOptionsDto> {
            return localVarFp.getMentorOptions(mentorId, courseId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} mentorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMentorStudents(mentorId: number, options?: any): AxiosPromise<Array<MentorStudentDto>> {
            return localVarFp.getMentorStudents(mentorId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} mentorId
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomTask(mentorId: number, courseId: number, options?: any): AxiosPromise<void> {
            return localVarFp.getRandomTask(mentorId, courseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MentorsApi - object-oriented interface
 * @export
 * @class MentorsApi
 * @extends {BaseAPI}
 */
export class MentorsApi extends BaseAPI {
    /**
     *
     * @param {number} mentorId
     * @param {number} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MentorsApi
     */
    public getCourseStudentsCount(mentorId: number, courseId: number, options?: AxiosRequestConfig) {
        return MentorsApiFp(this.configuration).getCourseStudentsCount(mentorId, courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} mentorId
     * @param {number} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MentorsApi
     */
    public getMentorDashboardData(mentorId: number, courseId: number, options?: AxiosRequestConfig) {
        return MentorsApiFp(this.configuration).getMentorDashboardData(mentorId, courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} mentorId
     * @param {number} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MentorsApi
     */
    public getMentorOptions(mentorId: number, courseId: number, options?: AxiosRequestConfig) {
        return MentorsApiFp(this.configuration).getMentorOptions(mentorId, courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} mentorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MentorsApi
     */
    public getMentorStudents(mentorId: number, options?: AxiosRequestConfig) {
        return MentorsApiFp(this.configuration).getMentorStudents(mentorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} mentorId
     * @param {number} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MentorsApi
     */
    public getRandomTask(mentorId: number, courseId: number, options?: AxiosRequestConfig) {
        return MentorsApiFp(this.configuration).getRandomTask(mentorId, courseId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {UpdateNotificationDto} updateNotificationDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotification: async (updateNotificationDto: UpdateNotificationDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateNotificationDto' is not null or undefined
            assertParamExists('createNotification', 'updateNotificationDto', updateNotificationDto)
            const localVarPath = `/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNotificationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotification: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteNotification', 'id', id)
            const localVarPath = `/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {UpdateNotificationDto} updateNotificationDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotification: async (updateNotificationDto: UpdateNotificationDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateNotificationDto' is not null or undefined
            assertParamExists('updateNotification', 'updateNotificationDto', updateNotificationDto)
            const localVarPath = `/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNotificationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {UpdateNotificationDto} updateNotificationDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNotification(updateNotificationDto: UpdateNotificationDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNotification(updateNotificationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNotification(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNotification(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotifications(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotifications(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {UpdateNotificationDto} updateNotificationDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNotification(updateNotificationDto: UpdateNotificationDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNotification(updateNotificationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         *
         * @param {UpdateNotificationDto} updateNotificationDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotification(updateNotificationDto: UpdateNotificationDto, options?: any): AxiosPromise<NotificationDto> {
            return localVarFp.createNotification(updateNotificationDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotification(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteNotification(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(options?: any): AxiosPromise<Array<NotificationDto>> {
            return localVarFp.getNotifications(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {UpdateNotificationDto} updateNotificationDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotification(updateNotificationDto: UpdateNotificationDto, options?: any): AxiosPromise<NotificationDto> {
            return localVarFp.updateNotification(updateNotificationDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     *
     * @param {UpdateNotificationDto} updateNotificationDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public createNotification(updateNotificationDto: UpdateNotificationDto, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).createNotification(updateNotificationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public deleteNotification(id: string, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).deleteNotification(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public getNotifications(options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).getNotifications(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {UpdateNotificationDto} updateNotificationDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public updateNotification(updateNotificationDto: UpdateNotificationDto, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).updateNotification(updateNotificationDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OpportunitiesApi - axios parameter creator
 * @export
 */
export const OpportunitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConsent: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/opportunities/consent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConsent: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/opportunities/consent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicants: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/opportunities/applicants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsent: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/opportunities/consent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicResume: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getPublicResume', 'uuid', uuid)
            const localVarPath = `/opportunities/public/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} githubId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResume: async (githubId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'githubId' is not null or undefined
            assertParamExists('getResume', 'githubId', githubId)
            const localVarPath = `/opportunities/{githubId}/resume`
                .replace(`{${"githubId"}}`, encodeURIComponent(String(githubId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prolong: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/opportunities/prolong`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} githubId
         * @param {FormDataDto} formDataDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveResume: async (githubId: string, formDataDto: FormDataDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'githubId' is not null or undefined
            assertParamExists('saveResume', 'githubId', githubId)
            // verify required parameter 'formDataDto' is not null or undefined
            assertParamExists('saveResume', 'formDataDto', formDataDto)
            const localVarPath = `/opportunities/{githubId}/resume`
                .replace(`{${"githubId"}}`, encodeURIComponent(String(githubId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(formDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setVisibility: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/opportunities/visibility`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OpportunitiesApi - functional programming interface
 * @export
 */
export const OpportunitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OpportunitiesApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConsent(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GiveConsentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConsent(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConsent(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConsent(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicants(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicantResumeDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicants(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConsent(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConsent(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicResume(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResumeDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicResume(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} githubId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResume(githubId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResumeDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResume(githubId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prolong(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prolong(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} githubId
         * @param {FormDataDto} formDataDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveResume(githubId: string, formDataDto: FormDataDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveResume(githubId, formDataDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setVisibility(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VisibilityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setVisibility(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OpportunitiesApi - factory interface
 * @export
 */
export const OpportunitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OpportunitiesApiFp(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConsent(options?: any): AxiosPromise<GiveConsentDto> {
            return localVarFp.createConsent(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConsent(options?: any): AxiosPromise<ConsentDto> {
            return localVarFp.deleteConsent(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicants(options?: any): AxiosPromise<Array<ApplicantResumeDto>> {
            return localVarFp.getApplicants(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsent(options?: any): AxiosPromise<ConsentDto> {
            return localVarFp.getConsent(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicResume(uuid: string, options?: any): AxiosPromise<ResumeDto> {
            return localVarFp.getPublicResume(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} githubId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResume(githubId: string, options?: any): AxiosPromise<ResumeDto> {
            return localVarFp.getResume(githubId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prolong(options?: any): AxiosPromise<StatusDto> {
            return localVarFp.prolong(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} githubId
         * @param {FormDataDto} formDataDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveResume(githubId: string, formDataDto: FormDataDto, options?: any): AxiosPromise<object> {
            return localVarFp.saveResume(githubId, formDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setVisibility(options?: any): AxiosPromise<VisibilityDto> {
            return localVarFp.setVisibility(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OpportunitiesApi - object-oriented interface
 * @export
 * @class OpportunitiesApi
 * @extends {BaseAPI}
 */
export class OpportunitiesApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpportunitiesApi
     */
    public createConsent(options?: AxiosRequestConfig) {
        return OpportunitiesApiFp(this.configuration).createConsent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpportunitiesApi
     */
    public deleteConsent(options?: AxiosRequestConfig) {
        return OpportunitiesApiFp(this.configuration).deleteConsent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpportunitiesApi
     */
    public getApplicants(options?: AxiosRequestConfig) {
        return OpportunitiesApiFp(this.configuration).getApplicants(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpportunitiesApi
     */
    public getConsent(options?: AxiosRequestConfig) {
        return OpportunitiesApiFp(this.configuration).getConsent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpportunitiesApi
     */
    public getPublicResume(uuid: string, options?: AxiosRequestConfig) {
        return OpportunitiesApiFp(this.configuration).getPublicResume(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} githubId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpportunitiesApi
     */
    public getResume(githubId: string, options?: AxiosRequestConfig) {
        return OpportunitiesApiFp(this.configuration).getResume(githubId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpportunitiesApi
     */
    public prolong(options?: AxiosRequestConfig) {
        return OpportunitiesApiFp(this.configuration).prolong(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} githubId
     * @param {FormDataDto} formDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpportunitiesApi
     */
    public saveResume(githubId: string, formDataDto: FormDataDto, options?: AxiosRequestConfig) {
        return OpportunitiesApiFp(this.configuration).saveResume(githubId, formDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpportunitiesApi
     */
    public setVisibility(options?: AxiosRequestConfig) {
        return OpportunitiesApiFp(this.configuration).setVisibility(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProfileApi - axios parameter creator
 * @export
 */
export const ProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmployment: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/employment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEndorsement: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getEndorsement', 'username', username)
            const localVarPath = `/profile/{username}/endorsement`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonalProfile: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getPersonalProfile', 'username', username)
            const localVarPath = `/profile/{username}/personal`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getProfile', 'username', username)
            const localVarPath = `/profile/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCourses: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUserCourses', 'username', username)
            const localVarPath = `/profile/{username}/courses`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {ProfileInfoDto} profileInfoDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileInfo: async (profileInfoDto: ProfileInfoDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileInfoDto' is not null or undefined
            assertParamExists('updateProfileInfo', 'profileInfoDto', profileInfoDto)
            const localVarPath = `/profile/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profileInfoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {UpdateProfileInfoDto} updateProfileInfoDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileInfoFlat: async (updateProfileInfoDto: UpdateProfileInfoDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateProfileInfoDto' is not null or undefined
            assertParamExists('updateProfileInfoFlat', 'updateProfileInfoDto', updateProfileInfoDto)
            const localVarPath = `/profile/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProfileInfoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {UpdateUserDto} updateUserDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (updateUserDto: UpdateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('updateUser', 'updateUserDto', updateUserDto)
            const localVarPath = `/profile/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmployment(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EmploymentRecordDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEmployment(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEndorsement(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EndorsementDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEndorsement(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonalProfile(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonalProfileDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonalProfile(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfile(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfile(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCourses(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProfileCourseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCourses(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {ProfileInfoDto} profileInfoDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfileInfo(profileInfoDto: ProfileInfoDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProfileInfo(profileInfoDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {UpdateProfileInfoDto} updateProfileInfoDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfileInfoFlat(updateProfileInfoDto: UpdateProfileInfoDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProfileInfoFlat(updateProfileInfoDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {UpdateUserDto} updateUserDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(updateUserDto: UpdateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(updateUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileApiFp(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmployment(options?: any): AxiosPromise<Array<EmploymentRecordDto>> {
            return localVarFp.getEmployment(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEndorsement(username: string, options?: any): AxiosPromise<EndorsementDto> {
            return localVarFp.getEndorsement(username, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonalProfile(username: string, options?: any): AxiosPromise<PersonalProfileDto> {
            return localVarFp.getPersonalProfile(username, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(username: string, options?: any): AxiosPromise<ProfileDto> {
            return localVarFp.getProfile(username, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCourses(username: string, options?: any): AxiosPromise<Array<ProfileCourseDto>> {
            return localVarFp.getUserCourses(username, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {ProfileInfoDto} profileInfoDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileInfo(profileInfoDto: ProfileInfoDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateProfileInfo(profileInfoDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {UpdateProfileInfoDto} updateProfileInfoDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileInfoFlat(updateProfileInfoDto: UpdateProfileInfoDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateProfileInfoFlat(updateProfileInfoDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {UpdateUserDto} updateUserDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(updateUserDto: UpdateUserDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateUser(updateUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getEmployment(options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).getEmployment(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getEndorsement(username: string, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).getEndorsement(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getPersonalProfile(username: string, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).getPersonalProfile(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getProfile(username: string, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).getProfile(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getUserCourses(username: string, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).getUserCourses(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {ProfileInfoDto} profileInfoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public updateProfileInfo(profileInfoDto: ProfileInfoDto, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).updateProfileInfo(profileInfoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {UpdateProfileInfoDto} updateProfileInfoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public updateProfileInfoFlat(updateProfileInfoDto: UpdateProfileInfoDto, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).updateProfileInfoFlat(updateProfileInfoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {UpdateUserDto} updateUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public updateUser(updateUserDto: UpdateUserDto, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).updateUser(updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PromptsApi - axios parameter creator
 * @export
 */
export const PromptsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {CreatePromptDto} createPromptDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrompt: async (createPromptDto: CreatePromptDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPromptDto' is not null or undefined
            assertParamExists('createPrompt', 'createPromptDto', createPromptDto)
            const localVarPath = `/prompts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPromptDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrompt: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePrompt', 'id', id)
            const localVarPath = `/prompts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrompts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/prompts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {UpdatePromptDto} updatePromptDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrompt: async (id: number, updatePromptDto: UpdatePromptDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePrompt', 'id', id)
            // verify required parameter 'updatePromptDto' is not null or undefined
            assertParamExists('updatePrompt', 'updatePromptDto', updatePromptDto)
            const localVarPath = `/prompts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePromptDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromptsApi - functional programming interface
 * @export
 */
export const PromptsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromptsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {CreatePromptDto} createPromptDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPrompt(createPromptDto: CreatePromptDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromptDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPrompt(createPromptDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePrompt(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePrompt(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrompts(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PromptDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPrompts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id
         * @param {UpdatePromptDto} updatePromptDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePrompt(id: number, updatePromptDto: UpdatePromptDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromptDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePrompt(id, updatePromptDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PromptsApi - factory interface
 * @export
 */
export const PromptsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromptsApiFp(configuration)
    return {
        /**
         *
         * @param {CreatePromptDto} createPromptDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrompt(createPromptDto: CreatePromptDto, options?: any): AxiosPromise<PromptDto> {
            return localVarFp.createPrompt(createPromptDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrompt(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deletePrompt(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrompts(options?: any): AxiosPromise<Array<PromptDto>> {
            return localVarFp.getPrompts(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id
         * @param {UpdatePromptDto} updatePromptDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrompt(id: number, updatePromptDto: UpdatePromptDto, options?: any): AxiosPromise<PromptDto> {
            return localVarFp.updatePrompt(id, updatePromptDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromptsApi - object-oriented interface
 * @export
 * @class PromptsApi
 * @extends {BaseAPI}
 */
export class PromptsApi extends BaseAPI {
    /**
     *
     * @param {CreatePromptDto} createPromptDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public createPrompt(createPromptDto: CreatePromptDto, options?: AxiosRequestConfig) {
        return PromptsApiFp(this.configuration).createPrompt(createPromptDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public deletePrompt(id: number, options?: AxiosRequestConfig) {
        return PromptsApiFp(this.configuration).deletePrompt(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public getPrompts(options?: AxiosRequestConfig) {
        return PromptsApiFp(this.configuration).getPrompts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id
     * @param {UpdatePromptDto} updatePromptDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public updatePrompt(id: number, updatePromptDto: UpdatePromptDto, options?: AxiosRequestConfig) {
        return PromptsApiFp(this.configuration).updatePrompt(id, updatePromptDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RegistryApi - axios parameter creator
 * @export
 */
export const RegistryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} githubId
         * @param {ApproveMentorDto} approveMentorDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveMentor: async (githubId: string, approveMentorDto: ApproveMentorDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'githubId' is not null or undefined
            assertParamExists('approveMentor', 'githubId', githubId)
            // verify required parameter 'approveMentorDto' is not null or undefined
            assertParamExists('approveMentor', 'approveMentorDto', approveMentorDto)
            const localVarPath = `/registry/mentor/{githubId}`
                .replace(`{${"githubId"}}`, encodeURIComponent(String(githubId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(approveMentorDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} githubId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelMentorRegistry: async (githubId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'githubId' is not null or undefined
            assertParamExists('cancelMentorRegistry', 'githubId', githubId)
            const localVarPath = `/registry/mentor/{githubId}`
                .replace(`{${"githubId"}}`, encodeURIComponent(String(githubId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} githubId
         * @param {CommentMentorRegistryDto} commentMentorRegistryDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentMentorRegistry: async (githubId: string, commentMentorRegistryDto: CommentMentorRegistryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'githubId' is not null or undefined
            assertParamExists('commentMentorRegistry', 'githubId', githubId)
            // verify required parameter 'commentMentorRegistryDto' is not null or undefined
            assertParamExists('commentMentorRegistry', 'commentMentorRegistryDto', commentMentorRegistryDto)
            const localVarPath = `/registry/mentor/{githubId}/comment`
                .replace(`{${"githubId"}}`, encodeURIComponent(String(githubId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commentMentorRegistryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMentorRegistries: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/registry/mentors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistryApi - functional programming interface
 * @export
 */
export const RegistryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegistryApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} githubId
         * @param {ApproveMentorDto} approveMentorDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveMentor(githubId: string, approveMentorDto: ApproveMentorDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveMentor(githubId, approveMentorDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} githubId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelMentorRegistry(githubId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelMentorRegistry(githubId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} githubId
         * @param {CommentMentorRegistryDto} commentMentorRegistryDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentMentorRegistry(githubId: string, commentMentorRegistryDto: CommentMentorRegistryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentMentorRegistry(githubId, commentMentorRegistryDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMentorRegistries(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MentorRegistryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMentorRegistries(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RegistryApi - factory interface
 * @export
 */
export const RegistryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegistryApiFp(configuration)
    return {
        /**
         *
         * @param {string} githubId
         * @param {ApproveMentorDto} approveMentorDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveMentor(githubId: string, approveMentorDto: ApproveMentorDto, options?: any): AxiosPromise<void> {
            return localVarFp.approveMentor(githubId, approveMentorDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} githubId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelMentorRegistry(githubId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelMentorRegistry(githubId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} githubId
         * @param {CommentMentorRegistryDto} commentMentorRegistryDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentMentorRegistry(githubId: string, commentMentorRegistryDto: CommentMentorRegistryDto, options?: any): AxiosPromise<void> {
            return localVarFp.commentMentorRegistry(githubId, commentMentorRegistryDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMentorRegistries(options?: any): AxiosPromise<Array<MentorRegistryDto>> {
            return localVarFp.getMentorRegistries(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RegistryApi - object-oriented interface
 * @export
 * @class RegistryApi
 * @extends {BaseAPI}
 */
export class RegistryApi extends BaseAPI {
    /**
     *
     * @param {string} githubId
     * @param {ApproveMentorDto} approveMentorDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public approveMentor(githubId: string, approveMentorDto: ApproveMentorDto, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).approveMentor(githubId, approveMentorDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} githubId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public cancelMentorRegistry(githubId: string, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).cancelMentorRegistry(githubId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} githubId
     * @param {CommentMentorRegistryDto} commentMentorRegistryDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public commentMentorRegistry(githubId: string, commentMentorRegistryDto: CommentMentorRegistryDto, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).commentMentorRegistry(githubId, commentMentorRegistryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public getMentorRegistries(options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).getMentorRegistries(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ScheduleApi - axios parameter creator
 * @export
 */
export const ScheduleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {CheckScheduleChangesDto} checkScheduleChangesDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyScheduleChanges: async (checkScheduleChangesDto: CheckScheduleChangesDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkScheduleChangesDto' is not null or undefined
            assertParamExists('notifyScheduleChanges', 'checkScheduleChangesDto', checkScheduleChangesDto)
            const localVarPath = `/schedule/notify/changes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkScheduleChangesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduleApi - functional programming interface
 * @export
 */
export const ScheduleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScheduleApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {CheckScheduleChangesDto} checkScheduleChangesDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyScheduleChanges(checkScheduleChangesDto: CheckScheduleChangesDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyScheduleChanges(checkScheduleChangesDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ScheduleApi - factory interface
 * @export
 */
export const ScheduleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScheduleApiFp(configuration)
    return {
        /**
         *
         * @param {CheckScheduleChangesDto} checkScheduleChangesDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyScheduleChanges(checkScheduleChangesDto: CheckScheduleChangesDto, options?: any): AxiosPromise<void> {
            return localVarFp.notifyScheduleChanges(checkScheduleChangesDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScheduleApi - object-oriented interface
 * @export
 * @class ScheduleApi
 * @extends {BaseAPI}
 */
export class ScheduleApi extends BaseAPI {
    /**
     *
     * @param {CheckScheduleChangesDto} checkScheduleChangesDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public notifyScheduleChanges(checkScheduleChangesDto: CheckScheduleChangesDto, options?: AxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).notifyScheduleChanges(checkScheduleChangesDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudentsApi - axios parameter creator
 * @export
 */
export const StudentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} studentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudent: async (studentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studentId' is not null or undefined
            assertParamExists('getStudent', 'studentId', studentId)
            const localVarPath = `/students/{studentId}`
                .replace(`{${"studentId"}}`, encodeURIComponent(String(studentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudentsApi - functional programming interface
 * @export
 */
export const StudentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudentsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {number} studentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudent(studentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudent(studentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StudentsApi - factory interface
 * @export
 */
export const StudentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudentsApiFp(configuration)
    return {
        /**
         *
         * @param {number} studentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudent(studentId: number, options?: any): AxiosPromise<StudentDto> {
            return localVarFp.getStudent(studentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudentsApi - object-oriented interface
 * @export
 * @class StudentsApi
 * @extends {BaseAPI}
 */
export class StudentsApi extends BaseAPI {
    /**
     *
     * @param {number} studentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public getStudent(studentId: number, options?: AxiosRequestConfig) {
        return StudentsApiFp(this.configuration).getStudent(studentId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudentsFeedbacksApi - axios parameter creator
 * @export
 */
export const StudentsFeedbacksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} studentId
         * @param {CreateStudentFeedbackDto} createStudentFeedbackDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudentFeedback: async (studentId: number, createStudentFeedbackDto: CreateStudentFeedbackDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studentId' is not null or undefined
            assertParamExists('createStudentFeedback', 'studentId', studentId)
            // verify required parameter 'createStudentFeedbackDto' is not null or undefined
            assertParamExists('createStudentFeedback', 'createStudentFeedbackDto', createStudentFeedbackDto)
            const localVarPath = `/students/{studentId}/feedbacks`
                .replace(`{${"studentId"}}`, encodeURIComponent(String(studentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStudentFeedbackDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} studentId
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentFeedback: async (studentId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studentId' is not null or undefined
            assertParamExists('getStudentFeedback', 'studentId', studentId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStudentFeedback', 'id', id)
            const localVarPath = `/students/{studentId}/feedbacks/{id}`
                .replace(`{${"studentId"}}`, encodeURIComponent(String(studentId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} studentId
         * @param {number} id
         * @param {UpdateStudentFeedbackDto} updateStudentFeedbackDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStudentFeedback: async (studentId: number, id: number, updateStudentFeedbackDto: UpdateStudentFeedbackDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studentId' is not null or undefined
            assertParamExists('updateStudentFeedback', 'studentId', studentId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateStudentFeedback', 'id', id)
            // verify required parameter 'updateStudentFeedbackDto' is not null or undefined
            assertParamExists('updateStudentFeedback', 'updateStudentFeedbackDto', updateStudentFeedbackDto)
            const localVarPath = `/students/{studentId}/feedbacks/{id}`
                .replace(`{${"studentId"}}`, encodeURIComponent(String(studentId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStudentFeedbackDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudentsFeedbacksApi - functional programming interface
 * @export
 */
export const StudentsFeedbacksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudentsFeedbacksApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {number} studentId
         * @param {CreateStudentFeedbackDto} createStudentFeedbackDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStudentFeedback(studentId: number, createStudentFeedbackDto: CreateStudentFeedbackDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentFeedbackDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStudentFeedback(studentId, createStudentFeedbackDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} studentId
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudentFeedback(studentId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentFeedbackDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudentFeedback(studentId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} studentId
         * @param {number} id
         * @param {UpdateStudentFeedbackDto} updateStudentFeedbackDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStudentFeedback(studentId: number, id: number, updateStudentFeedbackDto: UpdateStudentFeedbackDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentFeedbackDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStudentFeedback(studentId, id, updateStudentFeedbackDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StudentsFeedbacksApi - factory interface
 * @export
 */
export const StudentsFeedbacksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudentsFeedbacksApiFp(configuration)
    return {
        /**
         *
         * @param {number} studentId
         * @param {CreateStudentFeedbackDto} createStudentFeedbackDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudentFeedback(studentId: number, createStudentFeedbackDto: CreateStudentFeedbackDto, options?: any): AxiosPromise<StudentFeedbackDto> {
            return localVarFp.createStudentFeedback(studentId, createStudentFeedbackDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} studentId
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentFeedback(studentId: number, id: number, options?: any): AxiosPromise<StudentFeedbackDto> {
            return localVarFp.getStudentFeedback(studentId, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} studentId
         * @param {number} id
         * @param {UpdateStudentFeedbackDto} updateStudentFeedbackDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStudentFeedback(studentId: number, id: number, updateStudentFeedbackDto: UpdateStudentFeedbackDto, options?: any): AxiosPromise<StudentFeedbackDto> {
            return localVarFp.updateStudentFeedback(studentId, id, updateStudentFeedbackDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudentsFeedbacksApi - object-oriented interface
 * @export
 * @class StudentsFeedbacksApi
 * @extends {BaseAPI}
 */
export class StudentsFeedbacksApi extends BaseAPI {
    /**
     *
     * @param {number} studentId
     * @param {CreateStudentFeedbackDto} createStudentFeedbackDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsFeedbacksApi
     */
    public createStudentFeedback(studentId: number, createStudentFeedbackDto: CreateStudentFeedbackDto, options?: AxiosRequestConfig) {
        return StudentsFeedbacksApiFp(this.configuration).createStudentFeedback(studentId, createStudentFeedbackDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} studentId
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsFeedbacksApi
     */
    public getStudentFeedback(studentId: number, id: number, options?: AxiosRequestConfig) {
        return StudentsFeedbacksApiFp(this.configuration).getStudentFeedback(studentId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} studentId
     * @param {number} id
     * @param {UpdateStudentFeedbackDto} updateStudentFeedbackDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsFeedbacksApi
     */
    public updateStudentFeedback(studentId: number, id: number, updateStudentFeedbackDto: UpdateStudentFeedbackDto, options?: AxiosRequestConfig) {
        return StudentsFeedbacksApiFp(this.configuration).updateStudentFeedback(studentId, id, updateStudentFeedbackDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudentsScoreApi - axios parameter creator
 * @export
 */
export const StudentsScoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} activeOnly
         * @param {'rank' | 'totalScore' | 'crossCheckScore' | 'githubId' | 'name' | 'cityName' | 'mentor' | 'totalScoreChangeDate' | 'repositoryLastActivityDate'} orderBy
         * @param {'asc' | 'null' | 'desc'} orderDirection
         * @param {string} current
         * @param {string} pageSize
         * @param {number} courseId
         * @param {string} [githubId]
         * @param {string} [name]
         * @param {string} [mentorGithubId]
         * @param {string} [cityName]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScore: async (activeOnly: string, orderBy: 'rank' | 'totalScore' | 'crossCheckScore' | 'githubId' | 'name' | 'cityName' | 'mentor' | 'totalScoreChangeDate' | 'repositoryLastActivityDate', orderDirection: 'asc' | 'null' | 'desc', current: string, pageSize: string, courseId: number, githubId?: string, name?: string, mentorGithubId?: string, cityName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activeOnly' is not null or undefined
            assertParamExists('getScore', 'activeOnly', activeOnly)
            // verify required parameter 'orderBy' is not null or undefined
            assertParamExists('getScore', 'orderBy', orderBy)
            // verify required parameter 'orderDirection' is not null or undefined
            assertParamExists('getScore', 'orderDirection', orderDirection)
            // verify required parameter 'current' is not null or undefined
            assertParamExists('getScore', 'current', current)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getScore', 'pageSize', pageSize)
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getScore', 'courseId', courseId)
            const localVarPath = `/course/{courseId}/students/score`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (activeOnly !== undefined) {
                localVarQueryParameter['activeOnly'] = activeOnly;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (githubId !== undefined) {
                localVarQueryParameter['githubId'] = githubId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (mentorGithubId !== undefined) {
                localVarQueryParameter['mentor.githubId'] = mentorGithubId;
            }

            if (cityName !== undefined) {
                localVarQueryParameter['cityName'] = cityName;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudentsScoreApi - functional programming interface
 * @export
 */
export const StudentsScoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudentsScoreApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} activeOnly
         * @param {'rank' | 'totalScore' | 'crossCheckScore' | 'githubId' | 'name' | 'cityName' | 'mentor' | 'totalScoreChangeDate' | 'repositoryLastActivityDate'} orderBy
         * @param {'asc' | 'null' | 'desc'} orderDirection
         * @param {string} current
         * @param {string} pageSize
         * @param {number} courseId
         * @param {string} [githubId]
         * @param {string} [name]
         * @param {string} [mentorGithubId]
         * @param {string} [cityName]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScore(activeOnly: string, orderBy: 'rank' | 'totalScore' | 'crossCheckScore' | 'githubId' | 'name' | 'cityName' | 'mentor' | 'totalScoreChangeDate' | 'repositoryLastActivityDate', orderDirection: 'asc' | 'null' | 'desc', current: string, pageSize: string, courseId: number, githubId?: string, name?: string, mentorGithubId?: string, cityName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScoreDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScore(activeOnly, orderBy, orderDirection, current, pageSize, courseId, githubId, name, mentorGithubId, cityName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StudentsScoreApi - factory interface
 * @export
 */
export const StudentsScoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudentsScoreApiFp(configuration)
    return {
        /**
         *
         * @param {string} activeOnly
         * @param {'rank' | 'totalScore' | 'crossCheckScore' | 'githubId' | 'name' | 'cityName' | 'mentor' | 'totalScoreChangeDate' | 'repositoryLastActivityDate'} orderBy
         * @param {'asc' | 'null' | 'desc'} orderDirection
         * @param {string} current
         * @param {string} pageSize
         * @param {number} courseId
         * @param {string} [githubId]
         * @param {string} [name]
         * @param {string} [mentorGithubId]
         * @param {string} [cityName]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScore(activeOnly: string, orderBy: 'rank' | 'totalScore' | 'crossCheckScore' | 'githubId' | 'name' | 'cityName' | 'mentor' | 'totalScoreChangeDate' | 'repositoryLastActivityDate', orderDirection: 'asc' | 'null' | 'desc', current: string, pageSize: string, courseId: number, githubId?: string, name?: string, mentorGithubId?: string, cityName?: string, options?: any): AxiosPromise<ScoreDto> {
            return localVarFp.getScore(activeOnly, orderBy, orderDirection, current, pageSize, courseId, githubId, name, mentorGithubId, cityName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudentsScoreApi - object-oriented interface
 * @export
 * @class StudentsScoreApi
 * @extends {BaseAPI}
 */
export class StudentsScoreApi extends BaseAPI {
    /**
     *
     * @param {string} activeOnly
     * @param {'rank' | 'totalScore' | 'crossCheckScore' | 'githubId' | 'name' | 'cityName' | 'mentor' | 'totalScoreChangeDate' | 'repositoryLastActivityDate'} orderBy
     * @param {'asc' | 'null' | 'desc'} orderDirection
     * @param {string} current
     * @param {string} pageSize
     * @param {number} courseId
     * @param {string} [githubId]
     * @param {string} [name]
     * @param {string} [mentorGithubId]
     * @param {string} [cityName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsScoreApi
     */
    public getScore(activeOnly: string, orderBy: 'rank' | 'totalScore' | 'crossCheckScore' | 'githubId' | 'name' | 'cityName' | 'mentor' | 'totalScoreChangeDate' | 'repositoryLastActivityDate', orderDirection: 'asc' | 'null' | 'desc', current: string, pageSize: string, courseId: number, githubId?: string, name?: string, mentorGithubId?: string, cityName?: string, options?: AxiosRequestConfig) {
        return StudentsScoreApiFp(this.configuration).getScore(activeOnly, orderBy, orderDirection, current, pageSize, courseId, githubId, name, mentorGithubId, cityName, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {CreateTaskDto} createTaskDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask: async (createTaskDto: CreateTaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTaskDto' is not null or undefined
            assertParamExists('createTask', 'createTaskDto', createTaskDto)
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTask', 'id', id)
            const localVarPath = `/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {UpdateTaskDto} updateTaskDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask: async (id: number, updateTaskDto: UpdateTaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTask', 'id', id)
            // verify required parameter 'updateTaskDto' is not null or undefined
            assertParamExists('updateTask', 'updateTaskDto', updateTaskDto)
            const localVarPath = `/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {CreateTaskDto} createTaskDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTask(createTaskDto: CreateTaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTask(createTaskDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTask(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTask(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasks(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTasks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id
         * @param {UpdateTaskDto} updateTaskDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTask(id: number, updateTaskDto: UpdateTaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTask(id, updateTaskDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksApiFp(configuration)
    return {
        /**
         *
         * @param {CreateTaskDto} createTaskDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask(createTaskDto: CreateTaskDto, options?: any): AxiosPromise<TaskDto> {
            return localVarFp.createTask(createTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTask(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(options?: any): AxiosPromise<Array<TaskDto>> {
            return localVarFp.getTasks(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id
         * @param {UpdateTaskDto} updateTaskDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask(id: number, updateTaskDto: UpdateTaskDto, options?: any): AxiosPromise<TaskDto> {
            return localVarFp.updateTask(id, updateTaskDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     *
     * @param {CreateTaskDto} createTaskDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public createTask(createTaskDto: CreateTaskDto, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).createTask(createTaskDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public deleteTask(id: number, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).deleteTask(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTasks(options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).getTasks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id
     * @param {UpdateTaskDto} updateTaskDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public updateTask(id: number, updateTaskDto: UpdateTaskDto, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).updateTask(id, updateTaskDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TasksCriteriaApi - axios parameter creator
 * @export
 */
export const TasksCriteriaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} taskId
         * @param {TaskCriteriaDto} taskCriteriaDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskCriteria: async (taskId: number, taskCriteriaDto: TaskCriteriaDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('createTaskCriteria', 'taskId', taskId)
            // verify required parameter 'taskCriteriaDto' is not null or undefined
            assertParamExists('createTaskCriteria', 'taskCriteriaDto', taskCriteriaDto)
            const localVarPath = `/tasks/{taskId}/criteria`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskCriteriaDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} taskId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskCriteria: async (taskId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getTaskCriteria', 'taskId', taskId)
            const localVarPath = `/tasks/{taskId}/criteria`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} taskId
         * @param {TaskCriteriaDto} taskCriteriaDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaskCriteria: async (taskId: number, taskCriteriaDto: TaskCriteriaDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('updateTaskCriteria', 'taskId', taskId)
            // verify required parameter 'taskCriteriaDto' is not null or undefined
            assertParamExists('updateTaskCriteria', 'taskCriteriaDto', taskCriteriaDto)
            const localVarPath = `/tasks/{taskId}/criteria`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskCriteriaDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksCriteriaApi - functional programming interface
 * @export
 */
export const TasksCriteriaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TasksCriteriaApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {number} taskId
         * @param {TaskCriteriaDto} taskCriteriaDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTaskCriteria(taskId: number, taskCriteriaDto: TaskCriteriaDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskCriteriaDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTaskCriteria(taskId, taskCriteriaDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} taskId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskCriteria(taskId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskCriteriaDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskCriteria(taskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} taskId
         * @param {TaskCriteriaDto} taskCriteriaDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTaskCriteria(taskId: number, taskCriteriaDto: TaskCriteriaDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskCriteriaDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTaskCriteria(taskId, taskCriteriaDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TasksCriteriaApi - factory interface
 * @export
 */
export const TasksCriteriaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksCriteriaApiFp(configuration)
    return {
        /**
         *
         * @param {number} taskId
         * @param {TaskCriteriaDto} taskCriteriaDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskCriteria(taskId: number, taskCriteriaDto: TaskCriteriaDto, options?: any): AxiosPromise<TaskCriteriaDto> {
            return localVarFp.createTaskCriteria(taskId, taskCriteriaDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} taskId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskCriteria(taskId: number, options?: any): AxiosPromise<TaskCriteriaDto> {
            return localVarFp.getTaskCriteria(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} taskId
         * @param {TaskCriteriaDto} taskCriteriaDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaskCriteria(taskId: number, taskCriteriaDto: TaskCriteriaDto, options?: any): AxiosPromise<TaskCriteriaDto> {
            return localVarFp.updateTaskCriteria(taskId, taskCriteriaDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TasksCriteriaApi - object-oriented interface
 * @export
 * @class TasksCriteriaApi
 * @extends {BaseAPI}
 */
export class TasksCriteriaApi extends BaseAPI {
    /**
     *
     * @param {number} taskId
     * @param {TaskCriteriaDto} taskCriteriaDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksCriteriaApi
     */
    public createTaskCriteria(taskId: number, taskCriteriaDto: TaskCriteriaDto, options?: AxiosRequestConfig) {
        return TasksCriteriaApiFp(this.configuration).createTaskCriteria(taskId, taskCriteriaDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksCriteriaApi
     */
    public getTaskCriteria(taskId: number, options?: AxiosRequestConfig) {
        return TasksCriteriaApiFp(this.configuration).getTaskCriteria(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} taskId
     * @param {TaskCriteriaDto} taskCriteriaDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksCriteriaApi
     */
    public updateTaskCriteria(taskId: number, taskCriteriaDto: TaskCriteriaDto, options?: AxiosRequestConfig) {
        return TasksCriteriaApiFp(this.configuration).updateTaskCriteria(taskId, taskCriteriaDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TeamApi - axios parameter creator
 * @export
 */
export const TeamApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} courseId
         * @param {number} distributionId
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeTeamPassword: async (courseId: number, distributionId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('changeTeamPassword', 'courseId', courseId)
            // verify required parameter 'distributionId' is not null or undefined
            assertParamExists('changeTeamPassword', 'distributionId', distributionId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('changeTeamPassword', 'id', id)
            const localVarPath = `/courses/{courseId}/team-distribution/{distributionId}/team/{id}/password`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"distributionId"}}`, encodeURIComponent(String(distributionId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {number} distributionId
         * @param {CreateTeamDto} createTeamDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam: async (courseId: number, distributionId: number, createTeamDto: CreateTeamDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('createTeam', 'courseId', courseId)
            // verify required parameter 'distributionId' is not null or undefined
            assertParamExists('createTeam', 'distributionId', distributionId)
            // verify required parameter 'createTeamDto' is not null or undefined
            assertParamExists('createTeam', 'createTeamDto', createTeamDto)
            const localVarPath = `/courses/{courseId}/team-distribution/{distributionId}/team`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"distributionId"}}`, encodeURIComponent(String(distributionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTeamDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {number} distributionId
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamPassword: async (courseId: number, distributionId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getTeamPassword', 'courseId', courseId)
            // verify required parameter 'distributionId' is not null or undefined
            assertParamExists('getTeamPassword', 'distributionId', distributionId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTeamPassword', 'id', id)
            const localVarPath = `/courses/{courseId}/team-distribution/{distributionId}/team/{id}/password`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"distributionId"}}`, encodeURIComponent(String(distributionId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {number} distributionId
         * @param {number} pageSize
         * @param {number} current
         * @param {string} search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams: async (courseId: number, distributionId: number, pageSize: number, current: number, search: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getTeams', 'courseId', courseId)
            // verify required parameter 'distributionId' is not null or undefined
            assertParamExists('getTeams', 'distributionId', distributionId)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getTeams', 'pageSize', pageSize)
            // verify required parameter 'current' is not null or undefined
            assertParamExists('getTeams', 'current', current)
            // verify required parameter 'search' is not null or undefined
            assertParamExists('getTeams', 'search', search)
            const localVarPath = `/courses/{courseId}/team-distribution/{distributionId}/team`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"distributionId"}}`, encodeURIComponent(String(distributionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {number} distributionId
         * @param {number} id
         * @param {JoinTeamDto} joinTeamDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinTeam: async (courseId: number, distributionId: number, id: number, joinTeamDto: JoinTeamDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('joinTeam', 'courseId', courseId)
            // verify required parameter 'distributionId' is not null or undefined
            assertParamExists('joinTeam', 'distributionId', distributionId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('joinTeam', 'id', id)
            // verify required parameter 'joinTeamDto' is not null or undefined
            assertParamExists('joinTeam', 'joinTeamDto', joinTeamDto)
            const localVarPath = `/courses/{courseId}/team-distribution/{distributionId}/team/{id}/join`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"distributionId"}}`, encodeURIComponent(String(distributionId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(joinTeamDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {number} distributionId
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveTeam: async (courseId: number, distributionId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('leaveTeam', 'courseId', courseId)
            // verify required parameter 'distributionId' is not null or undefined
            assertParamExists('leaveTeam', 'distributionId', distributionId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('leaveTeam', 'id', id)
            const localVarPath = `/courses/{courseId}/team-distribution/{distributionId}/team/{id}/leave`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"distributionId"}}`, encodeURIComponent(String(distributionId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {number} distributionId
         * @param {number} id
         * @param {UpdateTeamDto} updateTeamDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam: async (courseId: number, distributionId: number, id: number, updateTeamDto: UpdateTeamDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('updateTeam', 'courseId', courseId)
            // verify required parameter 'distributionId' is not null or undefined
            assertParamExists('updateTeam', 'distributionId', distributionId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTeam', 'id', id)
            // verify required parameter 'updateTeamDto' is not null or undefined
            assertParamExists('updateTeam', 'updateTeamDto', updateTeamDto)
            const localVarPath = `/courses/{courseId}/team-distribution/{distributionId}/team/{id}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"distributionId"}}`, encodeURIComponent(String(distributionId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTeamDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamApi - functional programming interface
 * @export
 */
export const TeamApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {number} distributionId
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeTeamPassword(courseId: number, distributionId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamPasswordDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeTeamPassword(courseId, distributionId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {number} distributionId
         * @param {CreateTeamDto} createTeamDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTeam(courseId: number, distributionId: number, createTeamDto: CreateTeamDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTeam(courseId, distributionId, createTeamDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {number} distributionId
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamPassword(courseId: number, distributionId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamPasswordDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamPassword(courseId, distributionId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {number} distributionId
         * @param {number} pageSize
         * @param {number} current
         * @param {string} search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeams(courseId: number, distributionId: number, pageSize: number, current: number, search: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeams(courseId, distributionId, pageSize, current, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {number} distributionId
         * @param {number} id
         * @param {JoinTeamDto} joinTeamDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinTeam(courseId: number, distributionId: number, id: number, joinTeamDto: JoinTeamDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamInfoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.joinTeam(courseId, distributionId, id, joinTeamDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {number} distributionId
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveTeam(courseId: number, distributionId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveTeam(courseId, distributionId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {number} distributionId
         * @param {number} id
         * @param {UpdateTeamDto} updateTeamDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTeam(courseId: number, distributionId: number, id: number, updateTeamDto: UpdateTeamDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTeam(courseId, distributionId, id, updateTeamDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TeamApi - factory interface
 * @export
 */
export const TeamApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamApiFp(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {number} distributionId
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeTeamPassword(courseId: number, distributionId: number, id: number, options?: any): AxiosPromise<TeamPasswordDto> {
            return localVarFp.changeTeamPassword(courseId, distributionId, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {number} distributionId
         * @param {CreateTeamDto} createTeamDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(courseId: number, distributionId: number, createTeamDto: CreateTeamDto, options?: any): AxiosPromise<TeamDto> {
            return localVarFp.createTeam(courseId, distributionId, createTeamDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {number} distributionId
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamPassword(courseId: number, distributionId: number, id: number, options?: any): AxiosPromise<TeamPasswordDto> {
            return localVarFp.getTeamPassword(courseId, distributionId, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {number} distributionId
         * @param {number} pageSize
         * @param {number} current
         * @param {string} search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams(courseId: number, distributionId: number, pageSize: number, current: number, search: string, options?: any): AxiosPromise<TeamsDto> {
            return localVarFp.getTeams(courseId, distributionId, pageSize, current, search, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {number} distributionId
         * @param {number} id
         * @param {JoinTeamDto} joinTeamDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinTeam(courseId: number, distributionId: number, id: number, joinTeamDto: JoinTeamDto, options?: any): AxiosPromise<TeamInfoDto> {
            return localVarFp.joinTeam(courseId, distributionId, id, joinTeamDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {number} distributionId
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveTeam(courseId: number, distributionId: number, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.leaveTeam(courseId, distributionId, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {number} distributionId
         * @param {number} id
         * @param {UpdateTeamDto} updateTeamDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(courseId: number, distributionId: number, id: number, updateTeamDto: UpdateTeamDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateTeam(courseId, distributionId, id, updateTeamDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamApi - object-oriented interface
 * @export
 * @class TeamApi
 * @extends {BaseAPI}
 */
export class TeamApi extends BaseAPI {
    /**
     *
     * @param {number} courseId
     * @param {number} distributionId
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public changeTeamPassword(courseId: number, distributionId: number, id: number, options?: AxiosRequestConfig) {
        return TeamApiFp(this.configuration).changeTeamPassword(courseId, distributionId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {number} distributionId
     * @param {CreateTeamDto} createTeamDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public createTeam(courseId: number, distributionId: number, createTeamDto: CreateTeamDto, options?: AxiosRequestConfig) {
        return TeamApiFp(this.configuration).createTeam(courseId, distributionId, createTeamDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {number} distributionId
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamPassword(courseId: number, distributionId: number, id: number, options?: AxiosRequestConfig) {
        return TeamApiFp(this.configuration).getTeamPassword(courseId, distributionId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {number} distributionId
     * @param {number} pageSize
     * @param {number} current
     * @param {string} search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeams(courseId: number, distributionId: number, pageSize: number, current: number, search: string, options?: AxiosRequestConfig) {
        return TeamApiFp(this.configuration).getTeams(courseId, distributionId, pageSize, current, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {number} distributionId
     * @param {number} id
     * @param {JoinTeamDto} joinTeamDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public joinTeam(courseId: number, distributionId: number, id: number, joinTeamDto: JoinTeamDto, options?: AxiosRequestConfig) {
        return TeamApiFp(this.configuration).joinTeam(courseId, distributionId, id, joinTeamDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {number} distributionId
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public leaveTeam(courseId: number, distributionId: number, id: number, options?: AxiosRequestConfig) {
        return TeamApiFp(this.configuration).leaveTeam(courseId, distributionId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {number} distributionId
     * @param {number} id
     * @param {UpdateTeamDto} updateTeamDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public updateTeam(courseId: number, distributionId: number, id: number, updateTeamDto: UpdateTeamDto, options?: AxiosRequestConfig) {
        return TeamApiFp(this.configuration).updateTeam(courseId, distributionId, id, updateTeamDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TeamDistributionApi - axios parameter creator
 * @export
 */
export const TeamDistributionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} courseId
         * @param {CreateTeamDistributionDto} createTeamDistributionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeamDistribution: async (courseId: number, createTeamDistributionDto: CreateTeamDistributionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('createTeamDistribution', 'courseId', courseId)
            // verify required parameter 'createTeamDistributionDto' is not null or undefined
            assertParamExists('createTeamDistribution', 'createTeamDistributionDto', createTeamDistributionDto)
            const localVarPath = `/courses/{courseId}/team-distribution`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTeamDistributionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamDistribution: async (courseId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('deleteTeamDistribution', 'courseId', courseId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTeamDistribution', 'id', id)
            const localVarPath = `/courses/{courseId}/team-distribution/{id}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributeStudentsToTeam: async (courseId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('distributeStudentsToTeam', 'courseId', courseId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('distributeStudentsToTeam', 'id', id)
            const localVarPath = `/courses/{courseId}/team-distribution/{id}/distribution`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseTeamDistributionDetailed: async (courseId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getCourseTeamDistributionDetailed', 'courseId', courseId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCourseTeamDistributionDetailed', 'id', id)
            const localVarPath = `/courses/{courseId}/team-distribution/{id}/detailed`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseTeamDistributions: async (courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getCourseTeamDistributions', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/team-distribution`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {number} id
         * @param {number} pageSize
         * @param {number} current
         * @param {string} search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsWithoutTeam: async (courseId: number, id: number, pageSize: number, current: number, search: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getStudentsWithoutTeam', 'courseId', courseId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStudentsWithoutTeam', 'id', id)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getStudentsWithoutTeam', 'pageSize', pageSize)
            // verify required parameter 'current' is not null or undefined
            assertParamExists('getStudentsWithoutTeam', 'current', current)
            // verify required parameter 'search' is not null or undefined
            assertParamExists('getStudentsWithoutTeam', 'search', search)
            const localVarPath = `/courses/{courseId}/team-distribution/{id}/students`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {number} id
         * @param {number} taskId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitScore: async (courseId: number, id: number, taskId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('submitScore', 'courseId', courseId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submitScore', 'id', id)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('submitScore', 'taskId', taskId)
            const localVarPath = `/courses/{courseId}/team-distribution/{id}/submit-score/{taskId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDistributionDeleteRegistry: async (id: number, courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('teamDistributionDeleteRegistry', 'id', id)
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('teamDistributionDeleteRegistry', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/team-distribution/{id}/registry`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDistributionRegistry: async (courseId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('teamDistributionRegistry', 'courseId', courseId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('teamDistributionRegistry', 'id', id)
            const localVarPath = `/courses/{courseId}/team-distribution/{id}/registry`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} courseId
         * @param {number} id
         * @param {UpdateTeamDistributionDto} updateTeamDistributionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeamDistribution: async (courseId: number, id: number, updateTeamDistributionDto: UpdateTeamDistributionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('updateTeamDistribution', 'courseId', courseId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTeamDistribution', 'id', id)
            // verify required parameter 'updateTeamDistributionDto' is not null or undefined
            assertParamExists('updateTeamDistribution', 'updateTeamDistributionDto', updateTeamDistributionDto)
            const localVarPath = `/courses/{courseId}/team-distribution/{id}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTeamDistributionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamDistributionApi - functional programming interface
 * @export
 */
export const TeamDistributionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamDistributionApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {CreateTeamDistributionDto} createTeamDistributionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTeamDistribution(courseId: number, createTeamDistributionDto: CreateTeamDistributionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamDistributionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTeamDistribution(courseId, createTeamDistributionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTeamDistribution(courseId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTeamDistribution(courseId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async distributeStudentsToTeam(courseId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.distributeStudentsToTeam(courseId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseTeamDistributionDetailed(courseId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamDistributionDetailedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseTeamDistributionDetailed(courseId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseTeamDistributions(courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamDistributionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseTeamDistributions(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {number} id
         * @param {number} pageSize
         * @param {number} current
         * @param {string} search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudentsWithoutTeam(courseId: number, id: number, pageSize: number, current: number, search: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamDistributionStudentDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudentsWithoutTeam(courseId, id, pageSize, current, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {number} id
         * @param {number} taskId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitScore(courseId: number, id: number, taskId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamDistributionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitScore(courseId, id, taskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamDistributionDeleteRegistry(id: number, courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamDistributionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamDistributionDeleteRegistry(id, courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamDistributionRegistry(courseId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamDistributionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamDistributionRegistry(courseId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} courseId
         * @param {number} id
         * @param {UpdateTeamDistributionDto} updateTeamDistributionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTeamDistribution(courseId: number, id: number, updateTeamDistributionDto: UpdateTeamDistributionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTeamDistribution(courseId, id, updateTeamDistributionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TeamDistributionApi - factory interface
 * @export
 */
export const TeamDistributionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamDistributionApiFp(configuration)
    return {
        /**
         *
         * @param {number} courseId
         * @param {CreateTeamDistributionDto} createTeamDistributionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeamDistribution(courseId: number, createTeamDistributionDto: CreateTeamDistributionDto, options?: any): AxiosPromise<TeamDistributionDto> {
            return localVarFp.createTeamDistribution(courseId, createTeamDistributionDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamDistribution(courseId: number, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTeamDistribution(courseId, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributeStudentsToTeam(courseId: number, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.distributeStudentsToTeam(courseId, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseTeamDistributionDetailed(courseId: number, id: number, options?: any): AxiosPromise<TeamDistributionDetailedDto> {
            return localVarFp.getCourseTeamDistributionDetailed(courseId, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseTeamDistributions(courseId: number, options?: any): AxiosPromise<Array<TeamDistributionDto>> {
            return localVarFp.getCourseTeamDistributions(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {number} id
         * @param {number} pageSize
         * @param {number} current
         * @param {string} search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentsWithoutTeam(courseId: number, id: number, pageSize: number, current: number, search: string, options?: any): AxiosPromise<Array<TeamDistributionStudentDto>> {
            return localVarFp.getStudentsWithoutTeam(courseId, id, pageSize, current, search, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {number} id
         * @param {number} taskId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitScore(courseId: number, id: number, taskId: number, options?: any): AxiosPromise<TeamDistributionDto> {
            return localVarFp.submitScore(courseId, id, taskId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id
         * @param {number} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDistributionDeleteRegistry(id: number, courseId: number, options?: any): AxiosPromise<TeamDistributionDto> {
            return localVarFp.teamDistributionDeleteRegistry(id, courseId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDistributionRegistry(courseId: number, id: number, options?: any): AxiosPromise<TeamDistributionDto> {
            return localVarFp.teamDistributionRegistry(courseId, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} courseId
         * @param {number} id
         * @param {UpdateTeamDistributionDto} updateTeamDistributionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeamDistribution(courseId: number, id: number, updateTeamDistributionDto: UpdateTeamDistributionDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateTeamDistribution(courseId, id, updateTeamDistributionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamDistributionApi - object-oriented interface
 * @export
 * @class TeamDistributionApi
 * @extends {BaseAPI}
 */
export class TeamDistributionApi extends BaseAPI {
    /**
     *
     * @param {number} courseId
     * @param {CreateTeamDistributionDto} createTeamDistributionDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDistributionApi
     */
    public createTeamDistribution(courseId: number, createTeamDistributionDto: CreateTeamDistributionDto, options?: AxiosRequestConfig) {
        return TeamDistributionApiFp(this.configuration).createTeamDistribution(courseId, createTeamDistributionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDistributionApi
     */
    public deleteTeamDistribution(courseId: number, id: number, options?: AxiosRequestConfig) {
        return TeamDistributionApiFp(this.configuration).deleteTeamDistribution(courseId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDistributionApi
     */
    public distributeStudentsToTeam(courseId: number, id: number, options?: AxiosRequestConfig) {
        return TeamDistributionApiFp(this.configuration).distributeStudentsToTeam(courseId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDistributionApi
     */
    public getCourseTeamDistributionDetailed(courseId: number, id: number, options?: AxiosRequestConfig) {
        return TeamDistributionApiFp(this.configuration).getCourseTeamDistributionDetailed(courseId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDistributionApi
     */
    public getCourseTeamDistributions(courseId: number, options?: AxiosRequestConfig) {
        return TeamDistributionApiFp(this.configuration).getCourseTeamDistributions(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {number} id
     * @param {number} pageSize
     * @param {number} current
     * @param {string} search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDistributionApi
     */
    public getStudentsWithoutTeam(courseId: number, id: number, pageSize: number, current: number, search: string, options?: AxiosRequestConfig) {
        return TeamDistributionApiFp(this.configuration).getStudentsWithoutTeam(courseId, id, pageSize, current, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {number} id
     * @param {number} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDistributionApi
     */
    public submitScore(courseId: number, id: number, taskId: number, options?: AxiosRequestConfig) {
        return TeamDistributionApiFp(this.configuration).submitScore(courseId, id, taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id
     * @param {number} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDistributionApi
     */
    public teamDistributionDeleteRegistry(id: number, courseId: number, options?: AxiosRequestConfig) {
        return TeamDistributionApiFp(this.configuration).teamDistributionDeleteRegistry(id, courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDistributionApi
     */
    public teamDistributionRegistry(courseId: number, id: number, options?: AxiosRequestConfig) {
        return TeamDistributionApiFp(this.configuration).teamDistributionRegistry(courseId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} courseId
     * @param {number} id
     * @param {UpdateTeamDistributionDto} updateTeamDistributionDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDistributionApi
     */
    public updateTeamDistribution(courseId: number, id: number, updateTeamDistributionDto: UpdateTeamDistributionDto, options?: AxiosRequestConfig) {
        return TeamDistributionApiFp(this.configuration).updateTeamDistribution(courseId, id, updateTeamDistributionDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserGroupApi - axios parameter creator
 * @export
 */
export const UserGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {CreateUserGroupDto} createUserGroupDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserGroup: async (createUserGroupDto: CreateUserGroupDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserGroupDto' is not null or undefined
            assertParamExists('createUserGroup', 'createUserGroupDto', createUserGroupDto)
            const localVarPath = `/user-group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserGroupDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserGroup: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUserGroup', 'id', id)
            const localVarPath = `/user-group/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {UpdateUserGroupDto} updateUserGroupDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserGroup: async (id: number, updateUserGroupDto: UpdateUserGroupDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserGroup', 'id', id)
            // verify required parameter 'updateUserGroupDto' is not null or undefined
            assertParamExists('updateUserGroup', 'updateUserGroupDto', updateUserGroupDto)
            const localVarPath = `/user-group/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserGroupDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserGroupApi - functional programming interface
 * @export
 */
export const UserGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserGroupApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {CreateUserGroupDto} createUserGroupDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserGroup(createUserGroupDto: CreateUserGroupDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGroupDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserGroup(createUserGroupDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserGroup(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGroupDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserGroups(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserGroupDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id
         * @param {UpdateUserGroupDto} updateUserGroupDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserGroup(id: number, updateUserGroupDto: UpdateUserGroupDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGroupDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserGroup(id, updateUserGroupDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserGroupApi - factory interface
 * @export
 */
export const UserGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserGroupApiFp(configuration)
    return {
        /**
         *
         * @param {CreateUserGroupDto} createUserGroupDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserGroup(createUserGroupDto: CreateUserGroupDto, options?: any): AxiosPromise<UserGroupDto> {
            return localVarFp.createUserGroup(createUserGroupDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserGroup(id: number, options?: any): AxiosPromise<UserGroupDto> {
            return localVarFp.deleteUserGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups(options?: any): AxiosPromise<Array<UserGroupDto>> {
            return localVarFp.getUserGroups(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id
         * @param {UpdateUserGroupDto} updateUserGroupDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserGroup(id: number, updateUserGroupDto: UpdateUserGroupDto, options?: any): AxiosPromise<UserGroupDto> {
            return localVarFp.updateUserGroup(id, updateUserGroupDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserGroupApi - object-oriented interface
 * @export
 * @class UserGroupApi
 * @extends {BaseAPI}
 */
export class UserGroupApi extends BaseAPI {
    /**
     *
     * @param {CreateUserGroupDto} createUserGroupDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    public createUserGroup(createUserGroupDto: CreateUserGroupDto, options?: AxiosRequestConfig) {
        return UserGroupApiFp(this.configuration).createUserGroup(createUserGroupDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    public deleteUserGroup(id: number, options?: AxiosRequestConfig) {
        return UserGroupApiFp(this.configuration).deleteUserGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    public getUserGroups(options?: AxiosRequestConfig) {
        return UserGroupApiFp(this.configuration).getUserGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id
     * @param {UpdateUserGroupDto} updateUserGroupDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    public updateUserGroup(id: number, updateUserGroupDto: UpdateUserGroupDto, options?: AxiosRequestConfig) {
        return UserGroupApiFp(this.configuration).updateUserGroup(id, updateUserGroupDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersNotificationsApi - axios parameter creator
 * @export
 */
export const UsersNotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotificationConnections: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/notifications/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotifications: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailConfirmationLink: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/notifications/confirmation/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {SendUserNotificationDto} sendUserNotificationDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendNotification: async (sendUserNotificationDto: SendUserNotificationDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendUserNotificationDto' is not null or undefined
            assertParamExists('sendNotification', 'sendUserNotificationDto', sendUserNotificationDto)
            const localVarPath = `/users/notifications/send`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendUserNotificationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {Array<UpdateNotificationUserSettingsDto>} updateNotificationUserSettingsDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNotifications: async (updateNotificationUserSettingsDto: Array<UpdateNotificationUserSettingsDto>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateNotificationUserSettingsDto' is not null or undefined
            assertParamExists('updateUserNotifications', 'updateNotificationUserSettingsDto', updateNotificationUserSettingsDto)
            const localVarPath = `/users/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNotificationUserSettingsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {UpsertNotificationConnectionDto} upsertNotificationConnectionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersNotificationsControllerCreateUserConnection: async (upsertNotificationConnectionDto: UpsertNotificationConnectionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'upsertNotificationConnectionDto' is not null or undefined
            assertParamExists('usersNotificationsControllerCreateUserConnection', 'upsertNotificationConnectionDto', upsertNotificationConnectionDto)
            const localVarPath = `/users/notifications/connection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertNotificationConnectionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {NotificationConnectionExistsDto} notificationConnectionExistsDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersNotificationsControllerFindConnection: async (notificationConnectionExistsDto: NotificationConnectionExistsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationConnectionExistsDto' is not null or undefined
            assertParamExists('usersNotificationsControllerFindConnection', 'notificationConnectionExistsDto', notificationConnectionExistsDto)
            const localVarPath = `/users/notifications/connection/find`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationConnectionExistsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersNotificationsApi - functional programming interface
 * @export
 */
export const UsersNotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersNotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserNotificationConnections(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationUserConnectionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserNotificationConnections(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserNotifications(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserNotificationsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserNotifications(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendEmailConfirmationLink(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendEmailConfirmationLink(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {SendUserNotificationDto} sendUserNotificationDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendNotification(sendUserNotificationDto: SendUserNotificationDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendNotification(sendUserNotificationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {Array<UpdateNotificationUserSettingsDto>} updateNotificationUserSettingsDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserNotifications(updateNotificationUserSettingsDto: Array<UpdateNotificationUserSettingsDto>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UpdateNotificationUserSettingsDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserNotifications(updateNotificationUserSettingsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {UpsertNotificationConnectionDto} upsertNotificationConnectionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersNotificationsControllerCreateUserConnection(upsertNotificationConnectionDto: UpsertNotificationConnectionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationConnectionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersNotificationsControllerCreateUserConnection(upsertNotificationConnectionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {NotificationConnectionExistsDto} notificationConnectionExistsDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersNotificationsControllerFindConnection(notificationConnectionExistsDto: NotificationConnectionExistsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationConnectionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersNotificationsControllerFindConnection(notificationConnectionExistsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersNotificationsApi - factory interface
 * @export
 */
export const UsersNotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersNotificationsApiFp(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotificationConnections(options?: any): AxiosPromise<NotificationUserConnectionsDto> {
            return localVarFp.getUserNotificationConnections(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotifications(options?: any): AxiosPromise<UserNotificationsDto> {
            return localVarFp.getUserNotifications(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailConfirmationLink(options?: any): AxiosPromise<void> {
            return localVarFp.sendEmailConfirmationLink(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {SendUserNotificationDto} sendUserNotificationDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendNotification(sendUserNotificationDto: SendUserNotificationDto, options?: any): AxiosPromise<void> {
            return localVarFp.sendNotification(sendUserNotificationDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {Array<UpdateNotificationUserSettingsDto>} updateNotificationUserSettingsDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNotifications(updateNotificationUserSettingsDto: Array<UpdateNotificationUserSettingsDto>, options?: any): AxiosPromise<Array<UpdateNotificationUserSettingsDto>> {
            return localVarFp.updateUserNotifications(updateNotificationUserSettingsDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {UpsertNotificationConnectionDto} upsertNotificationConnectionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersNotificationsControllerCreateUserConnection(upsertNotificationConnectionDto: UpsertNotificationConnectionDto, options?: any): AxiosPromise<NotificationConnectionDto> {
            return localVarFp.usersNotificationsControllerCreateUserConnection(upsertNotificationConnectionDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {NotificationConnectionExistsDto} notificationConnectionExistsDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersNotificationsControllerFindConnection(notificationConnectionExistsDto: NotificationConnectionExistsDto, options?: any): AxiosPromise<NotificationConnectionDto> {
            return localVarFp.usersNotificationsControllerFindConnection(notificationConnectionExistsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersNotificationsApi - object-oriented interface
 * @export
 * @class UsersNotificationsApi
 * @extends {BaseAPI}
 */
export class UsersNotificationsApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersNotificationsApi
     */
    public getUserNotificationConnections(options?: AxiosRequestConfig) {
        return UsersNotificationsApiFp(this.configuration).getUserNotificationConnections(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersNotificationsApi
     */
    public getUserNotifications(options?: AxiosRequestConfig) {
        return UsersNotificationsApiFp(this.configuration).getUserNotifications(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersNotificationsApi
     */
    public sendEmailConfirmationLink(options?: AxiosRequestConfig) {
        return UsersNotificationsApiFp(this.configuration).sendEmailConfirmationLink(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {SendUserNotificationDto} sendUserNotificationDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersNotificationsApi
     */
    public sendNotification(sendUserNotificationDto: SendUserNotificationDto, options?: AxiosRequestConfig) {
        return UsersNotificationsApiFp(this.configuration).sendNotification(sendUserNotificationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {Array<UpdateNotificationUserSettingsDto>} updateNotificationUserSettingsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersNotificationsApi
     */
    public updateUserNotifications(updateNotificationUserSettingsDto: Array<UpdateNotificationUserSettingsDto>, options?: AxiosRequestConfig) {
        return UsersNotificationsApiFp(this.configuration).updateUserNotifications(updateNotificationUserSettingsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {UpsertNotificationConnectionDto} upsertNotificationConnectionDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersNotificationsApi
     */
    public usersNotificationsControllerCreateUserConnection(upsertNotificationConnectionDto: UpsertNotificationConnectionDto, options?: AxiosRequestConfig) {
        return UsersNotificationsApiFp(this.configuration).usersNotificationsControllerCreateUserConnection(upsertNotificationConnectionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {NotificationConnectionExistsDto} notificationConnectionExistsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersNotificationsApi
     */
    public usersNotificationsControllerFindConnection(notificationConnectionExistsDto: NotificationConnectionExistsDto, options?: AxiosRequestConfig) {
        return UsersNotificationsApiFp(this.configuration).usersNotificationsControllerFindConnection(notificationConnectionExistsDto, options).then((request) => request(this.axios, this.basePath));
    }
}


