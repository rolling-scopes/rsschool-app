/* tslint:disable */
/* eslint-disable */
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ActivityDto
 */
export interface ActivityDto {
    /**
     * 
     * @type {number}
     * @memberof ActivityDto
     */
    'lastActivityTime': number;
    /**
     * 
     * @type {boolean}
     * @memberof ActivityDto
     */
    'isActive': boolean;
}
/**
 * 
 * @export
 * @interface AlertDto
 */
export interface AlertDto {
    /**
     * 
     * @type {number}
     * @memberof AlertDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof AlertDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof AlertDto
     */
    'text': string;
    /**
     * 
     * @type {boolean}
     * @memberof AlertDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {number}
     * @memberof AlertDto
     */
    'courseId': number | null;
    /**
     * 
     * @type {string}
     * @memberof AlertDto
     */
    'updatedDate': string;
    /**
     * 
     * @type {string}
     * @memberof AlertDto
     */
    'createdDate': string;
}
/**
 * 
 * @export
 * @interface ApproveMentorDto
 */
export interface ApproveMentorDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof ApproveMentorDto
     */
    'preselectedCourses': Array<string>;
}
/**
 * 
 * @export
 * @interface AuthConnectionDto
 */
export interface AuthConnectionDto {
    /**
     * 
     * @type {string}
     * @memberof AuthConnectionDto
     */
    'channelId': string;
    /**
     * 
     * @type {string}
     * @memberof AuthConnectionDto
     */
    'externalId': string;
}
/**
 * 
 * @export
 * @interface BadgeDto
 */
export interface BadgeDto {
    /**
     * 
     * @type {string}
     * @memberof BadgeDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BadgeDto
     */
    'id': BadgeDtoIdEnum;
}

export const BadgeDtoIdEnum = {
    Congratulations: 'Congratulations',
    ExpertHelp: 'Expert_help',
    GreatSpeaker: 'Great_speaker',
    GoodJob: 'Good_job',
    HelpingHand: 'Helping_hand',
    Hero: 'Hero',
    ThankYou: 'Thank_you',
    OutstandingWork: 'Outstanding_work',
    TopPerformer: 'Top_performer',
    JobOffer: 'Job_Offer',
    RsActivist: 'RS_activist'
} as const;

export type BadgeDtoIdEnum = typeof BadgeDtoIdEnum[keyof typeof BadgeDtoIdEnum];

/**
 * 
 * @export
 * @interface ChannelSettings
 */
export interface ChannelSettings {
    /**
     * 
     * @type {string}
     * @memberof ChannelSettings
     */
    'channelId': string;
    /**
     * 
     * @type {object}
     * @memberof ChannelSettings
     */
    'template': object;
}
/**
 * 
 * @export
 * @interface CheckTasksDeadlineDto
 */
export interface CheckTasksDeadlineDto {
    /**
     * 
     * @type {number}
     * @memberof CheckTasksDeadlineDto
     */
    'deadlineInHours': number;
}
/**
 * 
 * @export
 * @interface ConfigurableProfilePermissions
 */
export interface ConfigurableProfilePermissions {
    /**
     * 
     * @type {PublicVisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isProfileVisible'?: PublicVisibilitySettings;
    /**
     * 
     * @type {VisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isAboutVisible'?: VisibilitySettings;
    /**
     * 
     * @type {VisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isEducationVisible'?: VisibilitySettings;
    /**
     * 
     * @type {PartialStudentVisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isEnglishVisible'?: PartialStudentVisibilitySettings;
    /**
     * 
     * @type {ContactsVisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isEmailVisible'?: ContactsVisibilitySettings;
    /**
     * 
     * @type {ContactsVisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isTelegramVisible'?: ContactsVisibilitySettings;
    /**
     * 
     * @type {ContactsVisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isSkypeVisible'?: ContactsVisibilitySettings;
    /**
     * 
     * @type {ContactsVisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isPhoneVisible'?: ContactsVisibilitySettings;
    /**
     * 
     * @type {ContactsVisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isContactsNotesVisible'?: ContactsVisibilitySettings;
    /**
     * 
     * @type {VisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isLinkedInVisible'?: VisibilitySettings;
    /**
     * 
     * @type {VisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isPublicFeedbackVisible'?: VisibilitySettings;
    /**
     * 
     * @type {VisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isMentorStatsVisible'?: VisibilitySettings;
    /**
     * 
     * @type {PartialStudentVisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isStudentStatsVisible'?: PartialStudentVisibilitySettings;
}
/**
 * 
 * @export
 * @interface ConsentDto
 */
export interface ConsentDto {
    /**
     * 
     * @type {boolean}
     * @memberof ConsentDto
     */
    'consent': boolean;
}
/**
 * 
 * @export
 * @interface Contacts
 */
export interface Contacts {
    /**
     * 
     * @type {string}
     * @memberof Contacts
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contacts
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contacts
     */
    'epamEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contacts
     */
    'skype'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contacts
     */
    'telegram'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contacts
     */
    'notes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contacts
     */
    'linkedIn'?: string | null;
}
/**
 * 
 * @export
 * @interface ContactsVisibilitySettings
 */
export interface ContactsVisibilitySettings {
    /**
     * 
     * @type {boolean}
     * @memberof ContactsVisibilitySettings
     */
    'all': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ContactsVisibilitySettings
     */
    'student': boolean;
}
/**
 * 
 * @export
 * @interface CourseDto
 */
export interface CourseDto {
    /**
     * 
     * @type {number}
     * @memberof CourseDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'createdDate': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'updatedDate': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'alias': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'descriptionUrl': string;
    /**
     * 
     * @type {number}
     * @memberof CourseDto
     */
    'year': number;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'endDate': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'registrationEndDate': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'primarySkillId': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'primarySkillName': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'locationName': string;
    /**
     * 
     * @type {number}
     * @memberof CourseDto
     */
    'discordServerId': number;
    /**
     * 
     * @type {boolean}
     * @memberof CourseDto
     */
    'completed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CourseDto
     */
    'planned': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CourseDto
     */
    'inviteOnly': boolean;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'certificateIssuer': string;
    /**
     * 
     * @type {boolean}
     * @memberof CourseDto
     */
    'usePrivateRepositories': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CourseDto
     */
    'personalMentoring': boolean;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'logo': string;
}
/**
 * 
 * @export
 * @interface CourseStatsDto
 */
export interface CourseStatsDto {
    /**
     * 
     * @type {number}
     * @memberof CourseStatsDto
     */
    'studentsActiveCount': number;
    /**
     * 
     * @type {number}
     * @memberof CourseStatsDto
     */
    'studentsTotalCount': number;
}
/**
 * 
 * @export
 * @interface CourseTaskDetailedDto
 */
export interface CourseTaskDetailedDto {
    /**
     * 
     * @type {number}
     * @memberof CourseTaskDetailedDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'type': CourseTaskDetailedDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'checker': string;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'studentStartDate': string;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'studentEndDate': string;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'descriptionUrl': string;
    /**
     * 
     * @type {number}
     * @memberof CourseTaskDetailedDto
     */
    'taskOwnerId': number;
    /**
     * 
     * @type {number}
     * @memberof CourseTaskDetailedDto
     */
    'maxScore': number;
    /**
     * 
     * @type {number}
     * @memberof CourseTaskDetailedDto
     */
    'scoreWeight': number;
    /**
     * 
     * @type {object}
     * @memberof CourseTaskDetailedDto
     */
    'publicAttributes': object;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'githubRepoName': string;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'sourceGithubRepoUrl': string;
}

export const CourseTaskDetailedDtoTypeEnum = {
    Jstask: 'jstask',
    Kotlintask: 'kotlintask',
    Objctask: 'objctask',
    Htmltask: 'htmltask',
    Ipynb: 'ipynb',
    Selfeducation: 'selfeducation',
    Codewars: 'codewars',
    Test: 'test',
    Codejam: 'codejam',
    Interview: 'interview',
    StageInterview: 'stage-interview',
    Cvhtml: 'cv:html',
    Cvmarkdown: 'cv:markdown'
} as const;

export type CourseTaskDetailedDtoTypeEnum = typeof CourseTaskDetailedDtoTypeEnum[keyof typeof CourseTaskDetailedDtoTypeEnum];

/**
 * 
 * @export
 * @interface CourseTaskDto
 */
export interface CourseTaskDto {
    /**
     * 
     * @type {number}
     * @memberof CourseTaskDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDto
     */
    'type': CourseTaskDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDto
     */
    'checker': string;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDto
     */
    'studentStartDate': string;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDto
     */
    'studentEndDate': string;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDto
     */
    'descriptionUrl': string;
    /**
     * 
     * @type {number}
     * @memberof CourseTaskDto
     */
    'taskOwnerId': number;
    /**
     * 
     * @type {number}
     * @memberof CourseTaskDto
     */
    'maxScore': number;
    /**
     * 
     * @type {number}
     * @memberof CourseTaskDto
     */
    'scoreWeight': number;
}

export const CourseTaskDtoTypeEnum = {
    Jstask: 'jstask',
    Kotlintask: 'kotlintask',
    Objctask: 'objctask',
    Htmltask: 'htmltask',
    Ipynb: 'ipynb',
    Selfeducation: 'selfeducation',
    Codewars: 'codewars',
    Test: 'test',
    Codejam: 'codejam',
    Interview: 'interview',
    StageInterview: 'stage-interview',
    Cvhtml: 'cv:html',
    Cvmarkdown: 'cv:markdown'
} as const;

export type CourseTaskDtoTypeEnum = typeof CourseTaskDtoTypeEnum[keyof typeof CourseTaskDtoTypeEnum];

/**
 * 
 * @export
 * @interface CreateActivityDto
 */
export interface CreateActivityDto {
    /**
     * 
     * @type {boolean}
     * @memberof CreateActivityDto
     */
    'isActive': boolean;
}
/**
 * 
 * @export
 * @interface CreateActivityWebhookDto
 */
export interface CreateActivityWebhookDto {
    /**
     * 
     * @type {SenderDto}
     * @memberof CreateActivityWebhookDto
     */
    'sender': SenderDto;
}
/**
 * 
 * @export
 * @interface CreateAlertDto
 */
export interface CreateAlertDto {
    /**
     * 
     * @type {string}
     * @memberof CreateAlertDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAlertDto
     */
    'text': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAlertDto
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateAlertDto
     */
    'courseId'?: number;
}
/**
 * 
 * @export
 * @interface CreateDisciplineDto
 */
export interface CreateDisciplineDto {
    /**
     * 
     * @type {string}
     * @memberof CreateDisciplineDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateDiscordServerDto
 */
export interface CreateDiscordServerDto {
    /**
     * 
     * @type {string}
     * @memberof CreateDiscordServerDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateDiscordServerDto
     */
    'gratitudeUrl': string;
    /**
     * 
     * @type {string}
     * @memberof CreateDiscordServerDto
     */
    'mentorsChatUrl': string;
}
/**
 * 
 * @export
 * @interface CreateGratitudeDto
 */
export interface CreateGratitudeDto {
    /**
     * 
     * @type {number}
     * @memberof CreateGratitudeDto
     */
    'userId': number;
    /**
     * 
     * @type {number}
     * @memberof CreateGratitudeDto
     */
    'courseId': number;
    /**
     * 
     * @type {string}
     * @memberof CreateGratitudeDto
     */
    'comment': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGratitudeDto
     */
    'badgeId': string;
}
/**
 * 
 * @export
 * @interface CreateStudentFeedbackDto
 */
export interface CreateStudentFeedbackDto {
    /**
     * 
     * @type {StudentFeedbackContentDto}
     * @memberof CreateStudentFeedbackDto
     */
    'content': StudentFeedbackContentDto;
    /**
     * 
     * @type {string}
     * @memberof CreateStudentFeedbackDto
     */
    'recommendation': CreateStudentFeedbackDtoRecommendationEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateStudentFeedbackDto
     */
    'englishLevel': CreateStudentFeedbackDtoEnglishLevelEnum;
}

export const CreateStudentFeedbackDtoRecommendationEnum = {
    Hire: 'hire',
    NotHire: 'not-hire'
} as const;

export type CreateStudentFeedbackDtoRecommendationEnum = typeof CreateStudentFeedbackDtoRecommendationEnum[keyof typeof CreateStudentFeedbackDtoRecommendationEnum];
export const CreateStudentFeedbackDtoEnglishLevelEnum = {
    Unknown: 'unknown',
    A0: 'a0',
    A1: 'a1',
    A2: 'a2',
    B1: 'b1',
    B2: 'b2',
    C1: 'c1',
    C2: 'c2'
} as const;

export type CreateStudentFeedbackDtoEnglishLevelEnum = typeof CreateStudentFeedbackDtoEnglishLevelEnum[keyof typeof CreateStudentFeedbackDtoEnglishLevelEnum];

/**
 * 
 * @export
 * @interface CreateUserGroupDto
 */
export interface CreateUserGroupDto {
    /**
     * 
     * @type {string}
     * @memberof CreateUserGroupDto
     */
    'name': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateUserGroupDto
     */
    'users': Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateUserGroupDto
     */
    'roles': Array<string>;
}
/**
 * 
 * @export
 * @interface DisciplineDto
 */
export interface DisciplineDto {
    /**
     * 
     * @type {string}
     * @memberof DisciplineDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof DisciplineDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DisciplineDto
     */
    'createdDate': string;
    /**
     * 
     * @type {string}
     * @memberof DisciplineDto
     */
    'updatedDate': string;
}
/**
 * 
 * @export
 * @interface Discord
 */
export interface Discord {
    /**
     * 
     * @type {number}
     * @memberof Discord
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Discord
     */
    'username': string;
    /**
     * 
     * @type {number}
     * @memberof Discord
     */
    'discriminator': number;
}
/**
 * 
 * @export
 * @interface DiscordServerDto
 */
export interface DiscordServerDto {
    /**
     * 
     * @type {number}
     * @memberof DiscordServerDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof DiscordServerDto
     */
    'createdDate': number;
    /**
     * 
     * @type {number}
     * @memberof DiscordServerDto
     */
    'updatedDate': number;
    /**
     * 
     * @type {string}
     * @memberof DiscordServerDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DiscordServerDto
     */
    'gratitudeUrl': string;
    /**
     * 
     * @type {string}
     * @memberof DiscordServerDto
     */
    'mentorsChatUrl': string | null;
}
/**
 * 
 * @export
 * @interface Education
 */
export interface Education {
    /**
     * 
     * @type {string}
     * @memberof Education
     */
    'university': string;
    /**
     * 
     * @type {string}
     * @memberof Education
     */
    'faculty': string;
    /**
     * 
     * @type {number}
     * @memberof Education
     */
    'graduationYear': number;
}
/**
 * 
 * @export
 * @interface FeedbackCourseDto
 */
export interface FeedbackCourseDto {
    /**
     * 
     * @type {string}
     * @memberof FeedbackCourseDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof FeedbackCourseDto
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface FeedbackDto
 */
export interface FeedbackDto {
    /**
     * 
     * @type {string}
     * @memberof FeedbackDto
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof FeedbackDto
     */
    'recommendation': string;
    /**
     * 
     * @type {string}
     * @memberof FeedbackDto
     */
    'englishLevel': string;
    /**
     * 
     * @type {string}
     * @memberof FeedbackDto
     */
    'recommendationComment': string;
    /**
     * 
     * @type {string}
     * @memberof FeedbackDto
     */
    'suggestions': string;
    /**
     * 
     * @type {Array<FeedbackSoftSkill>}
     * @memberof FeedbackDto
     */
    'softSkills': Array<FeedbackSoftSkill>;
    /**
     * 
     * @type {ResumeCourseMentor}
     * @memberof FeedbackDto
     */
    'mentor': ResumeCourseMentor;
    /**
     * 
     * @type {FeedbackCourseDto}
     * @memberof FeedbackDto
     */
    'course': FeedbackCourseDto;
}
/**
 * 
 * @export
 * @interface FeedbackSoftSkill
 */
export interface FeedbackSoftSkill {
    /**
     * 
     * @type {string}
     * @memberof FeedbackSoftSkill
     */
    'value': FeedbackSoftSkillValueEnum;
    /**
     * 
     * @type {string}
     * @memberof FeedbackSoftSkill
     */
    'id': FeedbackSoftSkillIdEnum;
}

export const FeedbackSoftSkillValueEnum = {
    None: 'None',
    Poor: 'Poor',
    Fair: 'Fair',
    Good: 'Good',
    Great: 'Great',
    Excellent: 'Excellent'
} as const;

export type FeedbackSoftSkillValueEnum = typeof FeedbackSoftSkillValueEnum[keyof typeof FeedbackSoftSkillValueEnum];
export const FeedbackSoftSkillIdEnum = {
    Responsible: 'skill.soft.responsible',
    TeamPlayer: 'skill.soft.team-player',
    Communicable: 'skill.soft.communicable'
} as const;

export type FeedbackSoftSkillIdEnum = typeof FeedbackSoftSkillIdEnum[keyof typeof FeedbackSoftSkillIdEnum];

/**
 * 
 * @export
 * @interface GeneralInfo
 */
export interface GeneralInfo {
    /**
     * 
     * @type {string}
     * @memberof GeneralInfo
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GeneralInfo
     */
    'githubId': string;
    /**
     * 
     * @type {string}
     * @memberof GeneralInfo
     */
    'aboutMyself'?: string | null;
    /**
     * 
     * @type {Location}
     * @memberof GeneralInfo
     */
    'location': Location;
    /**
     * 
     * @type {Array<Education>}
     * @memberof GeneralInfo
     */
    'educationHistory'?: Array<Education> | null;
    /**
     * 
     * @type {string}
     * @memberof GeneralInfo
     */
    'englishLevel'?: string | null;
}
/**
 * 
 * @export
 * @interface GratitudeDto
 */
export interface GratitudeDto {
    /**
     * 
     * @type {PersonDto}
     * @memberof GratitudeDto
     */
    'user': PersonDto;
    /**
     * 
     * @type {number}
     * @memberof GratitudeDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GratitudeDto
     */
    'badgeId': GratitudeDtoBadgeIdEnum;
    /**
     * 
     * @type {string}
     * @memberof GratitudeDto
     */
    'comment': string;
    /**
     * 
     * @type {number}
     * @memberof GratitudeDto
     */
    'courseId': number;
    /**
     * 
     * @type {string}
     * @memberof GratitudeDto
     */
    'date': string;
}

export const GratitudeDtoBadgeIdEnum = {
    Congratulations: 'Congratulations',
    ExpertHelp: 'Expert_help',
    GreatSpeaker: 'Great_speaker',
    GoodJob: 'Good_job',
    HelpingHand: 'Helping_hand',
    Hero: 'Hero',
    ThankYou: 'Thank_you',
    OutstandingWork: 'Outstanding_work',
    TopPerformer: 'Top_performer',
    JobOffer: 'Job_Offer',
    RsActivist: 'RS_activist'
} as const;

export type GratitudeDtoBadgeIdEnum = typeof GratitudeDtoBadgeIdEnum[keyof typeof GratitudeDtoBadgeIdEnum];

/**
 * 
 * @export
 * @interface InterviewDto
 */
export interface InterviewDto {
    /**
     * 
     * @type {number}
     * @memberof InterviewDto
     */
    'id': number;
    /**
     * 
     * @type {object}
     * @memberof InterviewDto
     */
    'attributes': object;
}
/**
 * 
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'cityName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'countryName'?: string | null;
}
/**
 * 
 * @export
 * @interface MentorStudentDto
 */
export interface MentorStudentDto {
    /**
     * 
     * @type {string}
     * @memberof MentorStudentDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof MentorStudentDto
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof MentorStudentDto
     */
    'active': boolean;
    /**
     * 
     * @type {string}
     * @memberof MentorStudentDto
     */
    'cityName': string | null;
    /**
     * 
     * @type {string}
     * @memberof MentorStudentDto
     */
    'countryName': string | null;
    /**
     * 
     * @type {string}
     * @memberof MentorStudentDto
     */
    'githubId': string;
    /**
     * 
     * @type {number}
     * @memberof MentorStudentDto
     */
    'totalScore': number;
    /**
     * 
     * @type {number}
     * @memberof MentorStudentDto
     */
    'rank': number;
    /**
     * 
     * @type {Array<StudentFeedback>}
     * @memberof MentorStudentDto
     */
    'feedbacks': Array<StudentFeedback>;
}
/**
 * 
 * @export
 * @interface NotificationConnectionDto
 */
export interface NotificationConnectionDto {
    /**
     * 
     * @type {string}
     * @memberof NotificationConnectionDto
     */
    'channelId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationConnectionDto
     */
    'externalId': string;
    /**
     * 
     * @type {number}
     * @memberof NotificationConnectionDto
     */
    'userId': number;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationConnectionDto
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface NotificationConnectionExistsDto
 */
export interface NotificationConnectionExistsDto {
    /**
     * 
     * @type {string}
     * @memberof NotificationConnectionExistsDto
     */
    'channelId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationConnectionExistsDto
     */
    'externalId': string;
}
/**
 * 
 * @export
 * @interface NotificationDto
 */
export interface NotificationDto {
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {NotificationType}
     * @memberof NotificationDto
     */
    'type': NotificationType;
    /**
     * 
     * @type {Array<ChannelSettings>}
     * @memberof NotificationDto
     */
    'channels': Array<ChannelSettings>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationType = {
    Event: 'event',
    Message: 'message'
} as const;

export type NotificationType = typeof NotificationType[keyof typeof NotificationType];


/**
 * 
 * @export
 * @interface NotificationUserConnectionsDto
 */
export interface NotificationUserConnectionsDto {
    /**
     * 
     * @type {object}
     * @memberof NotificationUserConnectionsDto
     */
    'connections': object;
}
/**
 * 
 * @export
 * @interface NotificationUserSettingsDto
 */
export interface NotificationUserSettingsDto {
    /**
     * 
     * @type {string}
     * @memberof NotificationUserSettingsDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationUserSettingsDto
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationUserSettingsDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {object}
     * @memberof NotificationUserSettingsDto
     */
    'settings': object;
}
/**
 * 
 * @export
 * @interface PartialStudentVisibilitySettings
 */
export interface PartialStudentVisibilitySettings {
    /**
     * 
     * @type {boolean}
     * @memberof PartialStudentVisibilitySettings
     */
    'all': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PartialStudentVisibilitySettings
     */
    'student': boolean;
}
/**
 * 
 * @export
 * @interface PersonDto
 */
export interface PersonDto {
    /**
     * 
     * @type {string}
     * @memberof PersonDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PersonDto
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface ProfileCourseDto
 */
export interface ProfileCourseDto {
    /**
     * 
     * @type {number}
     * @memberof ProfileCourseDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'createdDate': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'updatedDate': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'alias': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'descriptionUrl': string;
    /**
     * 
     * @type {number}
     * @memberof ProfileCourseDto
     */
    'year': number;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'endDate': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'registrationEndDate': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'primarySkillId': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'primarySkillName': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'locationName': string;
    /**
     * 
     * @type {number}
     * @memberof ProfileCourseDto
     */
    'discordServerId': number;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileCourseDto
     */
    'completed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileCourseDto
     */
    'planned': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileCourseDto
     */
    'inviteOnly': boolean;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'certificateIssuer': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileCourseDto
     */
    'usePrivateRepositories': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileCourseDto
     */
    'personalMentoring': boolean;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'logo': string;
}
/**
 * 
 * @export
 * @interface ProfileInfoDto
 */
export interface ProfileInfoDto {
    /**
     * 
     * @type {ConfigurableProfilePermissions}
     * @memberof ProfileInfoDto
     */
    'permissionsSettings': ConfigurableProfilePermissions;
    /**
     * 
     * @type {GeneralInfo}
     * @memberof ProfileInfoDto
     */
    'generalInfo': GeneralInfo;
    /**
     * 
     * @type {Contacts}
     * @memberof ProfileInfoDto
     */
    'contacts': Contacts;
    /**
     * 
     * @type {Discord}
     * @memberof ProfileInfoDto
     */
    'discord'?: Discord | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileInfoDto
     */
    'isPermissionsSettingsChanged': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileInfoDto
     */
    'isProfileSettingsChanged': boolean;
}
/**
 * 
 * @export
 * @interface PublicVisibilitySettings
 */
export interface PublicVisibilitySettings {
    /**
     * 
     * @type {boolean}
     * @memberof PublicVisibilitySettings
     */
    'all': boolean;
}
/**
 * 
 * @export
 * @interface ResumeCourseDto
 */
export interface ResumeCourseDto {
    /**
     * 
     * @type {number}
     * @memberof ResumeCourseDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ResumeCourseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeCourseDto
     */
    'fullName': string;
    /**
     * 
     * @type {number}
     * @memberof ResumeCourseDto
     */
    'rank': number;
    /**
     * 
     * @type {number}
     * @memberof ResumeCourseDto
     */
    'totalScore': number;
    /**
     * 
     * @type {string}
     * @memberof ResumeCourseDto
     */
    'certificateId': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ResumeCourseDto
     */
    'completed': boolean;
    /**
     * 
     * @type {ResumeCourseMentor}
     * @memberof ResumeCourseDto
     */
    'mentor': ResumeCourseMentor | null;
    /**
     * 
     * @type {string}
     * @memberof ResumeCourseDto
     */
    'locationName': string;
}
/**
 * 
 * @export
 * @interface ResumeCourseMentor
 */
export interface ResumeCourseMentor {
    /**
     * 
     * @type {string}
     * @memberof ResumeCourseMentor
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ResumeCourseMentor
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ResumeCourseMentor
     */
    'githubId': string;
}
/**
 * 
 * @export
 * @interface ResumeDto
 */
export interface ResumeDto {
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'avatarLink': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ResumeDto
     */
    'visibleCourses': Array<number>;
    /**
     * 
     * @type {Array<ResumeCourseDto>}
     * @memberof ResumeDto
     */
    'courses': Array<ResumeCourseDto>;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'desiredPosition': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'englishLevel': ResumeDtoEnglishLevelEnum;
    /**
     * 
     * @type {number}
     * @memberof ResumeDto
     */
    'expires': number;
    /**
     * 
     * @type {Array<GratitudeDto>}
     * @memberof ResumeDto
     */
    'gratitudes': Array<GratitudeDto>;
    /**
     * 
     * @type {Array<FeedbackDto>}
     * @memberof ResumeDto
     */
    'feedbacks': Array<FeedbackDto>;
    /**
     * 
     * @type {boolean}
     * @memberof ResumeDto
     */
    'fullTime': boolean;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'githubUsername': string;
    /**
     * 
     * @type {number}
     * @memberof ResumeDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'linkedin': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'locations': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'militaryService': ResumeDtoMilitaryServiceEnum;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'notes': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'selfIntroLink': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'skype': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'startFrom': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'telegram': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'website': string;
}

export const ResumeDtoEnglishLevelEnum = {
    Unknown: 'unknown',
    A0: 'a0',
    A1: 'a1',
    A2: 'a2',
    B1: 'b1',
    B2: 'b2',
    C1: 'c1',
    C2: 'c2'
} as const;

export type ResumeDtoEnglishLevelEnum = typeof ResumeDtoEnglishLevelEnum[keyof typeof ResumeDtoEnglishLevelEnum];
export const ResumeDtoMilitaryServiceEnum = {
    Served: 'served',
    Liable: 'liable',
    NotLiable: 'notLiable'
} as const;

export type ResumeDtoMilitaryServiceEnum = typeof ResumeDtoMilitaryServiceEnum[keyof typeof ResumeDtoMilitaryServiceEnum];

/**
 * 
 * @export
 * @interface SaveCertificateDto
 */
export interface SaveCertificateDto {
    /**
     * 
     * @type {string}
     * @memberof SaveCertificateDto
     */
    'publicId': string;
    /**
     * 
     * @type {number}
     * @memberof SaveCertificateDto
     */
    'studentId': number;
    /**
     * 
     * @type {string}
     * @memberof SaveCertificateDto
     */
    's3Bucket': string;
    /**
     * 
     * @type {string}
     * @memberof SaveCertificateDto
     */
    's3Key': string;
    /**
     * 
     * @type {string}
     * @memberof SaveCertificateDto
     */
    'issueDate': string;
}
/**
 * 
 * @export
 * @interface SendUserNotificationDto
 */
export interface SendUserNotificationDto {
    /**
     * 
     * @type {string}
     * @memberof SendUserNotificationDto
     */
    'notificationId': string;
    /**
     * 
     * @type {number}
     * @memberof SendUserNotificationDto
     */
    'userId': number;
    /**
     * 
     * @type {object}
     * @memberof SendUserNotificationDto
     */
    'data': object;
    /**
     * 
     * @type {number}
     * @memberof SendUserNotificationDto
     */
    'expireDate': number;
}
/**
 * 
 * @export
 * @interface SenderDto
 */
export interface SenderDto {
    /**
     * 
     * @type {SenderLoginDto}
     * @memberof SenderDto
     */
    'login': SenderLoginDto;
}
/**
 * 
 * @export
 * @interface SenderLoginDto
 */
export interface SenderLoginDto {
    /**
     * 
     * @type {string}
     * @memberof SenderLoginDto
     */
    'githubId': string;
}
/**
 * 
 * @export
 * @interface SoftSkillEntry
 */
export interface SoftSkillEntry {
    /**
     * 
     * @type {string}
     * @memberof SoftSkillEntry
     */
    'id': SoftSkillEntryIdEnum;
    /**
     * 
     * @type {string}
     * @memberof SoftSkillEntry
     */
    'value': SoftSkillEntryValueEnum;
}

export const SoftSkillEntryIdEnum = {
    Responsible: 'skill.soft.responsible',
    TeamPlayer: 'skill.soft.team-player',
    Communicable: 'skill.soft.communicable'
} as const;

export type SoftSkillEntryIdEnum = typeof SoftSkillEntryIdEnum[keyof typeof SoftSkillEntryIdEnum];
export const SoftSkillEntryValueEnum = {
    None: 'None',
    Poor: 'Poor',
    Fair: 'Fair',
    Good: 'Good',
    Great: 'Great',
    Excellent: 'Excellent'
} as const;

export type SoftSkillEntryValueEnum = typeof SoftSkillEntryValueEnum[keyof typeof SoftSkillEntryValueEnum];

/**
 * 
 * @export
 * @interface StudentDto
 */
export interface StudentDto {
    /**
     * 
     * @type {string}
     * @memberof StudentDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof StudentDto
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof StudentDto
     */
    'active': boolean;
    /**
     * 
     * @type {string}
     * @memberof StudentDto
     */
    'cityName': string | null;
    /**
     * 
     * @type {string}
     * @memberof StudentDto
     */
    'countryName': string | null;
    /**
     * 
     * @type {string}
     * @memberof StudentDto
     */
    'githubId': string;
    /**
     * 
     * @type {number}
     * @memberof StudentDto
     */
    'totalScore': number;
    /**
     * 
     * @type {number}
     * @memberof StudentDto
     */
    'rank': number;
}
/**
 * 
 * @export
 * @interface StudentFeedback
 */
export interface StudentFeedback {
    /**
     * 
     * @type {number}
     * @memberof StudentFeedback
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface StudentFeedbackContentDto
 */
export interface StudentFeedbackContentDto {
    /**
     * 
     * @type {string}
     * @memberof StudentFeedbackContentDto
     */
    'suggestions': string;
    /**
     * 
     * @type {string}
     * @memberof StudentFeedbackContentDto
     */
    'recommendationComment': string;
    /**
     * 
     * @type {Array<SoftSkillEntry>}
     * @memberof StudentFeedbackContentDto
     */
    'softSkills': Array<SoftSkillEntry>;
}
/**
 * 
 * @export
 * @interface StudentFeedbackDto
 */
export interface StudentFeedbackDto {
    /**
     * 
     * @type {number}
     * @memberof StudentFeedbackDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof StudentFeedbackDto
     */
    'createdDate': string;
    /**
     * 
     * @type {string}
     * @memberof StudentFeedbackDto
     */
    'updatedDate': string;
    /**
     * 
     * @type {StudentFeedbackContentDto}
     * @memberof StudentFeedbackDto
     */
    'content': StudentFeedbackContentDto;
    /**
     * 
     * @type {string}
     * @memberof StudentFeedbackDto
     */
    'recommendation': StudentFeedbackDtoRecommendationEnum;
    /**
     * 
     * @type {PersonDto}
     * @memberof StudentFeedbackDto
     */
    'author': PersonDto;
    /**
     * 
     * @type {PersonDto}
     * @memberof StudentFeedbackDto
     */
    'mentor': PersonDto | null;
    /**
     * 
     * @type {string}
     * @memberof StudentFeedbackDto
     */
    'englishLevel': StudentFeedbackDtoEnglishLevelEnum;
}

export const StudentFeedbackDtoRecommendationEnum = {
    Hire: 'hire',
    NotHire: 'not-hire'
} as const;

export type StudentFeedbackDtoRecommendationEnum = typeof StudentFeedbackDtoRecommendationEnum[keyof typeof StudentFeedbackDtoRecommendationEnum];
export const StudentFeedbackDtoEnglishLevelEnum = {
    Unknown: 'unknown',
    A0: 'a0',
    A1: 'a1',
    A2: 'a2',
    B1: 'b1',
    B2: 'b2',
    C1: 'c1',
    C2: 'c2'
} as const;

export type StudentFeedbackDtoEnglishLevelEnum = typeof StudentFeedbackDtoEnglishLevelEnum[keyof typeof StudentFeedbackDtoEnglishLevelEnum];

/**
 * 
 * @export
 * @interface UpdateDisciplineDto
 */
export interface UpdateDisciplineDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateDisciplineDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UpdateDiscordServerDto
 */
export interface UpdateDiscordServerDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateDiscordServerDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDiscordServerDto
     */
    'gratitudeUrl': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDiscordServerDto
     */
    'mentorsChatUrl': string;
}
/**
 * 
 * @export
 * @interface UpdateNotificationDto
 */
export interface UpdateNotificationDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationDto
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateNotificationDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {Array<ChannelSettings>}
     * @memberof UpdateNotificationDto
     */
    'channels': Array<ChannelSettings>;
    /**
     * 
     * @type {NotificationType}
     * @memberof UpdateNotificationDto
     */
    'type': NotificationType;
}
/**
 * 
 * @export
 * @interface UpdateNotificationUserSettingsDto
 */
export interface UpdateNotificationUserSettingsDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationUserSettingsDto
     */
    'notificationId': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateNotificationUserSettingsDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationUserSettingsDto
     */
    'channelId': string;
}
/**
 * 
 * @export
 * @interface UpdateStudentFeedbackDto
 */
export interface UpdateStudentFeedbackDto {
    /**
     * 
     * @type {StudentFeedbackContentDto}
     * @memberof UpdateStudentFeedbackDto
     */
    'content': StudentFeedbackContentDto;
    /**
     * 
     * @type {string}
     * @memberof UpdateStudentFeedbackDto
     */
    'recommendation': UpdateStudentFeedbackDtoRecommendationEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateStudentFeedbackDto
     */
    'englishLevel': UpdateStudentFeedbackDtoEnglishLevelEnum;
}

export const UpdateStudentFeedbackDtoRecommendationEnum = {
    Hire: 'hire',
    NotHire: 'not-hire'
} as const;

export type UpdateStudentFeedbackDtoRecommendationEnum = typeof UpdateStudentFeedbackDtoRecommendationEnum[keyof typeof UpdateStudentFeedbackDtoRecommendationEnum];
export const UpdateStudentFeedbackDtoEnglishLevelEnum = {
    Unknown: 'unknown',
    A0: 'a0',
    A1: 'a1',
    A2: 'a2',
    B1: 'b1',
    B2: 'b2',
    C1: 'c1',
    C2: 'c2'
} as const;

export type UpdateStudentFeedbackDtoEnglishLevelEnum = typeof UpdateStudentFeedbackDtoEnglishLevelEnum[keyof typeof UpdateStudentFeedbackDtoEnglishLevelEnum];

/**
 * 
 * @export
 * @interface UpdateUserDto
 */
export interface UpdateUserDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'firstName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'lastName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'primaryEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'cityName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'countryName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'contactsNotes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'contactsPhone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'contactsEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'contactsEpamEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'contactsSkype'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'contactsTelegram'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'contactsLinkedIn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'notes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'aboutMyself'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateUserGroupDto
 */
export interface UpdateUserGroupDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserGroupDto
     */
    'name': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateUserGroupDto
     */
    'users': Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateUserGroupDto
     */
    'roles': Array<string>;
}
/**
 * 
 * @export
 * @interface UpsertNotificationConnectionDto
 */
export interface UpsertNotificationConnectionDto {
    /**
     * 
     * @type {string}
     * @memberof UpsertNotificationConnectionDto
     */
    'channelId': string;
    /**
     * 
     * @type {string}
     * @memberof UpsertNotificationConnectionDto
     */
    'externalId': string;
    /**
     * 
     * @type {number}
     * @memberof UpsertNotificationConnectionDto
     */
    'userId': number;
    /**
     * 
     * @type {boolean}
     * @memberof UpsertNotificationConnectionDto
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * 
     * @type {number}
     * @memberof UserDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'githubId': string;
}
/**
 * 
 * @export
 * @interface UserGroupDto
 */
export interface UserGroupDto {
    /**
     * 
     * @type {number}
     * @memberof UserGroupDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserGroupDto
     */
    'name': string;
    /**
     * 
     * @type {Array<UserDto>}
     * @memberof UserGroupDto
     */
    'users': Array<UserDto>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserGroupDto
     */
    'roles': Array<string>;
}
/**
 * 
 * @export
 * @interface UserNotificationsDto
 */
export interface UserNotificationsDto {
    /**
     * 
     * @type {Array<NotificationUserSettingsDto>}
     * @memberof UserNotificationsDto
     */
    'notifications': Array<NotificationUserSettingsDto>;
    /**
     * 
     * @type {object}
     * @memberof UserNotificationsDto
     */
    'connections': object;
}
/**
 * 
 * @export
 * @interface VisibilitySettings
 */
export interface VisibilitySettings {
    /**
     * 
     * @type {boolean}
     * @memberof VisibilitySettings
     */
    'all': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VisibilitySettings
     */
    'mentor': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VisibilitySettings
     */
    'student': boolean;
}

/**
 * ActivityApi - axios parameter creator
 * @export
 */
export const ActivityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateActivityDto} createActivityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActivity: async (createActivityDto: CreateActivityDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createActivityDto' is not null or undefined
            assertParamExists('createActivity', 'createActivityDto', createActivityDto)
            const localVarPath = `/activity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createActivityDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateActivityWebhookDto} createActivityWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActivityWebhook: async (createActivityWebhookDto: CreateActivityWebhookDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createActivityWebhookDto' is not null or undefined
            assertParamExists('createActivityWebhook', 'createActivityWebhookDto', createActivityWebhookDto)
            const localVarPath = `/activity/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createActivityWebhookDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/activity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityApi - functional programming interface
 * @export
 */
export const ActivityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateActivityDto} createActivityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createActivity(createActivityDto: CreateActivityDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createActivity(createActivityDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateActivityWebhookDto} createActivityWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createActivityWebhook(createActivityWebhookDto: CreateActivityWebhookDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createActivityWebhook(createActivityWebhookDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivity(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivity(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActivityApi - factory interface
 * @export
 */
export const ActivityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivityApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateActivityDto} createActivityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActivity(createActivityDto: CreateActivityDto, options?: any): AxiosPromise<ActivityDto> {
            return localVarFp.createActivity(createActivityDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateActivityWebhookDto} createActivityWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActivityWebhook(createActivityWebhookDto: CreateActivityWebhookDto, options?: any): AxiosPromise<ActivityDto> {
            return localVarFp.createActivityWebhook(createActivityWebhookDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity(options?: any): AxiosPromise<ActivityDto> {
            return localVarFp.getActivity(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivityApi - object-oriented interface
 * @export
 * @class ActivityApi
 * @extends {BaseAPI}
 */
export class ActivityApi extends BaseAPI {
    /**
     * 
     * @param {CreateActivityDto} createActivityDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public createActivity(createActivityDto: CreateActivityDto, options?: AxiosRequestConfig) {
        return ActivityApiFp(this.configuration).createActivity(createActivityDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateActivityWebhookDto} createActivityWebhookDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public createActivityWebhook(createActivityWebhookDto: CreateActivityWebhookDto, options?: AxiosRequestConfig) {
        return ActivityApiFp(this.configuration).createActivityWebhook(createActivityWebhookDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public getActivity(options?: AxiosRequestConfig) {
        return ActivityApiFp(this.configuration).getActivity(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AlertsApi - axios parameter creator
 * @export
 */
export const AlertsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateAlertDto} createAlertDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlert: async (createAlertDto: CreateAlertDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAlertDto' is not null or undefined
            assertParamExists('createAlert', 'createAlertDto', createAlertDto)
            const localVarPath = `/alerts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAlertDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAlert', 'id', id)
            const localVarPath = `/alerts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} enabled 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlerts: async (enabled: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enabled' is not null or undefined
            assertParamExists('getAlerts', 'enabled', enabled)
            const localVarPath = `/alerts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlert: async (id: number, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAlert', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateAlert', 'body', body)
            const localVarPath = `/alerts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertsApi - functional programming interface
 * @export
 */
export const AlertsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlertsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateAlertDto} createAlertDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlert(createAlertDto: CreateAlertDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlert(createAlertDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlert(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlert(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} enabled 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlerts(enabled: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AlertDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlerts(enabled, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAlert(id: number, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAlert(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AlertsApi - factory interface
 * @export
 */
export const AlertsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlertsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateAlertDto} createAlertDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlert(createAlertDto: CreateAlertDto, options?: any): AxiosPromise<AlertDto> {
            return localVarFp.createAlert(createAlertDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAlert(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} enabled 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlerts(enabled: boolean, options?: any): AxiosPromise<Array<AlertDto>> {
            return localVarFp.getAlerts(enabled, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlert(id: number, body: object, options?: any): AxiosPromise<AlertDto> {
            return localVarFp.updateAlert(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
export class AlertsApi extends BaseAPI {
    /**
     * 
     * @param {CreateAlertDto} createAlertDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public createAlert(createAlertDto: CreateAlertDto, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).createAlert(createAlertDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public deleteAlert(id: number, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).deleteAlert(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} enabled 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public getAlerts(enabled: boolean, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).getAlerts(enabled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public updateAlert(id: number, body: object, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).updateAlert(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AuthConnectionDto} authConnectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerCreateConnectLinkViaGithub: async (authConnectionDto: AuthConnectionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authConnectionDto' is not null or undefined
            assertParamExists('authControllerCreateConnectLinkViaGithub', 'authConnectionDto', authConnectionDto)
            const localVarPath = `/auth/github/connect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authConnectionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubCallback: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/github/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubLogin: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/github/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubLogout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/github/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AuthConnectionDto} authConnectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerCreateConnectLinkViaGithub(authConnectionDto: AuthConnectionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerCreateConnectLinkViaGithub(authConnectionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async githubCallback(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.githubCallback(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async githubLogin(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.githubLogin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async githubLogout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.githubLogout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {AuthConnectionDto} authConnectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerCreateConnectLinkViaGithub(authConnectionDto: AuthConnectionDto, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerCreateConnectLinkViaGithub(authConnectionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubCallback(options?: any): AxiosPromise<void> {
            return localVarFp.githubCallback(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubLogin(options?: any): AxiosPromise<void> {
            return localVarFp.githubLogin(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubLogout(options?: any): AxiosPromise<void> {
            return localVarFp.githubLogout(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {AuthConnectionDto} authConnectionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerCreateConnectLinkViaGithub(authConnectionDto: AuthConnectionDto, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerCreateConnectLinkViaGithub(authConnectionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public githubCallback(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).githubCallback(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public githubLogin(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).githubLogin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public githubLogout(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).githubLogout(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CertificateApi - axios parameter creator
 * @export
 */
export const CertificateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} publicId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCertificate: async (publicId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicId' is not null or undefined
            assertParamExists('getCertificate', 'publicId', publicId)
            const localVarPath = `/certificate/{publicId}`
                .replace(`{${"publicId"}}`, encodeURIComponent(String(publicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SaveCertificateDto} saveCertificateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCertificate: async (saveCertificateDto: SaveCertificateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saveCertificateDto' is not null or undefined
            assertParamExists('saveCertificate', 'saveCertificateDto', saveCertificateDto)
            const localVarPath = `/certificate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveCertificateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CertificateApi - functional programming interface
 * @export
 */
export const CertificateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CertificateApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} publicId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCertificate(publicId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCertificate(publicId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SaveCertificateDto} saveCertificateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveCertificate(saveCertificateDto: SaveCertificateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveCertificate(saveCertificateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CertificateApi - factory interface
 * @export
 */
export const CertificateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CertificateApiFp(configuration)
    return {
        /**
         * 
         * @param {string} publicId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCertificate(publicId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getCertificate(publicId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SaveCertificateDto} saveCertificateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCertificate(saveCertificateDto: SaveCertificateDto, options?: any): AxiosPromise<void> {
            return localVarFp.saveCertificate(saveCertificateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CertificateApi - object-oriented interface
 * @export
 * @class CertificateApi
 * @extends {BaseAPI}
 */
export class CertificateApi extends BaseAPI {
    /**
     * 
     * @param {string} publicId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificateApi
     */
    public getCertificate(publicId: string, options?: AxiosRequestConfig) {
        return CertificateApiFp(this.configuration).getCertificate(publicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SaveCertificateDto} saveCertificateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificateApi
     */
    public saveCertificate(saveCertificateDto: SaveCertificateDto, options?: AxiosRequestConfig) {
        return CertificateApiFp(this.configuration).saveCertificate(saveCertificateDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CourseStatsApi - axios parameter creator
 * @export
 */
export const CourseStatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseStats: async (courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getCourseStats', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/stats`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseStatsApi - functional programming interface
 * @export
 */
export const CourseStatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseStatsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseStats(courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseStatsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseStats(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CourseStatsApi - factory interface
 * @export
 */
export const CourseStatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseStatsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseStats(courseId: number, options?: any): AxiosPromise<CourseStatsDto> {
            return localVarFp.getCourseStats(courseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CourseStatsApi - object-oriented interface
 * @export
 * @class CourseStatsApi
 * @extends {BaseAPI}
 */
export class CourseStatsApi extends BaseAPI {
    /**
     * 
     * @param {number} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseStatsApi
     */
    public getCourseStats(courseId: number, options?: AxiosRequestConfig) {
        return CourseStatsApiFp(this.configuration).getCourseStats(courseId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CoursesApi - axios parameter creator
 * @export
 */
export const CoursesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourse: async (courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getCourse', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/courses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoursesApi - functional programming interface
 * @export
 */
export const CoursesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoursesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourse(courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourse(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourses(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CourseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourses(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CoursesApi - factory interface
 * @export
 */
export const CoursesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoursesApiFp(configuration)
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourse(courseId: number, options?: any): AxiosPromise<CourseDto> {
            return localVarFp.getCourse(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses(options?: any): AxiosPromise<Array<CourseDto>> {
            return localVarFp.getCourses(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoursesApi - object-oriented interface
 * @export
 * @class CoursesApi
 * @extends {BaseAPI}
 */
export class CoursesApi extends BaseAPI {
    /**
     * 
     * @param {number} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public getCourse(courseId: number, options?: AxiosRequestConfig) {
        return CoursesApiFp(this.configuration).getCourse(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public getCourses(options?: AxiosRequestConfig) {
        return CoursesApiFp(this.configuration).getCourses(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CoursesInterviewsApi - axios parameter creator
 * @export
 */
export const CoursesInterviewsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterviews: async (courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getInterviews', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/interviews`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoursesInterviewsApi - functional programming interface
 * @export
 */
export const CoursesInterviewsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoursesInterviewsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInterviews(courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InterviewDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInterviews(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CoursesInterviewsApi - factory interface
 * @export
 */
export const CoursesInterviewsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoursesInterviewsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterviews(courseId: number, options?: any): AxiosPromise<Array<InterviewDto>> {
            return localVarFp.getInterviews(courseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoursesInterviewsApi - object-oriented interface
 * @export
 * @class CoursesInterviewsApi
 * @extends {BaseAPI}
 */
export class CoursesInterviewsApi extends BaseAPI {
    /**
     * 
     * @param {number} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesInterviewsApi
     */
    public getInterviews(courseId: number, options?: AxiosRequestConfig) {
        return CoursesInterviewsApiFp(this.configuration).getInterviews(courseId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CoursesTasksApi - axios parameter creator
 * @export
 */
export const CoursesTasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {number} courseTaskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseTask: async (courseId: number, courseTaskId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getCourseTask', 'courseId', courseId)
            // verify required parameter 'courseTaskId' is not null or undefined
            assertParamExists('getCourseTask', 'courseTaskId', courseTaskId)
            const localVarPath = `/courses/{courseId}/tasks/{courseTaskId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"courseTaskId"}}`, encodeURIComponent(String(courseTaskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} courseId 
         * @param {'started' | 'inprogress' | 'finished'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseTasks: async (courseId: number, status?: 'started' | 'inprogress' | 'finished', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getCourseTasks', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/tasks`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CheckTasksDeadlineDto} checkTasksDeadlineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyTasksDeadlines: async (checkTasksDeadlineDto: CheckTasksDeadlineDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkTasksDeadlineDto' is not null or undefined
            assertParamExists('notifyTasksDeadlines', 'checkTasksDeadlineDto', checkTasksDeadlineDto)
            const localVarPath = `/tasks/notify/changes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkTasksDeadlineDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoursesTasksApi - functional programming interface
 * @export
 */
export const CoursesTasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoursesTasksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {number} courseTaskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseTask(courseId: number, courseTaskId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseTaskDetailedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseTask(courseId, courseTaskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} courseId 
         * @param {'started' | 'inprogress' | 'finished'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseTasks(courseId: number, status?: 'started' | 'inprogress' | 'finished', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CourseTaskDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseTasks(courseId, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CheckTasksDeadlineDto} checkTasksDeadlineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyTasksDeadlines(checkTasksDeadlineDto: CheckTasksDeadlineDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyTasksDeadlines(checkTasksDeadlineDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CoursesTasksApi - factory interface
 * @export
 */
export const CoursesTasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoursesTasksApiFp(configuration)
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {number} courseTaskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseTask(courseId: number, courseTaskId: number, options?: any): AxiosPromise<CourseTaskDetailedDto> {
            return localVarFp.getCourseTask(courseId, courseTaskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} courseId 
         * @param {'started' | 'inprogress' | 'finished'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseTasks(courseId: number, status?: 'started' | 'inprogress' | 'finished', options?: any): AxiosPromise<Array<CourseTaskDto>> {
            return localVarFp.getCourseTasks(courseId, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CheckTasksDeadlineDto} checkTasksDeadlineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyTasksDeadlines(checkTasksDeadlineDto: CheckTasksDeadlineDto, options?: any): AxiosPromise<void> {
            return localVarFp.notifyTasksDeadlines(checkTasksDeadlineDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoursesTasksApi - object-oriented interface
 * @export
 * @class CoursesTasksApi
 * @extends {BaseAPI}
 */
export class CoursesTasksApi extends BaseAPI {
    /**
     * 
     * @param {number} courseId 
     * @param {number} courseTaskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesTasksApi
     */
    public getCourseTask(courseId: number, courseTaskId: number, options?: AxiosRequestConfig) {
        return CoursesTasksApiFp(this.configuration).getCourseTask(courseId, courseTaskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} courseId 
     * @param {'started' | 'inprogress' | 'finished'} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesTasksApi
     */
    public getCourseTasks(courseId: number, status?: 'started' | 'inprogress' | 'finished', options?: AxiosRequestConfig) {
        return CoursesTasksApiFp(this.configuration).getCourseTasks(courseId, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CheckTasksDeadlineDto} checkTasksDeadlineDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesTasksApi
     */
    public notifyTasksDeadlines(checkTasksDeadlineDto: CheckTasksDeadlineDto, options?: AxiosRequestConfig) {
        return CoursesTasksApiFp(this.configuration).notifyTasksDeadlines(checkTasksDeadlineDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DisciplinesApi - axios parameter creator
 * @export
 */
export const DisciplinesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateDisciplineDto} createDisciplineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiscipline: async (createDisciplineDto: CreateDisciplineDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDisciplineDto' is not null or undefined
            assertParamExists('createDiscipline', 'createDisciplineDto', createDisciplineDto)
            const localVarPath = `/disciplines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDisciplineDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscipline: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDiscipline', 'id', id)
            const localVarPath = `/disciplines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisciplines: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/disciplines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateDisciplineDto} updateDisciplineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDiscipline: async (id: number, updateDisciplineDto: UpdateDisciplineDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDiscipline', 'id', id)
            // verify required parameter 'updateDisciplineDto' is not null or undefined
            assertParamExists('updateDiscipline', 'updateDisciplineDto', updateDisciplineDto)
            const localVarPath = `/disciplines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDisciplineDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DisciplinesApi - functional programming interface
 * @export
 */
export const DisciplinesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DisciplinesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateDisciplineDto} createDisciplineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDiscipline(createDisciplineDto: CreateDisciplineDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisciplineDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDiscipline(createDisciplineDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDiscipline(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDiscipline(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDisciplines(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DisciplineDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDisciplines(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateDisciplineDto} updateDisciplineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDiscipline(id: number, updateDisciplineDto: UpdateDisciplineDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisciplineDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDiscipline(id, updateDisciplineDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DisciplinesApi - factory interface
 * @export
 */
export const DisciplinesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DisciplinesApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateDisciplineDto} createDisciplineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiscipline(createDisciplineDto: CreateDisciplineDto, options?: any): AxiosPromise<DisciplineDto> {
            return localVarFp.createDiscipline(createDisciplineDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscipline(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDiscipline(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisciplines(options?: any): AxiosPromise<Array<DisciplineDto>> {
            return localVarFp.getDisciplines(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateDisciplineDto} updateDisciplineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDiscipline(id: number, updateDisciplineDto: UpdateDisciplineDto, options?: any): AxiosPromise<DisciplineDto> {
            return localVarFp.updateDiscipline(id, updateDisciplineDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DisciplinesApi - object-oriented interface
 * @export
 * @class DisciplinesApi
 * @extends {BaseAPI}
 */
export class DisciplinesApi extends BaseAPI {
    /**
     * 
     * @param {CreateDisciplineDto} createDisciplineDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisciplinesApi
     */
    public createDiscipline(createDisciplineDto: CreateDisciplineDto, options?: AxiosRequestConfig) {
        return DisciplinesApiFp(this.configuration).createDiscipline(createDisciplineDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisciplinesApi
     */
    public deleteDiscipline(id: number, options?: AxiosRequestConfig) {
        return DisciplinesApiFp(this.configuration).deleteDiscipline(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisciplinesApi
     */
    public getDisciplines(options?: AxiosRequestConfig) {
        return DisciplinesApiFp(this.configuration).getDisciplines(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UpdateDisciplineDto} updateDisciplineDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisciplinesApi
     */
    public updateDiscipline(id: number, updateDisciplineDto: UpdateDisciplineDto, options?: AxiosRequestConfig) {
        return DisciplinesApiFp(this.configuration).updateDiscipline(id, updateDisciplineDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DiscordServersApi - axios parameter creator
 * @export
 */
export const DiscordServersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateDiscordServerDto} createDiscordServerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiscordServer: async (createDiscordServerDto: CreateDiscordServerDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDiscordServerDto' is not null or undefined
            assertParamExists('createDiscordServer', 'createDiscordServerDto', createDiscordServerDto)
            const localVarPath = `/discord-servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDiscordServerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscordServer: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDiscordServer', 'id', id)
            const localVarPath = `/discord-servers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscordServers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/discord-servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateDiscordServerDto} updateDiscordServerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDiscordServer: async (id: number, updateDiscordServerDto: UpdateDiscordServerDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDiscordServer', 'id', id)
            // verify required parameter 'updateDiscordServerDto' is not null or undefined
            assertParamExists('updateDiscordServer', 'updateDiscordServerDto', updateDiscordServerDto)
            const localVarPath = `/discord-servers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDiscordServerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiscordServersApi - functional programming interface
 * @export
 */
export const DiscordServersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DiscordServersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateDiscordServerDto} createDiscordServerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDiscordServer(createDiscordServerDto: CreateDiscordServerDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscordServerDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDiscordServer(createDiscordServerDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDiscordServer(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscordServerDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDiscordServer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDiscordServers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DiscordServerDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDiscordServers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateDiscordServerDto} updateDiscordServerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDiscordServer(id: number, updateDiscordServerDto: UpdateDiscordServerDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscordServerDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDiscordServer(id, updateDiscordServerDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DiscordServersApi - factory interface
 * @export
 */
export const DiscordServersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DiscordServersApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateDiscordServerDto} createDiscordServerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiscordServer(createDiscordServerDto: CreateDiscordServerDto, options?: any): AxiosPromise<DiscordServerDto> {
            return localVarFp.createDiscordServer(createDiscordServerDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscordServer(id: number, options?: any): AxiosPromise<DiscordServerDto> {
            return localVarFp.deleteDiscordServer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscordServers(options?: any): AxiosPromise<Array<DiscordServerDto>> {
            return localVarFp.getDiscordServers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateDiscordServerDto} updateDiscordServerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDiscordServer(id: number, updateDiscordServerDto: UpdateDiscordServerDto, options?: any): AxiosPromise<DiscordServerDto> {
            return localVarFp.updateDiscordServer(id, updateDiscordServerDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DiscordServersApi - object-oriented interface
 * @export
 * @class DiscordServersApi
 * @extends {BaseAPI}
 */
export class DiscordServersApi extends BaseAPI {
    /**
     * 
     * @param {CreateDiscordServerDto} createDiscordServerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscordServersApi
     */
    public createDiscordServer(createDiscordServerDto: CreateDiscordServerDto, options?: AxiosRequestConfig) {
        return DiscordServersApiFp(this.configuration).createDiscordServer(createDiscordServerDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscordServersApi
     */
    public deleteDiscordServer(id: number, options?: AxiosRequestConfig) {
        return DiscordServersApiFp(this.configuration).deleteDiscordServer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscordServersApi
     */
    public getDiscordServers(options?: AxiosRequestConfig) {
        return DiscordServersApiFp(this.configuration).getDiscordServers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UpdateDiscordServerDto} updateDiscordServerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscordServersApi
     */
    public updateDiscordServer(id: number, updateDiscordServerDto: UpdateDiscordServerDto, options?: AxiosRequestConfig) {
        return DiscordServersApiFp(this.configuration).updateDiscordServer(id, updateDiscordServerDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GratitudesApi - axios parameter creator
 * @export
 */
export const GratitudesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateGratitudeDto} createGratitudeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGratitude: async (createGratitudeDto: CreateGratitudeDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createGratitudeDto' is not null or undefined
            assertParamExists('createGratitude', 'createGratitudeDto', createGratitudeDto)
            const localVarPath = `/gratitudes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGratitudeDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBadges: async (courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getBadges', 'courseId', courseId)
            const localVarPath = `/gratitudes/badges/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GratitudesApi - functional programming interface
 * @export
 */
export const GratitudesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GratitudesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateGratitudeDto} createGratitudeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGratitude(createGratitudeDto: CreateGratitudeDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GratitudeDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGratitude(createGratitudeDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBadges(courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BadgeDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBadges(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GratitudesApi - factory interface
 * @export
 */
export const GratitudesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GratitudesApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateGratitudeDto} createGratitudeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGratitude(createGratitudeDto: CreateGratitudeDto, options?: any): AxiosPromise<GratitudeDto> {
            return localVarFp.createGratitude(createGratitudeDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBadges(courseId: number, options?: any): AxiosPromise<Array<BadgeDto>> {
            return localVarFp.getBadges(courseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GratitudesApi - object-oriented interface
 * @export
 * @class GratitudesApi
 * @extends {BaseAPI}
 */
export class GratitudesApi extends BaseAPI {
    /**
     * 
     * @param {CreateGratitudeDto} createGratitudeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GratitudesApi
     */
    public createGratitude(createGratitudeDto: CreateGratitudeDto, options?: AxiosRequestConfig) {
        return GratitudesApiFp(this.configuration).createGratitude(createGratitudeDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GratitudesApi
     */
    public getBadges(courseId: number, options?: AxiosRequestConfig) {
        return GratitudesApiFp(this.configuration).getBadges(courseId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MentorsApi - axios parameter creator
 * @export
 */
export const MentorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} mentorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMentorStudents: async (mentorId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mentorId' is not null or undefined
            assertParamExists('getMentorStudents', 'mentorId', mentorId)
            const localVarPath = `/mentors/{mentorId}/students`
                .replace(`{${"mentorId"}}`, encodeURIComponent(String(mentorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MentorsApi - functional programming interface
 * @export
 */
export const MentorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MentorsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} mentorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMentorStudents(mentorId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MentorStudentDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMentorStudents(mentorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MentorsApi - factory interface
 * @export
 */
export const MentorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MentorsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} mentorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMentorStudents(mentorId: number, options?: any): AxiosPromise<Array<MentorStudentDto>> {
            return localVarFp.getMentorStudents(mentorId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MentorsApi - object-oriented interface
 * @export
 * @class MentorsApi
 * @extends {BaseAPI}
 */
export class MentorsApi extends BaseAPI {
    /**
     * 
     * @param {number} mentorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MentorsApi
     */
    public getMentorStudents(mentorId: number, options?: AxiosRequestConfig) {
        return MentorsApiFp(this.configuration).getMentorStudents(mentorId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UpdateNotificationDto} updateNotificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotification: async (updateNotificationDto: UpdateNotificationDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateNotificationDto' is not null or undefined
            assertParamExists('createNotification', 'updateNotificationDto', updateNotificationDto)
            const localVarPath = `/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNotificationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotification: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteNotification', 'id', id)
            const localVarPath = `/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateNotificationDto} updateNotificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotification: async (updateNotificationDto: UpdateNotificationDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateNotificationDto' is not null or undefined
            assertParamExists('updateNotification', 'updateNotificationDto', updateNotificationDto)
            const localVarPath = `/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNotificationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UpdateNotificationDto} updateNotificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNotification(updateNotificationDto: UpdateNotificationDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNotification(updateNotificationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNotification(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNotification(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotifications(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotifications(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateNotificationDto} updateNotificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNotification(updateNotificationDto: UpdateNotificationDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNotification(updateNotificationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * 
         * @param {UpdateNotificationDto} updateNotificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotification(updateNotificationDto: UpdateNotificationDto, options?: any): AxiosPromise<NotificationDto> {
            return localVarFp.createNotification(updateNotificationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotification(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteNotification(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(options?: any): AxiosPromise<Array<NotificationDto>> {
            return localVarFp.getNotifications(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateNotificationDto} updateNotificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotification(updateNotificationDto: UpdateNotificationDto, options?: any): AxiosPromise<NotificationDto> {
            return localVarFp.updateNotification(updateNotificationDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * 
     * @param {UpdateNotificationDto} updateNotificationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public createNotification(updateNotificationDto: UpdateNotificationDto, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).createNotification(updateNotificationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public deleteNotification(id: string, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).deleteNotification(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public getNotifications(options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).getNotifications(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateNotificationDto} updateNotificationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public updateNotification(updateNotificationDto: UpdateNotificationDto, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).updateNotification(updateNotificationDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OpportunitiesApi - axios parameter creator
 * @export
 */
export const OpportunitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConsent: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/opportunities/consent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConsent: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/opportunities/consent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsent: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/opportunities/consent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicResume: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getPublicResume', 'uuid', uuid)
            const localVarPath = `/opportunities/public/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} githubId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResume: async (githubId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'githubId' is not null or undefined
            assertParamExists('getResume', 'githubId', githubId)
            const localVarPath = `/opportunities/{githubId}/resume`
                .replace(`{${"githubId"}}`, encodeURIComponent(String(githubId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OpportunitiesApi - functional programming interface
 * @export
 */
export const OpportunitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OpportunitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConsent(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConsent(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConsent(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConsent(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConsent(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConsent(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicResume(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResumeDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicResume(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} githubId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResume(githubId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResumeDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResume(githubId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OpportunitiesApi - factory interface
 * @export
 */
export const OpportunitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OpportunitiesApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConsent(options?: any): AxiosPromise<ConsentDto> {
            return localVarFp.createConsent(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConsent(options?: any): AxiosPromise<ConsentDto> {
            return localVarFp.deleteConsent(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsent(options?: any): AxiosPromise<ConsentDto> {
            return localVarFp.getConsent(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicResume(uuid: string, options?: any): AxiosPromise<ResumeDto> {
            return localVarFp.getPublicResume(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} githubId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResume(githubId: string, options?: any): AxiosPromise<ResumeDto> {
            return localVarFp.getResume(githubId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OpportunitiesApi - object-oriented interface
 * @export
 * @class OpportunitiesApi
 * @extends {BaseAPI}
 */
export class OpportunitiesApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpportunitiesApi
     */
    public createConsent(options?: AxiosRequestConfig) {
        return OpportunitiesApiFp(this.configuration).createConsent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpportunitiesApi
     */
    public deleteConsent(options?: AxiosRequestConfig) {
        return OpportunitiesApiFp(this.configuration).deleteConsent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpportunitiesApi
     */
    public getConsent(options?: AxiosRequestConfig) {
        return OpportunitiesApiFp(this.configuration).getConsent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpportunitiesApi
     */
    public getPublicResume(uuid: string, options?: AxiosRequestConfig) {
        return OpportunitiesApiFp(this.configuration).getPublicResume(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} githubId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpportunitiesApi
     */
    public getResume(githubId: string, options?: AxiosRequestConfig) {
        return OpportunitiesApiFp(this.configuration).getResume(githubId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProfileApi - axios parameter creator
 * @export
 */
export const ProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCourses: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUserCourses', 'username', username)
            const localVarPath = `/profile/{username}/courses`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ProfileInfoDto} profileInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileInfo: async (profileInfoDto: ProfileInfoDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileInfoDto' is not null or undefined
            assertParamExists('updateProfileInfo', 'profileInfoDto', profileInfoDto)
            const localVarPath = `/profile/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profileInfoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (updateUserDto: UpdateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('updateUser', 'updateUserDto', updateUserDto)
            const localVarPath = `/profile/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCourses(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProfileCourseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCourses(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ProfileInfoDto} profileInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfileInfo(profileInfoDto: ProfileInfoDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProfileInfo(profileInfoDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(updateUserDto: UpdateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(updateUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileApiFp(configuration)
    return {
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCourses(username: string, options?: any): AxiosPromise<Array<ProfileCourseDto>> {
            return localVarFp.getUserCourses(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ProfileInfoDto} profileInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileInfo(profileInfoDto: ProfileInfoDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateProfileInfo(profileInfoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(updateUserDto: UpdateUserDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateUser(updateUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
    /**
     * 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getUserCourses(username: string, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).getUserCourses(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ProfileInfoDto} profileInfoDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public updateProfileInfo(profileInfoDto: ProfileInfoDto, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).updateProfileInfo(profileInfoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateUserDto} updateUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public updateUser(updateUserDto: UpdateUserDto, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).updateUser(updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RegistryApi - axios parameter creator
 * @export
 */
export const RegistryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} githubId 
         * @param {ApproveMentorDto} approveMentorDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveMentor: async (githubId: string, approveMentorDto: ApproveMentorDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'githubId' is not null or undefined
            assertParamExists('approveMentor', 'githubId', githubId)
            // verify required parameter 'approveMentorDto' is not null or undefined
            assertParamExists('approveMentor', 'approveMentorDto', approveMentorDto)
            const localVarPath = `/registry/mentor/{githubId}`
                .replace(`{${"githubId"}}`, encodeURIComponent(String(githubId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(approveMentorDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistryApi - functional programming interface
 * @export
 */
export const RegistryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegistryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} githubId 
         * @param {ApproveMentorDto} approveMentorDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveMentor(githubId: string, approveMentorDto: ApproveMentorDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveMentor(githubId, approveMentorDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RegistryApi - factory interface
 * @export
 */
export const RegistryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegistryApiFp(configuration)
    return {
        /**
         * 
         * @param {string} githubId 
         * @param {ApproveMentorDto} approveMentorDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveMentor(githubId: string, approveMentorDto: ApproveMentorDto, options?: any): AxiosPromise<void> {
            return localVarFp.approveMentor(githubId, approveMentorDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RegistryApi - object-oriented interface
 * @export
 * @class RegistryApi
 * @extends {BaseAPI}
 */
export class RegistryApi extends BaseAPI {
    /**
     * 
     * @param {string} githubId 
     * @param {ApproveMentorDto} approveMentorDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public approveMentor(githubId: string, approveMentorDto: ApproveMentorDto, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).approveMentor(githubId, approveMentorDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ScheduleApi - axios parameter creator
 * @export
 */
export const ScheduleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyScheduleChanges: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/schedule/notify/changes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduleApi - functional programming interface
 * @export
 */
export const ScheduleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScheduleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyScheduleChanges(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyScheduleChanges(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ScheduleApi - factory interface
 * @export
 */
export const ScheduleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScheduleApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyScheduleChanges(options?: any): AxiosPromise<void> {
            return localVarFp.notifyScheduleChanges(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScheduleApi - object-oriented interface
 * @export
 * @class ScheduleApi
 * @extends {BaseAPI}
 */
export class ScheduleApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public notifyScheduleChanges(options?: AxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).notifyScheduleChanges(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudentsApi - axios parameter creator
 * @export
 */
export const StudentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} studentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudent: async (studentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studentId' is not null or undefined
            assertParamExists('getStudent', 'studentId', studentId)
            const localVarPath = `/students/{studentId}`
                .replace(`{${"studentId"}}`, encodeURIComponent(String(studentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudentsApi - functional programming interface
 * @export
 */
export const StudentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} studentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudent(studentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudent(studentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StudentsApi - factory interface
 * @export
 */
export const StudentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudentsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} studentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudent(studentId: number, options?: any): AxiosPromise<StudentDto> {
            return localVarFp.getStudent(studentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudentsApi - object-oriented interface
 * @export
 * @class StudentsApi
 * @extends {BaseAPI}
 */
export class StudentsApi extends BaseAPI {
    /**
     * 
     * @param {number} studentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public getStudent(studentId: number, options?: AxiosRequestConfig) {
        return StudentsApiFp(this.configuration).getStudent(studentId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudentsFeedbacksApi - axios parameter creator
 * @export
 */
export const StudentsFeedbacksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} studentId 
         * @param {CreateStudentFeedbackDto} createStudentFeedbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudentFeedback: async (studentId: number, createStudentFeedbackDto: CreateStudentFeedbackDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studentId' is not null or undefined
            assertParamExists('createStudentFeedback', 'studentId', studentId)
            // verify required parameter 'createStudentFeedbackDto' is not null or undefined
            assertParamExists('createStudentFeedback', 'createStudentFeedbackDto', createStudentFeedbackDto)
            const localVarPath = `/students/{studentId}/feedbacks`
                .replace(`{${"studentId"}}`, encodeURIComponent(String(studentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStudentFeedbackDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} studentId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentFeedback: async (studentId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studentId' is not null or undefined
            assertParamExists('getStudentFeedback', 'studentId', studentId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStudentFeedback', 'id', id)
            const localVarPath = `/students/{studentId}/feedbacks/{id}`
                .replace(`{${"studentId"}}`, encodeURIComponent(String(studentId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} studentId 
         * @param {number} id 
         * @param {UpdateStudentFeedbackDto} updateStudentFeedbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStudentFeedback: async (studentId: number, id: number, updateStudentFeedbackDto: UpdateStudentFeedbackDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studentId' is not null or undefined
            assertParamExists('updateStudentFeedback', 'studentId', studentId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateStudentFeedback', 'id', id)
            // verify required parameter 'updateStudentFeedbackDto' is not null or undefined
            assertParamExists('updateStudentFeedback', 'updateStudentFeedbackDto', updateStudentFeedbackDto)
            const localVarPath = `/students/{studentId}/feedbacks/{id}`
                .replace(`{${"studentId"}}`, encodeURIComponent(String(studentId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStudentFeedbackDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudentsFeedbacksApi - functional programming interface
 * @export
 */
export const StudentsFeedbacksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudentsFeedbacksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} studentId 
         * @param {CreateStudentFeedbackDto} createStudentFeedbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStudentFeedback(studentId: number, createStudentFeedbackDto: CreateStudentFeedbackDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentFeedbackDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStudentFeedback(studentId, createStudentFeedbackDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} studentId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudentFeedback(studentId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentFeedbackDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudentFeedback(studentId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} studentId 
         * @param {number} id 
         * @param {UpdateStudentFeedbackDto} updateStudentFeedbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStudentFeedback(studentId: number, id: number, updateStudentFeedbackDto: UpdateStudentFeedbackDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentFeedbackDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStudentFeedback(studentId, id, updateStudentFeedbackDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StudentsFeedbacksApi - factory interface
 * @export
 */
export const StudentsFeedbacksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudentsFeedbacksApiFp(configuration)
    return {
        /**
         * 
         * @param {number} studentId 
         * @param {CreateStudentFeedbackDto} createStudentFeedbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudentFeedback(studentId: number, createStudentFeedbackDto: CreateStudentFeedbackDto, options?: any): AxiosPromise<StudentFeedbackDto> {
            return localVarFp.createStudentFeedback(studentId, createStudentFeedbackDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} studentId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentFeedback(studentId: number, id: number, options?: any): AxiosPromise<StudentFeedbackDto> {
            return localVarFp.getStudentFeedback(studentId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} studentId 
         * @param {number} id 
         * @param {UpdateStudentFeedbackDto} updateStudentFeedbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStudentFeedback(studentId: number, id: number, updateStudentFeedbackDto: UpdateStudentFeedbackDto, options?: any): AxiosPromise<StudentFeedbackDto> {
            return localVarFp.updateStudentFeedback(studentId, id, updateStudentFeedbackDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudentsFeedbacksApi - object-oriented interface
 * @export
 * @class StudentsFeedbacksApi
 * @extends {BaseAPI}
 */
export class StudentsFeedbacksApi extends BaseAPI {
    /**
     * 
     * @param {number} studentId 
     * @param {CreateStudentFeedbackDto} createStudentFeedbackDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsFeedbacksApi
     */
    public createStudentFeedback(studentId: number, createStudentFeedbackDto: CreateStudentFeedbackDto, options?: AxiosRequestConfig) {
        return StudentsFeedbacksApiFp(this.configuration).createStudentFeedback(studentId, createStudentFeedbackDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} studentId 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsFeedbacksApi
     */
    public getStudentFeedback(studentId: number, id: number, options?: AxiosRequestConfig) {
        return StudentsFeedbacksApiFp(this.configuration).getStudentFeedback(studentId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} studentId 
     * @param {number} id 
     * @param {UpdateStudentFeedbackDto} updateStudentFeedbackDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsFeedbacksApi
     */
    public updateStudentFeedback(studentId: number, id: number, updateStudentFeedbackDto: UpdateStudentFeedbackDto, options?: AxiosRequestConfig) {
        return StudentsFeedbacksApiFp(this.configuration).updateStudentFeedback(studentId, id, updateStudentFeedbackDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserGroupApi - axios parameter creator
 * @export
 */
export const UserGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateUserGroupDto} createUserGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserGroup: async (createUserGroupDto: CreateUserGroupDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserGroupDto' is not null or undefined
            assertParamExists('createUserGroup', 'createUserGroupDto', createUserGroupDto)
            const localVarPath = `/user-group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserGroupDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserGroup: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUserGroup', 'id', id)
            const localVarPath = `/user-group/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateUserGroupDto} updateUserGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserGroup: async (id: number, updateUserGroupDto: UpdateUserGroupDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserGroup', 'id', id)
            // verify required parameter 'updateUserGroupDto' is not null or undefined
            assertParamExists('updateUserGroup', 'updateUserGroupDto', updateUserGroupDto)
            const localVarPath = `/user-group/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserGroupDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserGroupApi - functional programming interface
 * @export
 */
export const UserGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserGroupApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateUserGroupDto} createUserGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserGroup(createUserGroupDto: CreateUserGroupDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGroupDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserGroup(createUserGroupDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserGroup(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGroupDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserGroups(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserGroupDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateUserGroupDto} updateUserGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserGroup(id: number, updateUserGroupDto: UpdateUserGroupDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGroupDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserGroup(id, updateUserGroupDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserGroupApi - factory interface
 * @export
 */
export const UserGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserGroupApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateUserGroupDto} createUserGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserGroup(createUserGroupDto: CreateUserGroupDto, options?: any): AxiosPromise<UserGroupDto> {
            return localVarFp.createUserGroup(createUserGroupDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserGroup(id: number, options?: any): AxiosPromise<UserGroupDto> {
            return localVarFp.deleteUserGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups(options?: any): AxiosPromise<Array<UserGroupDto>> {
            return localVarFp.getUserGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateUserGroupDto} updateUserGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserGroup(id: number, updateUserGroupDto: UpdateUserGroupDto, options?: any): AxiosPromise<UserGroupDto> {
            return localVarFp.updateUserGroup(id, updateUserGroupDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserGroupApi - object-oriented interface
 * @export
 * @class UserGroupApi
 * @extends {BaseAPI}
 */
export class UserGroupApi extends BaseAPI {
    /**
     * 
     * @param {CreateUserGroupDto} createUserGroupDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    public createUserGroup(createUserGroupDto: CreateUserGroupDto, options?: AxiosRequestConfig) {
        return UserGroupApiFp(this.configuration).createUserGroup(createUserGroupDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    public deleteUserGroup(id: number, options?: AxiosRequestConfig) {
        return UserGroupApiFp(this.configuration).deleteUserGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    public getUserGroups(options?: AxiosRequestConfig) {
        return UserGroupApiFp(this.configuration).getUserGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UpdateUserGroupDto} updateUserGroupDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    public updateUserGroup(id: number, updateUserGroupDto: UpdateUserGroupDto, options?: AxiosRequestConfig) {
        return UserGroupApiFp(this.configuration).updateUserGroup(id, updateUserGroupDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersNotificationsApi - axios parameter creator
 * @export
 */
export const UsersNotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotificationConnections: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/notifications/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotifications: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailConfirmationLink: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/notifications/confirmation/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SendUserNotificationDto} sendUserNotificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendNotification: async (sendUserNotificationDto: SendUserNotificationDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendUserNotificationDto' is not null or undefined
            assertParamExists('sendNotification', 'sendUserNotificationDto', sendUserNotificationDto)
            const localVarPath = `/users/notifications/send`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendUserNotificationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<UpdateNotificationUserSettingsDto>} updateNotificationUserSettingsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNotifications: async (updateNotificationUserSettingsDto: Array<UpdateNotificationUserSettingsDto>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateNotificationUserSettingsDto' is not null or undefined
            assertParamExists('updateUserNotifications', 'updateNotificationUserSettingsDto', updateNotificationUserSettingsDto)
            const localVarPath = `/users/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNotificationUserSettingsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpsertNotificationConnectionDto} upsertNotificationConnectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersNotificationsControllerCreateUserConnection: async (upsertNotificationConnectionDto: UpsertNotificationConnectionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'upsertNotificationConnectionDto' is not null or undefined
            assertParamExists('usersNotificationsControllerCreateUserConnection', 'upsertNotificationConnectionDto', upsertNotificationConnectionDto)
            const localVarPath = `/users/notifications/connection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertNotificationConnectionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NotificationConnectionExistsDto} notificationConnectionExistsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersNotificationsControllerFindConnection: async (notificationConnectionExistsDto: NotificationConnectionExistsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationConnectionExistsDto' is not null or undefined
            assertParamExists('usersNotificationsControllerFindConnection', 'notificationConnectionExistsDto', notificationConnectionExistsDto)
            const localVarPath = `/users/notifications/connection/find`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationConnectionExistsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersNotificationsApi - functional programming interface
 * @export
 */
export const UsersNotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersNotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserNotificationConnections(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationUserConnectionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserNotificationConnections(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserNotifications(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserNotificationsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserNotifications(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendEmailConfirmationLink(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendEmailConfirmationLink(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SendUserNotificationDto} sendUserNotificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendNotification(sendUserNotificationDto: SendUserNotificationDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendNotification(sendUserNotificationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<UpdateNotificationUserSettingsDto>} updateNotificationUserSettingsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserNotifications(updateNotificationUserSettingsDto: Array<UpdateNotificationUserSettingsDto>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UpdateNotificationUserSettingsDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserNotifications(updateNotificationUserSettingsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpsertNotificationConnectionDto} upsertNotificationConnectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersNotificationsControllerCreateUserConnection(upsertNotificationConnectionDto: UpsertNotificationConnectionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationConnectionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersNotificationsControllerCreateUserConnection(upsertNotificationConnectionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {NotificationConnectionExistsDto} notificationConnectionExistsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersNotificationsControllerFindConnection(notificationConnectionExistsDto: NotificationConnectionExistsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationConnectionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersNotificationsControllerFindConnection(notificationConnectionExistsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersNotificationsApi - factory interface
 * @export
 */
export const UsersNotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersNotificationsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotificationConnections(options?: any): AxiosPromise<NotificationUserConnectionsDto> {
            return localVarFp.getUserNotificationConnections(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotifications(options?: any): AxiosPromise<UserNotificationsDto> {
            return localVarFp.getUserNotifications(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailConfirmationLink(options?: any): AxiosPromise<void> {
            return localVarFp.sendEmailConfirmationLink(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SendUserNotificationDto} sendUserNotificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendNotification(sendUserNotificationDto: SendUserNotificationDto, options?: any): AxiosPromise<void> {
            return localVarFp.sendNotification(sendUserNotificationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<UpdateNotificationUserSettingsDto>} updateNotificationUserSettingsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNotifications(updateNotificationUserSettingsDto: Array<UpdateNotificationUserSettingsDto>, options?: any): AxiosPromise<Array<UpdateNotificationUserSettingsDto>> {
            return localVarFp.updateUserNotifications(updateNotificationUserSettingsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpsertNotificationConnectionDto} upsertNotificationConnectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersNotificationsControllerCreateUserConnection(upsertNotificationConnectionDto: UpsertNotificationConnectionDto, options?: any): AxiosPromise<NotificationConnectionDto> {
            return localVarFp.usersNotificationsControllerCreateUserConnection(upsertNotificationConnectionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {NotificationConnectionExistsDto} notificationConnectionExistsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersNotificationsControllerFindConnection(notificationConnectionExistsDto: NotificationConnectionExistsDto, options?: any): AxiosPromise<NotificationConnectionDto> {
            return localVarFp.usersNotificationsControllerFindConnection(notificationConnectionExistsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersNotificationsApi - object-oriented interface
 * @export
 * @class UsersNotificationsApi
 * @extends {BaseAPI}
 */
export class UsersNotificationsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersNotificationsApi
     */
    public getUserNotificationConnections(options?: AxiosRequestConfig) {
        return UsersNotificationsApiFp(this.configuration).getUserNotificationConnections(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersNotificationsApi
     */
    public getUserNotifications(options?: AxiosRequestConfig) {
        return UsersNotificationsApiFp(this.configuration).getUserNotifications(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersNotificationsApi
     */
    public sendEmailConfirmationLink(options?: AxiosRequestConfig) {
        return UsersNotificationsApiFp(this.configuration).sendEmailConfirmationLink(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SendUserNotificationDto} sendUserNotificationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersNotificationsApi
     */
    public sendNotification(sendUserNotificationDto: SendUserNotificationDto, options?: AxiosRequestConfig) {
        return UsersNotificationsApiFp(this.configuration).sendNotification(sendUserNotificationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<UpdateNotificationUserSettingsDto>} updateNotificationUserSettingsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersNotificationsApi
     */
    public updateUserNotifications(updateNotificationUserSettingsDto: Array<UpdateNotificationUserSettingsDto>, options?: AxiosRequestConfig) {
        return UsersNotificationsApiFp(this.configuration).updateUserNotifications(updateNotificationUserSettingsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpsertNotificationConnectionDto} upsertNotificationConnectionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersNotificationsApi
     */
    public usersNotificationsControllerCreateUserConnection(upsertNotificationConnectionDto: UpsertNotificationConnectionDto, options?: AxiosRequestConfig) {
        return UsersNotificationsApiFp(this.configuration).usersNotificationsControllerCreateUserConnection(upsertNotificationConnectionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {NotificationConnectionExistsDto} notificationConnectionExistsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersNotificationsApi
     */
    public usersNotificationsControllerFindConnection(notificationConnectionExistsDto: NotificationConnectionExistsDto, options?: AxiosRequestConfig) {
        return UsersNotificationsApiFp(this.configuration).usersNotificationsControllerFindConnection(notificationConnectionExistsDto, options).then((request) => request(this.axios, this.basePath));
    }
}


