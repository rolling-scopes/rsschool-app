/* tslint:disable */
/* eslint-disable */
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ActivityDto
 */
export interface ActivityDto {
    /**
     * 
     * @type {number}
     * @memberof ActivityDto
     */
    'lastActivityTime': number;
    /**
     * 
     * @type {boolean}
     * @memberof ActivityDto
     */
    'isActive': boolean;
}
/**
 * 
 * @export
 * @interface AlertDto
 */
export interface AlertDto {
    /**
     * 
     * @type {number}
     * @memberof AlertDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof AlertDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof AlertDto
     */
    'text': string;
    /**
     * 
     * @type {boolean}
     * @memberof AlertDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {number}
     * @memberof AlertDto
     */
    'courseId': number | null;
    /**
     * 
     * @type {string}
     * @memberof AlertDto
     */
    'updatedDate': string;
    /**
     * 
     * @type {string}
     * @memberof AlertDto
     */
    'createdDate': string;
}
/**
 * 
 * @export
 * @interface ApplicantResumeDto
 */
export interface ApplicantResumeDto {
    /**
     * 
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'avatarLink': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ApplicantResumeDto
     */
    'visibleCourses': Array<number>;
    /**
     * 
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'desiredPosition': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'englishLevel': ApplicantResumeDtoEnglishLevelEnum;
    /**
     * 
     * @type {number}
     * @memberof ApplicantResumeDto
     */
    'expires': number;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicantResumeDto
     */
    'fullTime': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'githubId': string;
    /**
     * 
     * @type {number}
     * @memberof ApplicantResumeDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'linkedin': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'locations': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'militaryService': ApplicantResumeDtoMilitaryServiceEnum;
    /**
     * 
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'notes': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'selfIntroLink': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'skype': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'startFrom': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'telegram': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicantResumeDto
     */
    'website': string;
}

export const ApplicantResumeDtoEnglishLevelEnum = {
    Unknown: 'unknown',
    A0: 'a0',
    A1: 'a1',
    A2: 'a2',
    B1: 'b1',
    B2: 'b2',
    C1: 'c1',
    C2: 'c2'
} as const;

export type ApplicantResumeDtoEnglishLevelEnum = typeof ApplicantResumeDtoEnglishLevelEnum[keyof typeof ApplicantResumeDtoEnglishLevelEnum];
export const ApplicantResumeDtoMilitaryServiceEnum = {
    Served: 'served',
    Liable: 'liable',
    NotLiable: 'notLiable'
} as const;

export type ApplicantResumeDtoMilitaryServiceEnum = typeof ApplicantResumeDtoMilitaryServiceEnum[keyof typeof ApplicantResumeDtoMilitaryServiceEnum];

/**
 * 
 * @export
 * @interface ApproveMentorDto
 */
export interface ApproveMentorDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof ApproveMentorDto
     */
    'preselectedCourses': Array<string>;
}
/**
 * 
 * @export
 * @interface AuthConnectionDto
 */
export interface AuthConnectionDto {
    /**
     * 
     * @type {string}
     * @memberof AuthConnectionDto
     */
    'channelId': string;
    /**
     * 
     * @type {string}
     * @memberof AuthConnectionDto
     */
    'externalId': string;
}
/**
 * 
 * @export
 * @interface AvailableStudentDto
 */
export interface AvailableStudentDto {
    /**
     * 
     * @type {number}
     * @memberof AvailableStudentDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof AvailableStudentDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AvailableStudentDto
     */
    'githubId': string;
    /**
     * 
     * @type {string}
     * @memberof AvailableStudentDto
     */
    'cityName': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AvailableStudentDto
     */
    'isGoodCandidate': boolean;
    /**
     * 
     * @type {string}
     * @memberof AvailableStudentDto
     */
    'rating': string | null;
    /**
     * 
     * @type {number}
     * @memberof AvailableStudentDto
     */
    'totalScore': number;
    /**
     * 
     * @type {string}
     * @memberof AvailableStudentDto
     */
    'registeredDate': string;
}
/**
 * 
 * @export
 * @interface BadgeDto
 */
export interface BadgeDto {
    /**
     * 
     * @type {string}
     * @memberof BadgeDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BadgeDto
     */
    'id': BadgeDtoIdEnum;
}

export const BadgeDtoIdEnum = {
    Congratulations: 'Congratulations',
    ExpertHelp: 'Expert_help',
    GreatSpeaker: 'Great_speaker',
    GoodJob: 'Good_job',
    HelpingHand: 'Helping_hand',
    Hero: 'Hero',
    ThankYou: 'Thank_you',
    OutstandingWork: 'Outstanding_work',
    TopPerformer: 'Top_performer',
    JobOffer: 'Job_Offer',
    RsActivist: 'RS_activist'
} as const;

export type BadgeDtoIdEnum = typeof BadgeDtoIdEnum[keyof typeof BadgeDtoIdEnum];

/**
 * 
 * @export
 * @interface ChannelSettings
 */
export interface ChannelSettings {
    /**
     * 
     * @type {string}
     * @memberof ChannelSettings
     */
    'channelId': string;
    /**
     * 
     * @type {object}
     * @memberof ChannelSettings
     */
    'template': object;
}
/**
 * 
 * @export
 * @interface CheckScheduleChangesDto
 */
export interface CheckScheduleChangesDto {
    /**
     * 
     * @type {number}
     * @memberof CheckScheduleChangesDto
     */
    'lastHours': number;
}
/**
 * 
 * @export
 * @interface CheckTasksDeadlineDto
 */
export interface CheckTasksDeadlineDto {
    /**
     * 
     * @type {number}
     * @memberof CheckTasksDeadlineDto
     */
    'deadlineInHours': number;
}
/**
 * 
 * @export
 * @interface ConfigurableProfilePermissions
 */
export interface ConfigurableProfilePermissions {
    /**
     * 
     * @type {PublicVisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isProfileVisible'?: PublicVisibilitySettings;
    /**
     * 
     * @type {VisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isAboutVisible'?: VisibilitySettings;
    /**
     * 
     * @type {VisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isEducationVisible'?: VisibilitySettings;
    /**
     * 
     * @type {PartialStudentVisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isEnglishVisible'?: PartialStudentVisibilitySettings;
    /**
     * 
     * @type {ContactsVisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isEmailVisible'?: ContactsVisibilitySettings;
    /**
     * 
     * @type {ContactsVisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isTelegramVisible'?: ContactsVisibilitySettings;
    /**
     * 
     * @type {ContactsVisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isSkypeVisible'?: ContactsVisibilitySettings;
    /**
     * 
     * @type {ContactsVisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isPhoneVisible'?: ContactsVisibilitySettings;
    /**
     * 
     * @type {ContactsVisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isContactsNotesVisible'?: ContactsVisibilitySettings;
    /**
     * 
     * @type {VisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isLinkedInVisible'?: VisibilitySettings;
    /**
     * 
     * @type {VisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isPublicFeedbackVisible'?: VisibilitySettings;
    /**
     * 
     * @type {VisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isMentorStatsVisible'?: VisibilitySettings;
    /**
     * 
     * @type {PartialStudentVisibilitySettings}
     * @memberof ConfigurableProfilePermissions
     */
    'isStudentStatsVisible'?: PartialStudentVisibilitySettings;
}
/**
 * 
 * @export
 * @interface ConsentDto
 */
export interface ConsentDto {
    /**
     * 
     * @type {boolean}
     * @memberof ConsentDto
     */
    'consent': boolean;
}
/**
 * 
 * @export
 * @interface ContactsDto
 */
export interface ContactsDto {
    /**
     * 
     * @type {string}
     * @memberof ContactsDto
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactsDto
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactsDto
     */
    'epamEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactsDto
     */
    'skype'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactsDto
     */
    'telegram'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactsDto
     */
    'notes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactsDto
     */
    'linkedIn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactsDto
     */
    'discord'?: string | null;
}
/**
 * 
 * @export
 * @interface ContactsVisibilitySettings
 */
export interface ContactsVisibilitySettings {
    /**
     * 
     * @type {boolean}
     * @memberof ContactsVisibilitySettings
     */
    'all': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ContactsVisibilitySettings
     */
    'student': boolean;
}
/**
 * 
 * @export
 * @interface CourseCopyFromDto
 */
export interface CourseCopyFromDto {
    /**
     * 
     * @type {number}
     * @memberof CourseCopyFromDto
     */
    'copyFromCourseId': number;
}
/**
 * 
 * @export
 * @interface CourseDto
 */
export interface CourseDto {
    /**
     * 
     * @type {number}
     * @memberof CourseDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'createdDate': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'updatedDate': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'alias': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'descriptionUrl': string;
    /**
     * 
     * @type {number}
     * @memberof CourseDto
     */
    'year': number;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'endDate': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'registrationEndDate': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'primarySkillId': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'primarySkillName': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'locationName': string;
    /**
     * 
     * @type {number}
     * @memberof CourseDto
     */
    'discordServerId': number;
    /**
     * 
     * @type {boolean}
     * @memberof CourseDto
     */
    'completed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CourseDto
     */
    'planned': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CourseDto
     */
    'inviteOnly': boolean;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'certificateIssuer': string;
    /**
     * 
     * @type {boolean}
     * @memberof CourseDto
     */
    'usePrivateRepositories': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CourseDto
     */
    'personalMentoring': boolean;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'logo': string;
    /**
     * 
     * @type {IdNameDto}
     * @memberof CourseDto
     */
    'discipline': IdNameDto | null;
}
/**
 * 
 * @export
 * @interface CourseEventDto
 */
export interface CourseEventDto {
    /**
     * 
     * @type {number}
     * @memberof CourseEventDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CourseEventDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CourseEventDto
     */
    'type': CourseEventDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CourseEventDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CourseEventDto
     */
    'descriptionUrl': string;
    /**
     * 
     * @type {string}
     * @memberof CourseEventDto
     */
    'dateTime': string;
    /**
     * 
     * @type {PersonDto}
     * @memberof CourseEventDto
     */
    'organizer': PersonDto;
}

export const CourseEventDtoTypeEnum = {
    LectureOnline: 'lecture_online',
    LectureOffline: 'lecture_offline',
    LectureMixed: 'lecture_mixed',
    LectureSelfStudy: 'lecture_self_study',
    Warmup: 'warmup',
    Info: 'info',
    Workshop: 'workshop',
    Meetup: 'meetup',
    CrossCheckDeadline: 'cross_check_deadline',
    Webinar: 'webinar',
    Special: 'special'
} as const;

export type CourseEventDtoTypeEnum = typeof CourseEventDtoTypeEnum[keyof typeof CourseEventDtoTypeEnum];

/**
 * 
 * @export
 * @interface CourseScheduleItemDto
 */
export interface CourseScheduleItemDto {
    /**
     * 
     * @type {object}
     * @memberof CourseScheduleItemDto
     */
    'score': object;
    /**
     * 
     * @type {string}
     * @memberof CourseScheduleItemDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CourseScheduleItemDto
     */
    'status': CourseScheduleItemDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CourseScheduleItemDto
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof CourseScheduleItemDto
     */
    'endDate': string;
    /**
     * 
     * @type {object}
     * @memberof CourseScheduleItemDto
     */
    'organizer': object | null;
    /**
     * 
     * @type {object}
     * @memberof CourseScheduleItemDto
     */
    'maxScore': object | null;
    /**
     * 
     * @type {object}
     * @memberof CourseScheduleItemDto
     */
    'scoreWeight': object | null;
    /**
     * 
     * @type {string}
     * @memberof CourseScheduleItemDto
     */
    'descriptionUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof CourseScheduleItemDto
     */
    'tag': CourseScheduleItemDtoTagEnum;
}

export const CourseScheduleItemDtoStatusEnum = {
    Done: 'done',
    Available: 'available',
    Archived: 'archived',
    Future: 'future',
    Missed: 'missed',
    Review: 'review'
} as const;

export type CourseScheduleItemDtoStatusEnum = typeof CourseScheduleItemDtoStatusEnum[keyof typeof CourseScheduleItemDtoStatusEnum];
export const CourseScheduleItemDtoTagEnum = {
    Lecture: 'lecture',
    Coding: 'coding',
    SelfStudy: 'self-study',
    Interview: 'interview',
    CrossCheck: 'cross-check',
    Test: 'test'
} as const;

export type CourseScheduleItemDtoTagEnum = typeof CourseScheduleItemDtoTagEnum[keyof typeof CourseScheduleItemDtoTagEnum];

/**
 * 
 * @export
 * @interface CourseScheduleTokenDto
 */
export interface CourseScheduleTokenDto {
    /**
     * 
     * @type {string}
     * @memberof CourseScheduleTokenDto
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface CourseStatsDto
 */
export interface CourseStatsDto {
    /**
     * 
     * @type {number}
     * @memberof CourseStatsDto
     */
    'studentsActiveCount': number;
    /**
     * 
     * @type {number}
     * @memberof CourseStatsDto
     */
    'studentsTotalCount': number;
}
/**
 * 
 * @export
 * @interface CourseTaskDetailedDto
 */
export interface CourseTaskDetailedDto {
    /**
     * 
     * @type {number}
     * @memberof CourseTaskDetailedDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof CourseTaskDetailedDto
     */
    'taskId': number;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'type': CourseTaskDetailedDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'checker': CourseTaskDetailedDtoCheckerEnum;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'studentStartDate': string;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'studentEndDate': string;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'crossCheckEndDate': string | null;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'descriptionUrl': string;
    /**
     * 
     * @type {PersonDto}
     * @memberof CourseTaskDetailedDto
     */
    'taskOwner': PersonDto | null;
    /**
     * 
     * @type {number}
     * @memberof CourseTaskDetailedDto
     */
    'maxScore': number;
    /**
     * 
     * @type {number}
     * @memberof CourseTaskDetailedDto
     */
    'scoreWeight': number;
    /**
     * 
     * @type {number}
     * @memberof CourseTaskDetailedDto
     */
    'pairsCount': number | null;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'crossCheckStatus': string;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'submitText': string | null;
    /**
     * 
     * @type {Validations}
     * @memberof CourseTaskDetailedDto
     */
    'validations': Validations | null;
    /**
     * 
     * @type {object}
     * @memberof CourseTaskDetailedDto
     */
    'publicAttributes': object;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'githubRepoName': string;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDetailedDto
     */
    'sourceGithubRepoUrl': string;
    /**
     * 
     * @type {number}
     * @memberof CourseTaskDetailedDto
     */
    'resultsCount': number;
}

export const CourseTaskDetailedDtoTypeEnum = {
    Jstask: 'jstask',
    Kotlintask: 'kotlintask',
    Objctask: 'objctask',
    Htmltask: 'htmltask',
    Ipynb: 'ipynb',
    Selfeducation: 'selfeducation',
    Codewars: 'codewars',
    Test: 'test',
    Codejam: 'codejam',
    Interview: 'interview',
    StageInterview: 'stage-interview',
    Cvhtml: 'cv:html',
    Cvmarkdown: 'cv:markdown'
} as const;

export type CourseTaskDetailedDtoTypeEnum = typeof CourseTaskDetailedDtoTypeEnum[keyof typeof CourseTaskDetailedDtoTypeEnum];
export const CourseTaskDetailedDtoCheckerEnum = {
    AutoTest: 'auto-test',
    Assigned: 'assigned',
    Mentor: 'mentor',
    TaskOwner: 'taskOwner',
    CrossCheck: 'crossCheck'
} as const;

export type CourseTaskDetailedDtoCheckerEnum = typeof CourseTaskDetailedDtoCheckerEnum[keyof typeof CourseTaskDetailedDtoCheckerEnum];

/**
 * 
 * @export
 * @interface CourseTaskDto
 */
export interface CourseTaskDto {
    /**
     * 
     * @type {number}
     * @memberof CourseTaskDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof CourseTaskDto
     */
    'taskId': number;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDto
     */
    'type': CourseTaskDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDto
     */
    'checker': CourseTaskDtoCheckerEnum;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDto
     */
    'studentStartDate': string;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDto
     */
    'studentEndDate': string;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDto
     */
    'crossCheckEndDate': string | null;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDto
     */
    'descriptionUrl': string;
    /**
     * 
     * @type {PersonDto}
     * @memberof CourseTaskDto
     */
    'taskOwner': PersonDto | null;
    /**
     * 
     * @type {number}
     * @memberof CourseTaskDto
     */
    'maxScore': number;
    /**
     * 
     * @type {number}
     * @memberof CourseTaskDto
     */
    'scoreWeight': number;
    /**
     * 
     * @type {number}
     * @memberof CourseTaskDto
     */
    'pairsCount': number | null;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDto
     */
    'crossCheckStatus': string;
    /**
     * 
     * @type {string}
     * @memberof CourseTaskDto
     */
    'submitText': string | null;
    /**
     * 
     * @type {Validations}
     * @memberof CourseTaskDto
     */
    'validations': Validations | null;
}

export const CourseTaskDtoTypeEnum = {
    Jstask: 'jstask',
    Kotlintask: 'kotlintask',
    Objctask: 'objctask',
    Htmltask: 'htmltask',
    Ipynb: 'ipynb',
    Selfeducation: 'selfeducation',
    Codewars: 'codewars',
    Test: 'test',
    Codejam: 'codejam',
    Interview: 'interview',
    StageInterview: 'stage-interview',
    Cvhtml: 'cv:html',
    Cvmarkdown: 'cv:markdown'
} as const;

export type CourseTaskDtoTypeEnum = typeof CourseTaskDtoTypeEnum[keyof typeof CourseTaskDtoTypeEnum];
export const CourseTaskDtoCheckerEnum = {
    AutoTest: 'auto-test',
    Assigned: 'assigned',
    Mentor: 'mentor',
    TaskOwner: 'taskOwner',
    CrossCheck: 'crossCheck'
} as const;

export type CourseTaskDtoCheckerEnum = typeof CourseTaskDtoCheckerEnum[keyof typeof CourseTaskDtoCheckerEnum];

/**
 * 
 * @export
 * @interface CreateActivityDto
 */
export interface CreateActivityDto {
    /**
     * 
     * @type {boolean}
     * @memberof CreateActivityDto
     */
    'isActive': boolean;
}
/**
 * 
 * @export
 * @interface CreateActivityWebhookDto
 */
export interface CreateActivityWebhookDto {
    /**
     * 
     * @type {SenderDto}
     * @memberof CreateActivityWebhookDto
     */
    'sender': SenderDto;
}
/**
 * 
 * @export
 * @interface CreateAlertDto
 */
export interface CreateAlertDto {
    /**
     * 
     * @type {string}
     * @memberof CreateAlertDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAlertDto
     */
    'text': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAlertDto
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateAlertDto
     */
    'courseId'?: number;
}
/**
 * 
 * @export
 * @interface CreateCourseEventDto
 */
export interface CreateCourseEventDto {
    /**
     * 
     * @type {number}
     * @memberof CreateCourseEventDto
     */
    'eventId': number;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseEventDto
     */
    'special'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseEventDto
     */
    'dateTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateCourseEventDto
     */
    'duration'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseEventDto
     */
    'place'?: string;
    /**
     * 
     * @type {Organizer}
     * @memberof CreateCourseEventDto
     */
    'organizer'?: Organizer;
    /**
     * 
     * @type {number}
     * @memberof CreateCourseEventDto
     */
    'organizerId'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseEventDto
     */
    'broadcastUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseEventDto
     */
    'coordinator'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseEventDto
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface CreateCourseTaskDto
 */
export interface CreateCourseTaskDto {
    /**
     * 
     * @type {number}
     * @memberof CreateCourseTaskDto
     */
    'taskId': number;
    /**
     * 
     * @type {number}
     * @memberof CreateCourseTaskDto
     */
    'maxScore'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateCourseTaskDto
     */
    'scoreWeight'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseTaskDto
     */
    'checker': CreateCourseTaskDtoCheckerEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseTaskDto
     */
    'studentStartDate': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseTaskDto
     */
    'studentEndDate': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseTaskDto
     */
    'crossCheckEndDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateCourseTaskDto
     */
    'taskOwnerId'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateCourseTaskDto
     */
    'pairsCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseTaskDto
     */
    'type': CreateCourseTaskDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseTaskDto
     */
    'submitText': string;
    /**
     * 
     * @type {object}
     * @memberof CreateCourseTaskDto
     */
    'validations': object;
}

export const CreateCourseTaskDtoCheckerEnum = {
    AutoTest: 'auto-test',
    Assigned: 'assigned',
    Mentor: 'mentor',
    TaskOwner: 'taskOwner',
    CrossCheck: 'crossCheck'
} as const;

export type CreateCourseTaskDtoCheckerEnum = typeof CreateCourseTaskDtoCheckerEnum[keyof typeof CreateCourseTaskDtoCheckerEnum];
export const CreateCourseTaskDtoTypeEnum = {
    Jstask: 'jstask',
    Kotlintask: 'kotlintask',
    Objctask: 'objctask',
    Htmltask: 'htmltask',
    Ipynb: 'ipynb',
    Selfeducation: 'selfeducation',
    Codewars: 'codewars',
    Test: 'test',
    Codejam: 'codejam',
    Interview: 'interview',
    StageInterview: 'stage-interview',
    Cvhtml: 'cv:html',
    Cvmarkdown: 'cv:markdown'
} as const;

export type CreateCourseTaskDtoTypeEnum = typeof CreateCourseTaskDtoTypeEnum[keyof typeof CreateCourseTaskDtoTypeEnum];

/**
 * 
 * @export
 * @interface CreateDisciplineDto
 */
export interface CreateDisciplineDto {
    /**
     * 
     * @type {string}
     * @memberof CreateDisciplineDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateDiscordServerDto
 */
export interface CreateDiscordServerDto {
    /**
     * 
     * @type {string}
     * @memberof CreateDiscordServerDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateDiscordServerDto
     */
    'gratitudeUrl': string;
    /**
     * 
     * @type {string}
     * @memberof CreateDiscordServerDto
     */
    'mentorsChatUrl': string;
}
/**
 * 
 * @export
 * @interface CreateGratitudeDto
 */
export interface CreateGratitudeDto {
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateGratitudeDto
     */
    'userIds': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof CreateGratitudeDto
     */
    'courseId': number;
    /**
     * 
     * @type {string}
     * @memberof CreateGratitudeDto
     */
    'comment': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGratitudeDto
     */
    'badgeId': string;
}
/**
 * 
 * @export
 * @interface CreateStudentFeedbackDto
 */
export interface CreateStudentFeedbackDto {
    /**
     * 
     * @type {StudentFeedbackContentDto}
     * @memberof CreateStudentFeedbackDto
     */
    'content': StudentFeedbackContentDto;
    /**
     * 
     * @type {string}
     * @memberof CreateStudentFeedbackDto
     */
    'recommendation': CreateStudentFeedbackDtoRecommendationEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateStudentFeedbackDto
     */
    'englishLevel': CreateStudentFeedbackDtoEnglishLevelEnum;
}

export const CreateStudentFeedbackDtoRecommendationEnum = {
    Hire: 'hire',
    NotHire: 'not-hire'
} as const;

export type CreateStudentFeedbackDtoRecommendationEnum = typeof CreateStudentFeedbackDtoRecommendationEnum[keyof typeof CreateStudentFeedbackDtoRecommendationEnum];
export const CreateStudentFeedbackDtoEnglishLevelEnum = {
    Unknown: 'unknown',
    A0: 'a0',
    A1: 'a1',
    A2: 'a2',
    B1: 'b1',
    B2: 'b2',
    C1: 'c1',
    C2: 'c2'
} as const;

export type CreateStudentFeedbackDtoEnglishLevelEnum = typeof CreateStudentFeedbackDtoEnglishLevelEnum[keyof typeof CreateStudentFeedbackDtoEnglishLevelEnum];

/**
 * 
 * @export
 * @interface CreateUserGroupDto
 */
export interface CreateUserGroupDto {
    /**
     * 
     * @type {string}
     * @memberof CreateUserGroupDto
     */
    'name': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateUserGroupDto
     */
    'users': Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateUserGroupDto
     */
    'roles': Array<string>;
}
/**
 * 
 * @export
 * @interface CrossCheckPairDto
 */
export interface CrossCheckPairDto {
    /**
     * 
     * @type {PersonDto}
     * @memberof CrossCheckPairDto
     */
    'student': PersonDto;
    /**
     * 
     * @type {PersonDto}
     * @memberof CrossCheckPairDto
     */
    'checker': PersonDto;
    /**
     * 
     * @type {IdNameDto}
     * @memberof CrossCheckPairDto
     */
    'task': IdNameDto;
    /**
     * 
     * @type {number}
     * @memberof CrossCheckPairDto
     */
    'score': number;
    /**
     * 
     * @type {number}
     * @memberof CrossCheckPairDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CrossCheckPairDto
     */
    'comment': string;
    /**
     * 
     * @type {string}
     * @memberof CrossCheckPairDto
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof CrossCheckPairDto
     */
    'reviewedDate': string;
    /**
     * 
     * @type {string}
     * @memberof CrossCheckPairDto
     */
    'submittedDate': string;
}
/**
 * 
 * @export
 * @interface CrossCheckPairResponseDto
 */
export interface CrossCheckPairResponseDto {
    /**
     * 
     * @type {Array<CrossCheckPairDto>}
     * @memberof CrossCheckPairResponseDto
     */
    'items': Array<CrossCheckPairDto>;
    /**
     * 
     * @type {PaginationDto}
     * @memberof CrossCheckPairResponseDto
     */
    'pagination': PaginationDto;
}
/**
 * 
 * @export
 * @interface DisciplineDto
 */
export interface DisciplineDto {
    /**
     * 
     * @type {string}
     * @memberof DisciplineDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof DisciplineDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DisciplineDto
     */
    'createdDate': string;
    /**
     * 
     * @type {string}
     * @memberof DisciplineDto
     */
    'updatedDate': string;
}
/**
 * 
 * @export
 * @interface Discord
 */
export interface Discord {
    /**
     * 
     * @type {string}
     * @memberof Discord
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Discord
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof Discord
     */
    'discriminator': string;
}
/**
 * 
 * @export
 * @interface DiscordServerDto
 */
export interface DiscordServerDto {
    /**
     * 
     * @type {number}
     * @memberof DiscordServerDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof DiscordServerDto
     */
    'createdDate': number;
    /**
     * 
     * @type {number}
     * @memberof DiscordServerDto
     */
    'updatedDate': number;
    /**
     * 
     * @type {string}
     * @memberof DiscordServerDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DiscordServerDto
     */
    'gratitudeUrl': string;
    /**
     * 
     * @type {string}
     * @memberof DiscordServerDto
     */
    'mentorsChatUrl': string | null;
}
/**
 * 
 * @export
 * @interface Education
 */
export interface Education {
    /**
     * 
     * @type {string}
     * @memberof Education
     */
    'university': string;
    /**
     * 
     * @type {string}
     * @memberof Education
     */
    'faculty': string;
    /**
     * 
     * @type {number}
     * @memberof Education
     */
    'graduationYear': number;
}
/**
 * 
 * @export
 * @interface FeedbackCourseDto
 */
export interface FeedbackCourseDto {
    /**
     * 
     * @type {string}
     * @memberof FeedbackCourseDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof FeedbackCourseDto
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface FeedbackDto
 */
export interface FeedbackDto {
    /**
     * 
     * @type {string}
     * @memberof FeedbackDto
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof FeedbackDto
     */
    'recommendation': string;
    /**
     * 
     * @type {string}
     * @memberof FeedbackDto
     */
    'englishLevel': string;
    /**
     * 
     * @type {string}
     * @memberof FeedbackDto
     */
    'recommendationComment': string;
    /**
     * 
     * @type {string}
     * @memberof FeedbackDto
     */
    'suggestions': string;
    /**
     * 
     * @type {Array<FeedbackSoftSkill>}
     * @memberof FeedbackDto
     */
    'softSkills': Array<FeedbackSoftSkill>;
    /**
     * 
     * @type {ResumeCourseMentor}
     * @memberof FeedbackDto
     */
    'mentor': ResumeCourseMentor;
    /**
     * 
     * @type {FeedbackCourseDto}
     * @memberof FeedbackDto
     */
    'course': FeedbackCourseDto;
}
/**
 * 
 * @export
 * @interface FeedbackSoftSkill
 */
export interface FeedbackSoftSkill {
    /**
     * 
     * @type {string}
     * @memberof FeedbackSoftSkill
     */
    'value': FeedbackSoftSkillValueEnum;
    /**
     * 
     * @type {string}
     * @memberof FeedbackSoftSkill
     */
    'id': FeedbackSoftSkillIdEnum;
}

export const FeedbackSoftSkillValueEnum = {
    None: 'None',
    Poor: 'Poor',
    Fair: 'Fair',
    Good: 'Good',
    Great: 'Great',
    Excellent: 'Excellent'
} as const;

export type FeedbackSoftSkillValueEnum = typeof FeedbackSoftSkillValueEnum[keyof typeof FeedbackSoftSkillValueEnum];
export const FeedbackSoftSkillIdEnum = {
    Responsible: 'skill.soft.responsible',
    TeamPlayer: 'skill.soft.team-player',
    Communicable: 'skill.soft.communicable'
} as const;

export type FeedbackSoftSkillIdEnum = typeof FeedbackSoftSkillIdEnum[keyof typeof FeedbackSoftSkillIdEnum];

/**
 * 
 * @export
 * @interface GeneralInfo
 */
export interface GeneralInfo {
    /**
     * 
     * @type {string}
     * @memberof GeneralInfo
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GeneralInfo
     */
    'githubId': string;
    /**
     * 
     * @type {string}
     * @memberof GeneralInfo
     */
    'aboutMyself'?: string | null;
    /**
     * 
     * @type {Location}
     * @memberof GeneralInfo
     */
    'location': Location;
    /**
     * 
     * @type {Array<Education>}
     * @memberof GeneralInfo
     */
    'educationHistory'?: Array<Education> | null;
    /**
     * 
     * @type {string}
     * @memberof GeneralInfo
     */
    'englishLevel'?: string | null;
}
/**
 * 
 * @export
 * @interface GratitudeDto
 */
export interface GratitudeDto {
    /**
     * 
     * @type {PersonDto}
     * @memberof GratitudeDto
     */
    'user': PersonDto;
    /**
     * 
     * @type {number}
     * @memberof GratitudeDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GratitudeDto
     */
    'badgeId': GratitudeDtoBadgeIdEnum;
    /**
     * 
     * @type {string}
     * @memberof GratitudeDto
     */
    'comment': string;
    /**
     * 
     * @type {number}
     * @memberof GratitudeDto
     */
    'courseId': number;
    /**
     * 
     * @type {string}
     * @memberof GratitudeDto
     */
    'date': string;
}

export const GratitudeDtoBadgeIdEnum = {
    Congratulations: 'Congratulations',
    ExpertHelp: 'Expert_help',
    GreatSpeaker: 'Great_speaker',
    GoodJob: 'Good_job',
    HelpingHand: 'Helping_hand',
    Hero: 'Hero',
    ThankYou: 'Thank_you',
    OutstandingWork: 'Outstanding_work',
    TopPerformer: 'Top_performer',
    JobOffer: 'Job_Offer',
    RsActivist: 'RS_activist'
} as const;

export type GratitudeDtoBadgeIdEnum = typeof GratitudeDtoBadgeIdEnum[keyof typeof GratitudeDtoBadgeIdEnum];

/**
 * 
 * @export
 * @interface IdNameDto
 */
export interface IdNameDto {
    /**
     * 
     * @type {string}
     * @memberof IdNameDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof IdNameDto
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface InterviewDto
 */
export interface InterviewDto {
    /**
     * 
     * @type {number}
     * @memberof InterviewDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof InterviewDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof InterviewDto
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof InterviewDto
     */
    'startDate': object;
    /**
     * 
     * @type {object}
     * @memberof InterviewDto
     */
    'attributes': object;
}
/**
 * 
 * @export
 * @interface LeaveCourseRequestDto
 */
export interface LeaveCourseRequestDto {
    /**
     * 
     * @type {string}
     * @memberof LeaveCourseRequestDto
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'cityName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'countryName'?: string | null;
}
/**
 * 
 * @export
 * @interface MentorDto
 */
export interface MentorDto {
    /**
     * 
     * @type {number}
     * @memberof MentorDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof MentorDto
     */
    'githubId': string;
    /**
     * 
     * @type {string}
     * @memberof MentorDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface MentorStudentDto
 */
export interface MentorStudentDto {
    /**
     * 
     * @type {string}
     * @memberof MentorStudentDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MentorStudentDto
     */
    'githubId': string;
    /**
     * 
     * @type {number}
     * @memberof MentorStudentDto
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof MentorStudentDto
     */
    'active': boolean;
    /**
     * 
     * @type {string}
     * @memberof MentorStudentDto
     */
    'cityName': string | null;
    /**
     * 
     * @type {string}
     * @memberof MentorStudentDto
     */
    'countryName': string | null;
    /**
     * 
     * @type {number}
     * @memberof MentorStudentDto
     */
    'totalScore': number;
    /**
     * 
     * @type {number}
     * @memberof MentorStudentDto
     */
    'rank': number;
    /**
     * 
     * @type {Array<StudentFeedback>}
     * @memberof MentorStudentDto
     */
    'feedbacks': Array<StudentFeedback>;
    /**
     * 
     * @type {string}
     * @memberof MentorStudentDto
     */
    'repoUrl': string | null;
}
/**
 * 
 * @export
 * @interface NotificationConnectionDto
 */
export interface NotificationConnectionDto {
    /**
     * 
     * @type {string}
     * @memberof NotificationConnectionDto
     */
    'channelId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationConnectionDto
     */
    'externalId': string;
    /**
     * 
     * @type {number}
     * @memberof NotificationConnectionDto
     */
    'userId': number;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationConnectionDto
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface NotificationConnectionExistsDto
 */
export interface NotificationConnectionExistsDto {
    /**
     * 
     * @type {string}
     * @memberof NotificationConnectionExistsDto
     */
    'channelId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationConnectionExistsDto
     */
    'externalId'?: string;
    /**
     * 
     * @type {number}
     * @memberof NotificationConnectionExistsDto
     */
    'userId'?: number;
}
/**
 * 
 * @export
 * @interface NotificationDto
 */
export interface NotificationDto {
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {NotificationType}
     * @memberof NotificationDto
     */
    'type': NotificationType;
    /**
     * 
     * @type {Array<ChannelSettings>}
     * @memberof NotificationDto
     */
    'channels': Array<ChannelSettings>;
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    'parentId': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationType = {
    Event: 'event',
    Message: 'message'
} as const;

export type NotificationType = typeof NotificationType[keyof typeof NotificationType];


/**
 * 
 * @export
 * @interface NotificationUserConnectionsDto
 */
export interface NotificationUserConnectionsDto {
    /**
     * 
     * @type {object}
     * @memberof NotificationUserConnectionsDto
     */
    'connections': object;
}
/**
 * 
 * @export
 * @interface NotificationUserSettingsDto
 */
export interface NotificationUserSettingsDto {
    /**
     * 
     * @type {string}
     * @memberof NotificationUserSettingsDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationUserSettingsDto
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationUserSettingsDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {object}
     * @memberof NotificationUserSettingsDto
     */
    'settings': object;
}
/**
 * 
 * @export
 * @interface Organizer
 */
export interface Organizer {
    /**
     * 
     * @type {number}
     * @memberof Organizer
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface PaginationDto
 */
export interface PaginationDto {
    /**
     * 
     * @type {number}
     * @memberof PaginationDto
     */
    'pageSize': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationDto
     */
    'current': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationDto
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationDto
     */
    'totalPages': number;
}
/**
 * 
 * @export
 * @interface PaginationMetaDto
 */
export interface PaginationMetaDto {
    /**
     * 
     * @type {number}
     * @memberof PaginationMetaDto
     */
    'itemCount': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationMetaDto
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationMetaDto
     */
    'current': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationMetaDto
     */
    'pageSize': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationMetaDto
     */
    'totalPages': number;
}
/**
 * 
 * @export
 * @interface PartialStudentVisibilitySettings
 */
export interface PartialStudentVisibilitySettings {
    /**
     * 
     * @type {boolean}
     * @memberof PartialStudentVisibilitySettings
     */
    'all': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PartialStudentVisibilitySettings
     */
    'student': boolean;
}
/**
 * 
 * @export
 * @interface PersonDto
 */
export interface PersonDto {
    /**
     * 
     * @type {string}
     * @memberof PersonDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PersonDto
     */
    'githubId': string;
    /**
     * 
     * @type {number}
     * @memberof PersonDto
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface ProfileCourseDto
 */
export interface ProfileCourseDto {
    /**
     * 
     * @type {number}
     * @memberof ProfileCourseDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'createdDate': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'updatedDate': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'alias': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'descriptionUrl': string;
    /**
     * 
     * @type {number}
     * @memberof ProfileCourseDto
     */
    'year': number;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'endDate': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'registrationEndDate': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'primarySkillId': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'primarySkillName': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'locationName': string;
    /**
     * 
     * @type {number}
     * @memberof ProfileCourseDto
     */
    'discordServerId': number;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileCourseDto
     */
    'completed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileCourseDto
     */
    'planned': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileCourseDto
     */
    'inviteOnly': boolean;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'certificateIssuer': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileCourseDto
     */
    'usePrivateRepositories': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileCourseDto
     */
    'personalMentoring': boolean;
    /**
     * 
     * @type {string}
     * @memberof ProfileCourseDto
     */
    'logo': string;
    /**
     * 
     * @type {IdNameDto}
     * @memberof ProfileCourseDto
     */
    'discipline': IdNameDto | null;
}
/**
 * 
 * @export
 * @interface ProfileDto
 */
export interface ProfileDto {
    /**
     * 
     * @type {string}
     * @memberof ProfileDto
     */
    'publicCvUrl': string | null;
}
/**
 * 
 * @export
 * @interface ProfileInfoDto
 */
export interface ProfileInfoDto {
    /**
     * 
     * @type {ConfigurableProfilePermissions}
     * @memberof ProfileInfoDto
     */
    'permissionsSettings': ConfigurableProfilePermissions;
    /**
     * 
     * @type {GeneralInfo}
     * @memberof ProfileInfoDto
     */
    'generalInfo': GeneralInfo;
    /**
     * 
     * @type {ContactsDto}
     * @memberof ProfileInfoDto
     */
    'contacts': ContactsDto;
    /**
     * 
     * @type {Discord}
     * @memberof ProfileInfoDto
     */
    'discord'?: Discord | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileInfoDto
     */
    'isPermissionsSettingsChanged': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileInfoDto
     */
    'isProfileSettingsChanged': boolean;
}
/**
 * 
 * @export
 * @interface PublicVisibilitySettings
 */
export interface PublicVisibilitySettings {
    /**
     * 
     * @type {boolean}
     * @memberof PublicVisibilitySettings
     */
    'all': boolean;
}
/**
 * 
 * @export
 * @interface ResumeCourseDto
 */
export interface ResumeCourseDto {
    /**
     * 
     * @type {number}
     * @memberof ResumeCourseDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ResumeCourseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeCourseDto
     */
    'fullName': string;
    /**
     * 
     * @type {number}
     * @memberof ResumeCourseDto
     */
    'rank': number;
    /**
     * 
     * @type {number}
     * @memberof ResumeCourseDto
     */
    'totalScore': number;
    /**
     * 
     * @type {string}
     * @memberof ResumeCourseDto
     */
    'certificateId': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ResumeCourseDto
     */
    'completed': boolean;
    /**
     * 
     * @type {ResumeCourseMentor}
     * @memberof ResumeCourseDto
     */
    'mentor': ResumeCourseMentor | null;
    /**
     * 
     * @type {string}
     * @memberof ResumeCourseDto
     */
    'locationName': string;
}
/**
 * 
 * @export
 * @interface ResumeCourseMentor
 */
export interface ResumeCourseMentor {
    /**
     * 
     * @type {string}
     * @memberof ResumeCourseMentor
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeCourseMentor
     */
    'githubId': string;
    /**
     * 
     * @type {number}
     * @memberof ResumeCourseMentor
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface ResumeDto
 */
export interface ResumeDto {
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'avatarLink': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ResumeDto
     */
    'visibleCourses': Array<number>;
    /**
     * 
     * @type {Array<ResumeCourseDto>}
     * @memberof ResumeDto
     */
    'courses': Array<ResumeCourseDto>;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'desiredPosition': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'englishLevel': ResumeDtoEnglishLevelEnum;
    /**
     * 
     * @type {number}
     * @memberof ResumeDto
     */
    'expires': number;
    /**
     * 
     * @type {Array<GratitudeDto>}
     * @memberof ResumeDto
     */
    'gratitudes': Array<GratitudeDto>;
    /**
     * 
     * @type {Array<FeedbackDto>}
     * @memberof ResumeDto
     */
    'feedbacks': Array<FeedbackDto>;
    /**
     * 
     * @type {boolean}
     * @memberof ResumeDto
     */
    'fullTime': boolean;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'githubUsername': string;
    /**
     * 
     * @type {number}
     * @memberof ResumeDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'linkedin': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'locations': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'militaryService': ResumeDtoMilitaryServiceEnum;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'notes': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'selfIntroLink': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'skype': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'startFrom': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'telegram': string;
    /**
     * 
     * @type {string}
     * @memberof ResumeDto
     */
    'website': string;
}

export const ResumeDtoEnglishLevelEnum = {
    Unknown: 'unknown',
    A0: 'a0',
    A1: 'a1',
    A2: 'a2',
    B1: 'b1',
    B2: 'b2',
    C1: 'c1',
    C2: 'c2'
} as const;

export type ResumeDtoEnglishLevelEnum = typeof ResumeDtoEnglishLevelEnum[keyof typeof ResumeDtoEnglishLevelEnum];
export const ResumeDtoMilitaryServiceEnum = {
    Served: 'served',
    Liable: 'liable',
    NotLiable: 'notLiable'
} as const;

export type ResumeDtoMilitaryServiceEnum = typeof ResumeDtoMilitaryServiceEnum[keyof typeof ResumeDtoMilitaryServiceEnum];

/**
 * 
 * @export
 * @interface SaveCertificateDto
 */
export interface SaveCertificateDto {
    /**
     * 
     * @type {string}
     * @memberof SaveCertificateDto
     */
    'publicId': string;
    /**
     * 
     * @type {number}
     * @memberof SaveCertificateDto
     */
    'studentId': number;
    /**
     * 
     * @type {string}
     * @memberof SaveCertificateDto
     */
    's3Bucket': string;
    /**
     * 
     * @type {string}
     * @memberof SaveCertificateDto
     */
    's3Key': string;
    /**
     * 
     * @type {string}
     * @memberof SaveCertificateDto
     */
    'issueDate': string;
}
/**
 * 
 * @export
 * @interface SaveTaskSolutionDto
 */
export interface SaveTaskSolutionDto {
    /**
     * 
     * @type {string}
     * @memberof SaveTaskSolutionDto
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface ScoreDto
 */
export interface ScoreDto {
    /**
     * 
     * @type {Array<ScoreStudentDto>}
     * @memberof ScoreDto
     */
    'content': Array<ScoreStudentDto>;
    /**
     * 
     * @type {PaginationMetaDto}
     * @memberof ScoreDto
     */
    'pagination': PaginationMetaDto;
}
/**
 * 
 * @export
 * @interface ScoreStudentDto
 */
export interface ScoreStudentDto {
    /**
     * 
     * @type {string}
     * @memberof ScoreStudentDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ScoreStudentDto
     */
    'githubId': string;
    /**
     * 
     * @type {number}
     * @memberof ScoreStudentDto
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof ScoreStudentDto
     */
    'active': boolean;
    /**
     * 
     * @type {string}
     * @memberof ScoreStudentDto
     */
    'cityName': string | null;
    /**
     * 
     * @type {string}
     * @memberof ScoreStudentDto
     */
    'countryName': string | null;
    /**
     * 
     * @type {number}
     * @memberof ScoreStudentDto
     */
    'totalScore': number;
    /**
     * 
     * @type {number}
     * @memberof ScoreStudentDto
     */
    'rank': number;
    /**
     * 
     * @type {MentorDto}
     * @memberof ScoreStudentDto
     */
    'mentor': MentorDto | null;
    /**
     * 
     * @type {string}
     * @memberof ScoreStudentDto
     */
    'totalScoreChangeDate': string;
    /**
     * 
     * @type {number}
     * @memberof ScoreStudentDto
     */
    'crossCheckScore': number;
    /**
     * 
     * @type {string}
     * @memberof ScoreStudentDto
     */
    'repositoryLastActivityDate': string;
    /**
     * 
     * @type {Array<TaskResultsDto>}
     * @memberof ScoreStudentDto
     */
    'taskResults': Array<TaskResultsDto>;
    /**
     * 
     * @type {boolean}
     * @memberof ScoreStudentDto
     */
    'isActive': boolean;
    /**
     * 
     * @type {ContactsDto}
     * @memberof ScoreStudentDto
     */
    'contacts': ContactsDto;
}
/**
 * 
 * @export
 * @interface SendUserNotificationDto
 */
export interface SendUserNotificationDto {
    /**
     * 
     * @type {string}
     * @memberof SendUserNotificationDto
     */
    'notificationId': string;
    /**
     * 
     * @type {number}
     * @memberof SendUserNotificationDto
     */
    'userId': number;
    /**
     * 
     * @type {object}
     * @memberof SendUserNotificationDto
     */
    'data': object;
    /**
     * 
     * @type {number}
     * @memberof SendUserNotificationDto
     */
    'expireDate': number;
}
/**
 * 
 * @export
 * @interface SenderDto
 */
export interface SenderDto {
    /**
     * 
     * @type {SenderLoginDto}
     * @memberof SenderDto
     */
    'login': SenderLoginDto;
}
/**
 * 
 * @export
 * @interface SenderLoginDto
 */
export interface SenderLoginDto {
    /**
     * 
     * @type {string}
     * @memberof SenderLoginDto
     */
    'githubId': string;
}
/**
 * 
 * @export
 * @interface SoftSkillEntry
 */
export interface SoftSkillEntry {
    /**
     * 
     * @type {string}
     * @memberof SoftSkillEntry
     */
    'id': SoftSkillEntryIdEnum;
    /**
     * 
     * @type {string}
     * @memberof SoftSkillEntry
     */
    'value': SoftSkillEntryValueEnum;
}

export const SoftSkillEntryIdEnum = {
    Responsible: 'skill.soft.responsible',
    TeamPlayer: 'skill.soft.team-player',
    Communicable: 'skill.soft.communicable'
} as const;

export type SoftSkillEntryIdEnum = typeof SoftSkillEntryIdEnum[keyof typeof SoftSkillEntryIdEnum];
export const SoftSkillEntryValueEnum = {
    None: 'None',
    Poor: 'Poor',
    Fair: 'Fair',
    Good: 'Good',
    Great: 'Great',
    Excellent: 'Excellent'
} as const;

export type SoftSkillEntryValueEnum = typeof SoftSkillEntryValueEnum[keyof typeof SoftSkillEntryValueEnum];

/**
 * 
 * @export
 * @interface StudentDto
 */
export interface StudentDto {
    /**
     * 
     * @type {string}
     * @memberof StudentDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof StudentDto
     */
    'githubId': string;
    /**
     * 
     * @type {number}
     * @memberof StudentDto
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof StudentDto
     */
    'active': boolean;
    /**
     * 
     * @type {string}
     * @memberof StudentDto
     */
    'cityName': string | null;
    /**
     * 
     * @type {string}
     * @memberof StudentDto
     */
    'countryName': string | null;
    /**
     * 
     * @type {number}
     * @memberof StudentDto
     */
    'totalScore': number;
    /**
     * 
     * @type {number}
     * @memberof StudentDto
     */
    'rank': number;
}
/**
 * 
 * @export
 * @interface StudentFeedback
 */
export interface StudentFeedback {
    /**
     * 
     * @type {number}
     * @memberof StudentFeedback
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface StudentFeedbackContentDto
 */
export interface StudentFeedbackContentDto {
    /**
     * 
     * @type {string}
     * @memberof StudentFeedbackContentDto
     */
    'suggestions': string;
    /**
     * 
     * @type {string}
     * @memberof StudentFeedbackContentDto
     */
    'recommendationComment': string;
    /**
     * 
     * @type {Array<SoftSkillEntry>}
     * @memberof StudentFeedbackContentDto
     */
    'softSkills': Array<SoftSkillEntry>;
}
/**
 * 
 * @export
 * @interface StudentFeedbackDto
 */
export interface StudentFeedbackDto {
    /**
     * 
     * @type {number}
     * @memberof StudentFeedbackDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof StudentFeedbackDto
     */
    'createdDate': string;
    /**
     * 
     * @type {string}
     * @memberof StudentFeedbackDto
     */
    'updatedDate': string;
    /**
     * 
     * @type {StudentFeedbackContentDto}
     * @memberof StudentFeedbackDto
     */
    'content': StudentFeedbackContentDto;
    /**
     * 
     * @type {string}
     * @memberof StudentFeedbackDto
     */
    'recommendation': StudentFeedbackDtoRecommendationEnum;
    /**
     * 
     * @type {PersonDto}
     * @memberof StudentFeedbackDto
     */
    'author': PersonDto;
    /**
     * 
     * @type {PersonDto}
     * @memberof StudentFeedbackDto
     */
    'mentor': PersonDto | null;
    /**
     * 
     * @type {string}
     * @memberof StudentFeedbackDto
     */
    'englishLevel': StudentFeedbackDtoEnglishLevelEnum;
}

export const StudentFeedbackDtoRecommendationEnum = {
    Hire: 'hire',
    NotHire: 'not-hire'
} as const;

export type StudentFeedbackDtoRecommendationEnum = typeof StudentFeedbackDtoRecommendationEnum[keyof typeof StudentFeedbackDtoRecommendationEnum];
export const StudentFeedbackDtoEnglishLevelEnum = {
    Unknown: 'unknown',
    A0: 'a0',
    A1: 'a1',
    A2: 'a2',
    B1: 'b1',
    B2: 'b2',
    C1: 'c1',
    C2: 'c2'
} as const;

export type StudentFeedbackDtoEnglishLevelEnum = typeof StudentFeedbackDtoEnglishLevelEnum[keyof typeof StudentFeedbackDtoEnglishLevelEnum];

/**
 * 
 * @export
 * @interface TaskResultsDto
 */
export interface TaskResultsDto {
    /**
     * 
     * @type {number}
     * @memberof TaskResultsDto
     */
    'courseTaskId': number;
    /**
     * 
     * @type {number}
     * @memberof TaskResultsDto
     */
    'score': number;
}
/**
 * 
 * @export
 * @interface TaskSolutionDto
 */
export interface TaskSolutionDto {
    /**
     * 
     * @type {number}
     * @memberof TaskSolutionDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof TaskSolutionDto
     */
    'courseTaskId': number;
    /**
     * 
     * @type {string}
     * @memberof TaskSolutionDto
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface UpdateCourseDto
 */
export interface UpdateCourseDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseDto
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseDto
     */
    'alias': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseDto
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateCourseDto
     */
    'year'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseDto
     */
    'startDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseDto
     */
    'endDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseDto
     */
    'registrationEndDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseDto
     */
    'locationName'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateCourseDto
     */
    'discordServerId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCourseDto
     */
    'completed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCourseDto
     */
    'planned'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCourseDto
     */
    'inviteOnly'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseDto
     */
    'certificateIssuer'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCourseDto
     */
    'usePrivateRepositories'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCourseDto
     */
    'personalMentoring'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseDto
     */
    'logo'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateCourseDto
     */
    'disciplineId'?: number;
}
/**
 * 
 * @export
 * @interface UpdateCourseEventDto
 */
export interface UpdateCourseEventDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseEventDto
     */
    'special'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseEventDto
     */
    'dateTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateCourseEventDto
     */
    'duration'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseEventDto
     */
    'place'?: string;
    /**
     * 
     * @type {Organizer}
     * @memberof UpdateCourseEventDto
     */
    'organizer'?: Organizer;
    /**
     * 
     * @type {number}
     * @memberof UpdateCourseEventDto
     */
    'organizerId'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseEventDto
     */
    'broadcastUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseEventDto
     */
    'coordinator'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseEventDto
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface UpdateCourseTaskDto
 */
export interface UpdateCourseTaskDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseTaskDto
     */
    'type'?: UpdateCourseTaskDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseTaskDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseTaskDto
     */
    'checker'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseTaskDto
     */
    'studentStartDate': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseTaskDto
     */
    'studentEndDate': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseTaskDto
     */
    'descriptionUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateCourseTaskDto
     */
    'taskOwnerId'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateCourseTaskDto
     */
    'maxScore'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateCourseTaskDto
     */
    'scoreWeight'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateCourseTaskDto
     */
    'pairsCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateCourseTaskDto
     */
    'taskId'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseTaskDto
     */
    'crossCheckEndDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseTaskDto
     */
    'submitText': string;
    /**
     * 
     * @type {object}
     * @memberof UpdateCourseTaskDto
     */
    'validations': object;
}

export const UpdateCourseTaskDtoTypeEnum = {
    Jstask: 'jstask',
    Kotlintask: 'kotlintask',
    Objctask: 'objctask',
    Htmltask: 'htmltask',
    Ipynb: 'ipynb',
    Selfeducation: 'selfeducation',
    Codewars: 'codewars',
    Test: 'test',
    Codejam: 'codejam',
    Interview: 'interview',
    StageInterview: 'stage-interview',
    Cvhtml: 'cv:html',
    Cvmarkdown: 'cv:markdown'
} as const;

export type UpdateCourseTaskDtoTypeEnum = typeof UpdateCourseTaskDtoTypeEnum[keyof typeof UpdateCourseTaskDtoTypeEnum];

/**
 * 
 * @export
 * @interface UpdateDisciplineDto
 */
export interface UpdateDisciplineDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateDisciplineDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UpdateDiscordServerDto
 */
export interface UpdateDiscordServerDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateDiscordServerDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDiscordServerDto
     */
    'gratitudeUrl': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDiscordServerDto
     */
    'mentorsChatUrl': string;
}
/**
 * 
 * @export
 * @interface UpdateNotificationDto
 */
export interface UpdateNotificationDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationDto
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateNotificationDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {Array<ChannelSettings>}
     * @memberof UpdateNotificationDto
     */
    'channels': Array<ChannelSettings>;
    /**
     * 
     * @type {NotificationType}
     * @memberof UpdateNotificationDto
     */
    'type': NotificationType;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationDto
     */
    'parentId': string;
}
/**
 * 
 * @export
 * @interface UpdateNotificationUserSettingsDto
 */
export interface UpdateNotificationUserSettingsDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationUserSettingsDto
     */
    'notificationId': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateNotificationUserSettingsDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationUserSettingsDto
     */
    'channelId': string;
}
/**
 * 
 * @export
 * @interface UpdateProfileInfoDto
 */
export interface UpdateProfileInfoDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'githubId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'aboutMyself'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'cityName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'countryName'?: string | null;
    /**
     * 
     * @type {Array<Education>}
     * @memberof UpdateProfileInfoDto
     */
    'educationHistory'?: Array<Education> | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'englishLevel'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'contactsPhone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'contactsEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'contactsEpamEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'contactsSkype'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'contactsTelegram'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'contactsNotes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileInfoDto
     */
    'contactsLinkedIn'?: string | null;
    /**
     * 
     * @type {Discord}
     * @memberof UpdateProfileInfoDto
     */
    'discord'?: Discord | null;
}
/**
 * 
 * @export
 * @interface UpdateStudentFeedbackDto
 */
export interface UpdateStudentFeedbackDto {
    /**
     * 
     * @type {StudentFeedbackContentDto}
     * @memberof UpdateStudentFeedbackDto
     */
    'content': StudentFeedbackContentDto;
    /**
     * 
     * @type {string}
     * @memberof UpdateStudentFeedbackDto
     */
    'recommendation': UpdateStudentFeedbackDtoRecommendationEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateStudentFeedbackDto
     */
    'englishLevel': UpdateStudentFeedbackDtoEnglishLevelEnum;
}

export const UpdateStudentFeedbackDtoRecommendationEnum = {
    Hire: 'hire',
    NotHire: 'not-hire'
} as const;

export type UpdateStudentFeedbackDtoRecommendationEnum = typeof UpdateStudentFeedbackDtoRecommendationEnum[keyof typeof UpdateStudentFeedbackDtoRecommendationEnum];
export const UpdateStudentFeedbackDtoEnglishLevelEnum = {
    Unknown: 'unknown',
    A0: 'a0',
    A1: 'a1',
    A2: 'a2',
    B1: 'b1',
    B2: 'b2',
    C1: 'c1',
    C2: 'c2'
} as const;

export type UpdateStudentFeedbackDtoEnglishLevelEnum = typeof UpdateStudentFeedbackDtoEnglishLevelEnum[keyof typeof UpdateStudentFeedbackDtoEnglishLevelEnum];

/**
 * 
 * @export
 * @interface UpdateUserDto
 */
export interface UpdateUserDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'firstName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'lastName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'primaryEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'cityName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'countryName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'contactsNotes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'contactsPhone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'contactsEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'contactsEpamEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'contactsSkype'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'contactsTelegram'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'contactsLinkedIn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'notes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'aboutMyself'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateUserGroupDto
 */
export interface UpdateUserGroupDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserGroupDto
     */
    'name': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateUserGroupDto
     */
    'users': Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateUserGroupDto
     */
    'roles': Array<string>;
}
/**
 * 
 * @export
 * @interface UpsertNotificationConnectionDto
 */
export interface UpsertNotificationConnectionDto {
    /**
     * 
     * @type {string}
     * @memberof UpsertNotificationConnectionDto
     */
    'channelId': string;
    /**
     * 
     * @type {string}
     * @memberof UpsertNotificationConnectionDto
     */
    'externalId': string;
    /**
     * 
     * @type {number}
     * @memberof UpsertNotificationConnectionDto
     */
    'userId': number;
    /**
     * 
     * @type {boolean}
     * @memberof UpsertNotificationConnectionDto
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * 
     * @type {number}
     * @memberof UserDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'githubId': string;
}
/**
 * 
 * @export
 * @interface UserGroupDto
 */
export interface UserGroupDto {
    /**
     * 
     * @type {number}
     * @memberof UserGroupDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserGroupDto
     */
    'name': string;
    /**
     * 
     * @type {Array<UserDto>}
     * @memberof UserGroupDto
     */
    'users': Array<UserDto>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserGroupDto
     */
    'roles': Array<string>;
}
/**
 * 
 * @export
 * @interface UserNotificationsDto
 */
export interface UserNotificationsDto {
    /**
     * 
     * @type {Array<NotificationUserSettingsDto>}
     * @memberof UserNotificationsDto
     */
    'notifications': Array<NotificationUserSettingsDto>;
    /**
     * 
     * @type {object}
     * @memberof UserNotificationsDto
     */
    'connections': object;
}
/**
 * 
 * @export
 * @interface Validations
 */
export interface Validations {
    /**
     * 
     * @type {boolean}
     * @memberof Validations
     */
    'githubIdInUrl': boolean;
}
/**
 * 
 * @export
 * @interface VisibilitySettings
 */
export interface VisibilitySettings {
    /**
     * 
     * @type {boolean}
     * @memberof VisibilitySettings
     */
    'all': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VisibilitySettings
     */
    'mentor': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VisibilitySettings
     */
    'student': boolean;
}

/**
 * ActivityApi - axios parameter creator
 * @export
 */
export const ActivityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateActivityDto} createActivityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActivity: async (createActivityDto: CreateActivityDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createActivityDto' is not null or undefined
            assertParamExists('createActivity', 'createActivityDto', createActivityDto)
            const localVarPath = `/activity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createActivityDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateActivityWebhookDto} createActivityWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActivityWebhook: async (createActivityWebhookDto: CreateActivityWebhookDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createActivityWebhookDto' is not null or undefined
            assertParamExists('createActivityWebhook', 'createActivityWebhookDto', createActivityWebhookDto)
            const localVarPath = `/activity/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createActivityWebhookDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/activity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityApi - functional programming interface
 * @export
 */
export const ActivityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateActivityDto} createActivityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createActivity(createActivityDto: CreateActivityDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createActivity(createActivityDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateActivityWebhookDto} createActivityWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createActivityWebhook(createActivityWebhookDto: CreateActivityWebhookDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createActivityWebhook(createActivityWebhookDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivity(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivity(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActivityApi - factory interface
 * @export
 */
export const ActivityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivityApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateActivityDto} createActivityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActivity(createActivityDto: CreateActivityDto, options?: any): AxiosPromise<ActivityDto> {
            return localVarFp.createActivity(createActivityDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateActivityWebhookDto} createActivityWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActivityWebhook(createActivityWebhookDto: CreateActivityWebhookDto, options?: any): AxiosPromise<ActivityDto> {
            return localVarFp.createActivityWebhook(createActivityWebhookDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity(options?: any): AxiosPromise<ActivityDto> {
            return localVarFp.getActivity(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivityApi - object-oriented interface
 * @export
 * @class ActivityApi
 * @extends {BaseAPI}
 */
export class ActivityApi extends BaseAPI {
    /**
     * 
     * @param {CreateActivityDto} createActivityDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public createActivity(createActivityDto: CreateActivityDto, options?: AxiosRequestConfig) {
        return ActivityApiFp(this.configuration).createActivity(createActivityDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateActivityWebhookDto} createActivityWebhookDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public createActivityWebhook(createActivityWebhookDto: CreateActivityWebhookDto, options?: AxiosRequestConfig) {
        return ActivityApiFp(this.configuration).createActivityWebhook(createActivityWebhookDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public getActivity(options?: AxiosRequestConfig) {
        return ActivityApiFp(this.configuration).getActivity(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AlertsApi - axios parameter creator
 * @export
 */
export const AlertsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateAlertDto} createAlertDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlert: async (createAlertDto: CreateAlertDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAlertDto' is not null or undefined
            assertParamExists('createAlert', 'createAlertDto', createAlertDto)
            const localVarPath = `/alerts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAlertDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAlert', 'id', id)
            const localVarPath = `/alerts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} enabled 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlerts: async (enabled: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enabled' is not null or undefined
            assertParamExists('getAlerts', 'enabled', enabled)
            const localVarPath = `/alerts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlert: async (id: number, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAlert', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateAlert', 'body', body)
            const localVarPath = `/alerts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertsApi - functional programming interface
 * @export
 */
export const AlertsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlertsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateAlertDto} createAlertDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlert(createAlertDto: CreateAlertDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlert(createAlertDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlert(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlert(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} enabled 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlerts(enabled: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AlertDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlerts(enabled, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAlert(id: number, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAlert(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AlertsApi - factory interface
 * @export
 */
export const AlertsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlertsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateAlertDto} createAlertDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlert(createAlertDto: CreateAlertDto, options?: any): AxiosPromise<AlertDto> {
            return localVarFp.createAlert(createAlertDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAlert(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} enabled 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlerts(enabled: boolean, options?: any): AxiosPromise<Array<AlertDto>> {
            return localVarFp.getAlerts(enabled, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlert(id: number, body: object, options?: any): AxiosPromise<AlertDto> {
            return localVarFp.updateAlert(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
export class AlertsApi extends BaseAPI {
    /**
     * 
     * @param {CreateAlertDto} createAlertDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public createAlert(createAlertDto: CreateAlertDto, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).createAlert(createAlertDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public deleteAlert(id: number, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).deleteAlert(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} enabled 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public getAlerts(enabled: boolean, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).getAlerts(enabled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public updateAlert(id: number, body: object, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).updateAlert(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AuthConnectionDto} authConnectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerCreateConnectLinkViaGithub: async (authConnectionDto: AuthConnectionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authConnectionDto' is not null or undefined
            assertParamExists('authControllerCreateConnectLinkViaGithub', 'authConnectionDto', authConnectionDto)
            const localVarPath = `/auth/github/connect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authConnectionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubCallback: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/github/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubLogin: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/github/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubLogout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/github/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AuthConnectionDto} authConnectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerCreateConnectLinkViaGithub(authConnectionDto: AuthConnectionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerCreateConnectLinkViaGithub(authConnectionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async githubCallback(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.githubCallback(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async githubLogin(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.githubLogin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async githubLogout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.githubLogout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {AuthConnectionDto} authConnectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerCreateConnectLinkViaGithub(authConnectionDto: AuthConnectionDto, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerCreateConnectLinkViaGithub(authConnectionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubCallback(options?: any): AxiosPromise<void> {
            return localVarFp.githubCallback(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubLogin(options?: any): AxiosPromise<void> {
            return localVarFp.githubLogin(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubLogout(options?: any): AxiosPromise<void> {
            return localVarFp.githubLogout(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {AuthConnectionDto} authConnectionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerCreateConnectLinkViaGithub(authConnectionDto: AuthConnectionDto, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerCreateConnectLinkViaGithub(authConnectionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public githubCallback(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).githubCallback(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public githubLogin(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).githubLogin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public githubLogout(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).githubLogout(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CertificateApi - axios parameter creator
 * @export
 */
export const CertificateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} publicId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCertificate: async (publicId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicId' is not null or undefined
            assertParamExists('getCertificate', 'publicId', publicId)
            const localVarPath = `/certificate/{publicId}`
                .replace(`{${"publicId"}}`, encodeURIComponent(String(publicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SaveCertificateDto} saveCertificateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCertificate: async (saveCertificateDto: SaveCertificateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saveCertificateDto' is not null or undefined
            assertParamExists('saveCertificate', 'saveCertificateDto', saveCertificateDto)
            const localVarPath = `/certificate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveCertificateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CertificateApi - functional programming interface
 * @export
 */
export const CertificateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CertificateApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} publicId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCertificate(publicId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCertificate(publicId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SaveCertificateDto} saveCertificateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveCertificate(saveCertificateDto: SaveCertificateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveCertificate(saveCertificateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CertificateApi - factory interface
 * @export
 */
export const CertificateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CertificateApiFp(configuration)
    return {
        /**
         * 
         * @param {string} publicId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCertificate(publicId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getCertificate(publicId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SaveCertificateDto} saveCertificateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCertificate(saveCertificateDto: SaveCertificateDto, options?: any): AxiosPromise<void> {
            return localVarFp.saveCertificate(saveCertificateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CertificateApi - object-oriented interface
 * @export
 * @class CertificateApi
 * @extends {BaseAPI}
 */
export class CertificateApi extends BaseAPI {
    /**
     * 
     * @param {string} publicId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificateApi
     */
    public getCertificate(publicId: string, options?: AxiosRequestConfig) {
        return CertificateApiFp(this.configuration).getCertificate(publicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SaveCertificateDto} saveCertificateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificateApi
     */
    public saveCertificate(saveCertificateDto: SaveCertificateDto, options?: AxiosRequestConfig) {
        return CertificateApiFp(this.configuration).saveCertificate(saveCertificateDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CourseStatsApi - axios parameter creator
 * @export
 */
export const CourseStatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseStats: async (courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getCourseStats', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/stats`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseStatsApi - functional programming interface
 * @export
 */
export const CourseStatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseStatsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseStats(courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseStatsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseStats(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CourseStatsApi - factory interface
 * @export
 */
export const CourseStatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseStatsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseStats(courseId: number, options?: any): AxiosPromise<CourseStatsDto> {
            return localVarFp.getCourseStats(courseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CourseStatsApi - object-oriented interface
 * @export
 * @class CourseStatsApi
 * @extends {BaseAPI}
 */
export class CourseStatsApi extends BaseAPI {
    /**
     * 
     * @param {number} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseStatsApi
     */
    public getCourseStats(courseId: number, options?: AxiosRequestConfig) {
        return CourseStatsApiFp(this.configuration).getCourseStats(courseId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CoursesApi - axios parameter creator
 * @export
 */
export const CoursesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourse: async (courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getCourse', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/courses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} courseId 
         * @param {LeaveCourseRequestDto} [leaveCourseRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveCourse: async (courseId: number, leaveCourseRequestDto?: LeaveCourseRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('leaveCourse', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/leave`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(leaveCourseRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejoinCourse: async (courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('rejoinCourse', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/rejoin`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} courseId 
         * @param {UpdateCourseDto} updateCourseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourse: async (courseId: number, updateCourseDto: UpdateCourseDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('updateCourse', 'courseId', courseId)
            // verify required parameter 'updateCourseDto' is not null or undefined
            assertParamExists('updateCourse', 'updateCourseDto', updateCourseDto)
            const localVarPath = `/courses/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCourseDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoursesApi - functional programming interface
 * @export
 */
export const CoursesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoursesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourse(courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourse(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourses(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CourseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourses(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} courseId 
         * @param {LeaveCourseRequestDto} [leaveCourseRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveCourse(courseId: number, leaveCourseRequestDto?: LeaveCourseRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveCourse(courseId, leaveCourseRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejoinCourse(courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejoinCourse(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} courseId 
         * @param {UpdateCourseDto} updateCourseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCourse(courseId: number, updateCourseDto: UpdateCourseDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCourse(courseId, updateCourseDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CoursesApi - factory interface
 * @export
 */
export const CoursesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoursesApiFp(configuration)
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourse(courseId: number, options?: any): AxiosPromise<CourseDto> {
            return localVarFp.getCourse(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses(options?: any): AxiosPromise<Array<CourseDto>> {
            return localVarFp.getCourses(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} courseId 
         * @param {LeaveCourseRequestDto} [leaveCourseRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveCourse(courseId: number, leaveCourseRequestDto?: LeaveCourseRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.leaveCourse(courseId, leaveCourseRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejoinCourse(courseId: number, options?: any): AxiosPromise<void> {
            return localVarFp.rejoinCourse(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} courseId 
         * @param {UpdateCourseDto} updateCourseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourse(courseId: number, updateCourseDto: UpdateCourseDto, options?: any): AxiosPromise<CourseDto> {
            return localVarFp.updateCourse(courseId, updateCourseDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoursesApi - object-oriented interface
 * @export
 * @class CoursesApi
 * @extends {BaseAPI}
 */
export class CoursesApi extends BaseAPI {
    /**
     * 
     * @param {number} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public getCourse(courseId: number, options?: AxiosRequestConfig) {
        return CoursesApiFp(this.configuration).getCourse(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public getCourses(options?: AxiosRequestConfig) {
        return CoursesApiFp(this.configuration).getCourses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} courseId 
     * @param {LeaveCourseRequestDto} [leaveCourseRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public leaveCourse(courseId: number, leaveCourseRequestDto?: LeaveCourseRequestDto, options?: AxiosRequestConfig) {
        return CoursesApiFp(this.configuration).leaveCourse(courseId, leaveCourseRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public rejoinCourse(courseId: number, options?: AxiosRequestConfig) {
        return CoursesApiFp(this.configuration).rejoinCourse(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} courseId 
     * @param {UpdateCourseDto} updateCourseDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public updateCourse(courseId: number, updateCourseDto: UpdateCourseDto, options?: AxiosRequestConfig) {
        return CoursesApiFp(this.configuration).updateCourse(courseId, updateCourseDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CoursesEventsApi - axios parameter creator
 * @export
 */
export const CoursesEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {CreateCourseEventDto} createCourseEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseEvent: async (courseId: number, createCourseEventDto: CreateCourseEventDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('createCourseEvent', 'courseId', courseId)
            // verify required parameter 'createCourseEventDto' is not null or undefined
            assertParamExists('createCourseEvent', 'createCourseEventDto', createCourseEventDto)
            const localVarPath = `/courses/{courseId}/events`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCourseEventDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} courseEventId 
         * @param {any} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseEvent: async (courseEventId: number, courseId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseEventId' is not null or undefined
            assertParamExists('deleteCourseEvent', 'courseEventId', courseEventId)
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('deleteCourseEvent', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/events/{courseEventId}`
                .replace(`{${"courseEventId"}}`, encodeURIComponent(String(courseEventId)))
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} courseId 
         * @param {number} courseEventId 
         * @param {UpdateCourseEventDto} updateCourseEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseEvent: async (courseId: number, courseEventId: number, updateCourseEventDto: UpdateCourseEventDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('updateCourseEvent', 'courseId', courseId)
            // verify required parameter 'courseEventId' is not null or undefined
            assertParamExists('updateCourseEvent', 'courseEventId', courseEventId)
            // verify required parameter 'updateCourseEventDto' is not null or undefined
            assertParamExists('updateCourseEvent', 'updateCourseEventDto', updateCourseEventDto)
            const localVarPath = `/courses/{courseId}/events/{courseEventId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"courseEventId"}}`, encodeURIComponent(String(courseEventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCourseEventDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoursesEventsApi - functional programming interface
 * @export
 */
export const CoursesEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoursesEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {CreateCourseEventDto} createCourseEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCourseEvent(courseId: number, createCourseEventDto: CreateCourseEventDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CourseEventDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCourseEvent(courseId, createCourseEventDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} courseEventId 
         * @param {any} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCourseEvent(courseEventId: number, courseId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCourseEvent(courseEventId, courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} courseId 
         * @param {number} courseEventId 
         * @param {UpdateCourseEventDto} updateCourseEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCourseEvent(courseId: number, courseEventId: number, updateCourseEventDto: UpdateCourseEventDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCourseEvent(courseId, courseEventId, updateCourseEventDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CoursesEventsApi - factory interface
 * @export
 */
export const CoursesEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoursesEventsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {CreateCourseEventDto} createCourseEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseEvent(courseId: number, createCourseEventDto: CreateCourseEventDto, options?: any): AxiosPromise<Array<CourseEventDto>> {
            return localVarFp.createCourseEvent(courseId, createCourseEventDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} courseEventId 
         * @param {any} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseEvent(courseEventId: number, courseId: any, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCourseEvent(courseEventId, courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} courseId 
         * @param {number} courseEventId 
         * @param {UpdateCourseEventDto} updateCourseEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseEvent(courseId: number, courseEventId: number, updateCourseEventDto: UpdateCourseEventDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateCourseEvent(courseId, courseEventId, updateCourseEventDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoursesEventsApi - object-oriented interface
 * @export
 * @class CoursesEventsApi
 * @extends {BaseAPI}
 */
export class CoursesEventsApi extends BaseAPI {
    /**
     * 
     * @param {number} courseId 
     * @param {CreateCourseEventDto} createCourseEventDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesEventsApi
     */
    public createCourseEvent(courseId: number, createCourseEventDto: CreateCourseEventDto, options?: AxiosRequestConfig) {
        return CoursesEventsApiFp(this.configuration).createCourseEvent(courseId, createCourseEventDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} courseEventId 
     * @param {any} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesEventsApi
     */
    public deleteCourseEvent(courseEventId: number, courseId: any, options?: AxiosRequestConfig) {
        return CoursesEventsApiFp(this.configuration).deleteCourseEvent(courseEventId, courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} courseId 
     * @param {number} courseEventId 
     * @param {UpdateCourseEventDto} updateCourseEventDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesEventsApi
     */
    public updateCourseEvent(courseId: number, courseEventId: number, updateCourseEventDto: UpdateCourseEventDto, options?: AxiosRequestConfig) {
        return CoursesEventsApiFp(this.configuration).updateCourseEvent(courseId, courseEventId, updateCourseEventDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CoursesInterviewsApi - axios parameter creator
 * @export
 */
export const CoursesInterviewsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {number} interviewId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableStudents: async (courseId: number, interviewId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getAvailableStudents', 'courseId', courseId)
            // verify required parameter 'interviewId' is not null or undefined
            assertParamExists('getAvailableStudents', 'interviewId', interviewId)
            const localVarPath = `/courses/{courseId}/interviews/{interviewId}/students/available`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"interviewId"}}`, encodeURIComponent(String(interviewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} interviewId 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterview: async (interviewId: number, courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'interviewId' is not null or undefined
            assertParamExists('getInterview', 'interviewId', interviewId)
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getInterview', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/interviews/{interviewId}`
                .replace(`{${"interviewId"}}`, encodeURIComponent(String(interviewId)))
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterviews: async (courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getInterviews', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/interviews`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoursesInterviewsApi - functional programming interface
 * @export
 */
export const CoursesInterviewsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoursesInterviewsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {number} interviewId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableStudents(courseId: number, interviewId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AvailableStudentDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableStudents(courseId, interviewId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} interviewId 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInterview(interviewId: number, courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterviewDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInterview(interviewId, courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInterviews(courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InterviewDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInterviews(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CoursesInterviewsApi - factory interface
 * @export
 */
export const CoursesInterviewsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoursesInterviewsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {number} interviewId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableStudents(courseId: number, interviewId: number, options?: any): AxiosPromise<Array<AvailableStudentDto>> {
            return localVarFp.getAvailableStudents(courseId, interviewId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} interviewId 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterview(interviewId: number, courseId: number, options?: any): AxiosPromise<InterviewDto> {
            return localVarFp.getInterview(interviewId, courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterviews(courseId: number, options?: any): AxiosPromise<Array<InterviewDto>> {
            return localVarFp.getInterviews(courseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoursesInterviewsApi - object-oriented interface
 * @export
 * @class CoursesInterviewsApi
 * @extends {BaseAPI}
 */
export class CoursesInterviewsApi extends BaseAPI {
    /**
     * 
     * @param {number} courseId 
     * @param {number} interviewId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesInterviewsApi
     */
    public getAvailableStudents(courseId: number, interviewId: number, options?: AxiosRequestConfig) {
        return CoursesInterviewsApiFp(this.configuration).getAvailableStudents(courseId, interviewId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} interviewId 
     * @param {number} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesInterviewsApi
     */
    public getInterview(interviewId: number, courseId: number, options?: AxiosRequestConfig) {
        return CoursesInterviewsApiFp(this.configuration).getInterview(interviewId, courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesInterviewsApi
     */
    public getInterviews(courseId: number, options?: AxiosRequestConfig) {
        return CoursesInterviewsApiFp(this.configuration).getInterviews(courseId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CoursesScheduleApi - axios parameter creator
 * @export
 */
export const CoursesScheduleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {CourseCopyFromDto} courseCopyFromDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copySchedule: async (courseId: number, courseCopyFromDto: CourseCopyFromDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('copySchedule', 'courseId', courseId)
            // verify required parameter 'courseCopyFromDto' is not null or undefined
            assertParamExists('copySchedule', 'courseCopyFromDto', courseCopyFromDto)
            const localVarPath = `/courses/{courseId}/schedule/copy`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(courseCopyFromDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedule: async (courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getSchedule', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/schedule`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoursesScheduleApi - functional programming interface
 * @export
 */
export const CoursesScheduleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoursesScheduleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {CourseCopyFromDto} courseCopyFromDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copySchedule(courseId: number, courseCopyFromDto: CourseCopyFromDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.copySchedule(courseId, courseCopyFromDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchedule(courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CourseScheduleItemDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchedule(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CoursesScheduleApi - factory interface
 * @export
 */
export const CoursesScheduleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoursesScheduleApiFp(configuration)
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {CourseCopyFromDto} courseCopyFromDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copySchedule(courseId: number, courseCopyFromDto: CourseCopyFromDto, options?: any): AxiosPromise<void> {
            return localVarFp.copySchedule(courseId, courseCopyFromDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedule(courseId: number, options?: any): AxiosPromise<Array<CourseScheduleItemDto>> {
            return localVarFp.getSchedule(courseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoursesScheduleApi - object-oriented interface
 * @export
 * @class CoursesScheduleApi
 * @extends {BaseAPI}
 */
export class CoursesScheduleApi extends BaseAPI {
    /**
     * 
     * @param {number} courseId 
     * @param {CourseCopyFromDto} courseCopyFromDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesScheduleApi
     */
    public copySchedule(courseId: number, courseCopyFromDto: CourseCopyFromDto, options?: AxiosRequestConfig) {
        return CoursesScheduleApiFp(this.configuration).copySchedule(courseId, courseCopyFromDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesScheduleApi
     */
    public getSchedule(courseId: number, options?: AxiosRequestConfig) {
        return CoursesScheduleApiFp(this.configuration).getSchedule(courseId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CoursesScheduleIcalApi - axios parameter creator
 * @export
 */
export const CoursesScheduleIcalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {string} token 
         * @param {string} timezone 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleICalendar: async (courseId: number, token: string, timezone: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getScheduleICalendar', 'courseId', courseId)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getScheduleICalendar', 'token', token)
            // verify required parameter 'timezone' is not null or undefined
            assertParamExists('getScheduleICalendar', 'timezone', timezone)
            const localVarPath = `/courses/{courseId}/icalendar/{token}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleICalendarToken: async (courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getScheduleICalendarToken', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/icalendar/token`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoursesScheduleIcalApi - functional programming interface
 * @export
 */
export const CoursesScheduleIcalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoursesScheduleIcalApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {string} token 
         * @param {string} timezone 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScheduleICalendar(courseId: number, token: string, timezone: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScheduleICalendar(courseId, token, timezone, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScheduleICalendarToken(courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseScheduleTokenDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScheduleICalendarToken(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CoursesScheduleIcalApi - factory interface
 * @export
 */
export const CoursesScheduleIcalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoursesScheduleIcalApiFp(configuration)
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {string} token 
         * @param {string} timezone 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleICalendar(courseId: number, token: string, timezone: string, options?: any): AxiosPromise<string> {
            return localVarFp.getScheduleICalendar(courseId, token, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleICalendarToken(courseId: number, options?: any): AxiosPromise<CourseScheduleTokenDto> {
            return localVarFp.getScheduleICalendarToken(courseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoursesScheduleIcalApi - object-oriented interface
 * @export
 * @class CoursesScheduleIcalApi
 * @extends {BaseAPI}
 */
export class CoursesScheduleIcalApi extends BaseAPI {
    /**
     * 
     * @param {number} courseId 
     * @param {string} token 
     * @param {string} timezone 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesScheduleIcalApi
     */
    public getScheduleICalendar(courseId: number, token: string, timezone: string, options?: AxiosRequestConfig) {
        return CoursesScheduleIcalApiFp(this.configuration).getScheduleICalendar(courseId, token, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesScheduleIcalApi
     */
    public getScheduleICalendarToken(courseId: number, options?: AxiosRequestConfig) {
        return CoursesScheduleIcalApiFp(this.configuration).getScheduleICalendarToken(courseId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CoursesTaskSolutionsApi - axios parameter creator
 * @export
 */
export const CoursesTaskSolutionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {number} courseTaskId 
         * @param {SaveTaskSolutionDto} saveTaskSolutionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskSolution: async (courseId: number, courseTaskId: number, saveTaskSolutionDto: SaveTaskSolutionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('createTaskSolution', 'courseId', courseId)
            // verify required parameter 'courseTaskId' is not null or undefined
            assertParamExists('createTaskSolution', 'courseTaskId', courseTaskId)
            // verify required parameter 'saveTaskSolutionDto' is not null or undefined
            assertParamExists('createTaskSolution', 'saveTaskSolutionDto', saveTaskSolutionDto)
            const localVarPath = `/courses/{courseId}/tasks/{courseTaskId}/solutions`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"courseTaskId"}}`, encodeURIComponent(String(courseTaskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveTaskSolutionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoursesTaskSolutionsApi - functional programming interface
 * @export
 */
export const CoursesTaskSolutionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoursesTaskSolutionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {number} courseTaskId 
         * @param {SaveTaskSolutionDto} saveTaskSolutionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTaskSolution(courseId: number, courseTaskId: number, saveTaskSolutionDto: SaveTaskSolutionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSolutionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTaskSolution(courseId, courseTaskId, saveTaskSolutionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CoursesTaskSolutionsApi - factory interface
 * @export
 */
export const CoursesTaskSolutionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoursesTaskSolutionsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {number} courseTaskId 
         * @param {SaveTaskSolutionDto} saveTaskSolutionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskSolution(courseId: number, courseTaskId: number, saveTaskSolutionDto: SaveTaskSolutionDto, options?: any): AxiosPromise<TaskSolutionDto> {
            return localVarFp.createTaskSolution(courseId, courseTaskId, saveTaskSolutionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoursesTaskSolutionsApi - object-oriented interface
 * @export
 * @class CoursesTaskSolutionsApi
 * @extends {BaseAPI}
 */
export class CoursesTaskSolutionsApi extends BaseAPI {
    /**
     * 
     * @param {number} courseId 
     * @param {number} courseTaskId 
     * @param {SaveTaskSolutionDto} saveTaskSolutionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesTaskSolutionsApi
     */
    public createTaskSolution(courseId: number, courseTaskId: number, saveTaskSolutionDto: SaveTaskSolutionDto, options?: AxiosRequestConfig) {
        return CoursesTaskSolutionsApiFp(this.configuration).createTaskSolution(courseId, courseTaskId, saveTaskSolutionDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CoursesTasksApi - axios parameter creator
 * @export
 */
export const CoursesTasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {CreateCourseTaskDto} createCourseTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseTask: async (courseId: number, createCourseTaskDto: CreateCourseTaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('createCourseTask', 'courseId', courseId)
            // verify required parameter 'createCourseTaskDto' is not null or undefined
            assertParamExists('createCourseTask', 'createCourseTaskDto', createCourseTaskDto)
            const localVarPath = `/courses/{courseId}/tasks`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCourseTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} courseId 
         * @param {number} courseTaskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseTask: async (courseId: number, courseTaskId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('deleteCourseTask', 'courseId', courseId)
            // verify required parameter 'courseTaskId' is not null or undefined
            assertParamExists('deleteCourseTask', 'courseTaskId', courseTaskId)
            const localVarPath = `/courses/{courseId}/tasks/{courseTaskId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"courseTaskId"}}`, encodeURIComponent(String(courseTaskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} courseId 
         * @param {number} courseTaskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseTask: async (courseId: number, courseTaskId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getCourseTask', 'courseId', courseId)
            // verify required parameter 'courseTaskId' is not null or undefined
            assertParamExists('getCourseTask', 'courseTaskId', courseTaskId)
            const localVarPath = `/courses/{courseId}/tasks/{courseTaskId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"courseTaskId"}}`, encodeURIComponent(String(courseTaskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} courseId 
         * @param {'started' | 'inprogress' | 'finished'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseTasks: async (courseId: number, status?: 'started' | 'inprogress' | 'finished', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getCourseTasks', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/tasks`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseTasksDetailed: async (courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getCourseTasksDetailed', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/tasks/detailed`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} courseId 
         * @param {number} pageSize 
         * @param {number} current 
         * @param {string} [orderBy] 
         * @param {string} [orderDirection] 
         * @param {string} [checker] 
         * @param {string} [student] 
         * @param {string} [url] 
         * @param {string} [task] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrossCheckPairs: async (courseId: number, pageSize: number, current: number, orderBy?: string, orderDirection?: string, checker?: string, student?: string, url?: string, task?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getCrossCheckPairs', 'courseId', courseId)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getCrossCheckPairs', 'pageSize', pageSize)
            // verify required parameter 'current' is not null or undefined
            assertParamExists('getCrossCheckPairs', 'current', current)
            const localVarPath = `/courses/{courseId}/cross-checks/pairs`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (checker !== undefined) {
                localVarQueryParameter['checker'] = checker;
            }

            if (student !== undefined) {
                localVarQueryParameter['student'] = student;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }

            if (task !== undefined) {
                localVarQueryParameter['task'] = task;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CheckTasksDeadlineDto} checkTasksDeadlineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyTasksDeadlines: async (checkTasksDeadlineDto: CheckTasksDeadlineDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkTasksDeadlineDto' is not null or undefined
            assertParamExists('notifyTasksDeadlines', 'checkTasksDeadlineDto', checkTasksDeadlineDto)
            const localVarPath = `/tasks/notify/changes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkTasksDeadlineDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} courseId 
         * @param {number} courseTaskId 
         * @param {UpdateCourseTaskDto} updateCourseTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseTask: async (courseId: number, courseTaskId: number, updateCourseTaskDto: UpdateCourseTaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('updateCourseTask', 'courseId', courseId)
            // verify required parameter 'courseTaskId' is not null or undefined
            assertParamExists('updateCourseTask', 'courseTaskId', courseTaskId)
            // verify required parameter 'updateCourseTaskDto' is not null or undefined
            assertParamExists('updateCourseTask', 'updateCourseTaskDto', updateCourseTaskDto)
            const localVarPath = `/courses/{courseId}/tasks/{courseTaskId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"courseTaskId"}}`, encodeURIComponent(String(courseTaskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCourseTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoursesTasksApi - functional programming interface
 * @export
 */
export const CoursesTasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoursesTasksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {CreateCourseTaskDto} createCourseTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCourseTask(courseId: number, createCourseTaskDto: CreateCourseTaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseTaskDetailedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCourseTask(courseId, createCourseTaskDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} courseId 
         * @param {number} courseTaskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCourseTask(courseId: number, courseTaskId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCourseTask(courseId, courseTaskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} courseId 
         * @param {number} courseTaskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseTask(courseId: number, courseTaskId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseTaskDetailedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseTask(courseId, courseTaskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} courseId 
         * @param {'started' | 'inprogress' | 'finished'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseTasks(courseId: number, status?: 'started' | 'inprogress' | 'finished', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CourseTaskDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseTasks(courseId, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseTasksDetailed(courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CourseTaskDetailedDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseTasksDetailed(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} courseId 
         * @param {number} pageSize 
         * @param {number} current 
         * @param {string} [orderBy] 
         * @param {string} [orderDirection] 
         * @param {string} [checker] 
         * @param {string} [student] 
         * @param {string} [url] 
         * @param {string} [task] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCrossCheckPairs(courseId: number, pageSize: number, current: number, orderBy?: string, orderDirection?: string, checker?: string, student?: string, url?: string, task?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrossCheckPairResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCrossCheckPairs(courseId, pageSize, current, orderBy, orderDirection, checker, student, url, task, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CheckTasksDeadlineDto} checkTasksDeadlineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyTasksDeadlines(checkTasksDeadlineDto: CheckTasksDeadlineDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyTasksDeadlines(checkTasksDeadlineDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} courseId 
         * @param {number} courseTaskId 
         * @param {UpdateCourseTaskDto} updateCourseTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCourseTask(courseId: number, courseTaskId: number, updateCourseTaskDto: UpdateCourseTaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseTaskDetailedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCourseTask(courseId, courseTaskId, updateCourseTaskDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CoursesTasksApi - factory interface
 * @export
 */
export const CoursesTasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoursesTasksApiFp(configuration)
    return {
        /**
         * 
         * @param {number} courseId 
         * @param {CreateCourseTaskDto} createCourseTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseTask(courseId: number, createCourseTaskDto: CreateCourseTaskDto, options?: any): AxiosPromise<CourseTaskDetailedDto> {
            return localVarFp.createCourseTask(courseId, createCourseTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} courseId 
         * @param {number} courseTaskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseTask(courseId: number, courseTaskId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCourseTask(courseId, courseTaskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} courseId 
         * @param {number} courseTaskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseTask(courseId: number, courseTaskId: number, options?: any): AxiosPromise<CourseTaskDetailedDto> {
            return localVarFp.getCourseTask(courseId, courseTaskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} courseId 
         * @param {'started' | 'inprogress' | 'finished'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseTasks(courseId: number, status?: 'started' | 'inprogress' | 'finished', options?: any): AxiosPromise<Array<CourseTaskDto>> {
            return localVarFp.getCourseTasks(courseId, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseTasksDetailed(courseId: number, options?: any): AxiosPromise<Array<CourseTaskDetailedDto>> {
            return localVarFp.getCourseTasksDetailed(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} courseId 
         * @param {number} pageSize 
         * @param {number} current 
         * @param {string} [orderBy] 
         * @param {string} [orderDirection] 
         * @param {string} [checker] 
         * @param {string} [student] 
         * @param {string} [url] 
         * @param {string} [task] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrossCheckPairs(courseId: number, pageSize: number, current: number, orderBy?: string, orderDirection?: string, checker?: string, student?: string, url?: string, task?: string, options?: any): AxiosPromise<CrossCheckPairResponseDto> {
            return localVarFp.getCrossCheckPairs(courseId, pageSize, current, orderBy, orderDirection, checker, student, url, task, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CheckTasksDeadlineDto} checkTasksDeadlineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyTasksDeadlines(checkTasksDeadlineDto: CheckTasksDeadlineDto, options?: any): AxiosPromise<void> {
            return localVarFp.notifyTasksDeadlines(checkTasksDeadlineDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} courseId 
         * @param {number} courseTaskId 
         * @param {UpdateCourseTaskDto} updateCourseTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseTask(courseId: number, courseTaskId: number, updateCourseTaskDto: UpdateCourseTaskDto, options?: any): AxiosPromise<CourseTaskDetailedDto> {
            return localVarFp.updateCourseTask(courseId, courseTaskId, updateCourseTaskDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoursesTasksApi - object-oriented interface
 * @export
 * @class CoursesTasksApi
 * @extends {BaseAPI}
 */
export class CoursesTasksApi extends BaseAPI {
    /**
     * 
     * @param {number} courseId 
     * @param {CreateCourseTaskDto} createCourseTaskDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesTasksApi
     */
    public createCourseTask(courseId: number, createCourseTaskDto: CreateCourseTaskDto, options?: AxiosRequestConfig) {
        return CoursesTasksApiFp(this.configuration).createCourseTask(courseId, createCourseTaskDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} courseId 
     * @param {number} courseTaskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesTasksApi
     */
    public deleteCourseTask(courseId: number, courseTaskId: number, options?: AxiosRequestConfig) {
        return CoursesTasksApiFp(this.configuration).deleteCourseTask(courseId, courseTaskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} courseId 
     * @param {number} courseTaskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesTasksApi
     */
    public getCourseTask(courseId: number, courseTaskId: number, options?: AxiosRequestConfig) {
        return CoursesTasksApiFp(this.configuration).getCourseTask(courseId, courseTaskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} courseId 
     * @param {'started' | 'inprogress' | 'finished'} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesTasksApi
     */
    public getCourseTasks(courseId: number, status?: 'started' | 'inprogress' | 'finished', options?: AxiosRequestConfig) {
        return CoursesTasksApiFp(this.configuration).getCourseTasks(courseId, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesTasksApi
     */
    public getCourseTasksDetailed(courseId: number, options?: AxiosRequestConfig) {
        return CoursesTasksApiFp(this.configuration).getCourseTasksDetailed(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} courseId 
     * @param {number} pageSize 
     * @param {number} current 
     * @param {string} [orderBy] 
     * @param {string} [orderDirection] 
     * @param {string} [checker] 
     * @param {string} [student] 
     * @param {string} [url] 
     * @param {string} [task] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesTasksApi
     */
    public getCrossCheckPairs(courseId: number, pageSize: number, current: number, orderBy?: string, orderDirection?: string, checker?: string, student?: string, url?: string, task?: string, options?: AxiosRequestConfig) {
        return CoursesTasksApiFp(this.configuration).getCrossCheckPairs(courseId, pageSize, current, orderBy, orderDirection, checker, student, url, task, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CheckTasksDeadlineDto} checkTasksDeadlineDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesTasksApi
     */
    public notifyTasksDeadlines(checkTasksDeadlineDto: CheckTasksDeadlineDto, options?: AxiosRequestConfig) {
        return CoursesTasksApiFp(this.configuration).notifyTasksDeadlines(checkTasksDeadlineDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} courseId 
     * @param {number} courseTaskId 
     * @param {UpdateCourseTaskDto} updateCourseTaskDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesTasksApi
     */
    public updateCourseTask(courseId: number, courseTaskId: number, updateCourseTaskDto: UpdateCourseTaskDto, options?: AxiosRequestConfig) {
        return CoursesTasksApiFp(this.configuration).updateCourseTask(courseId, courseTaskId, updateCourseTaskDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DisciplinesApi - axios parameter creator
 * @export
 */
export const DisciplinesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateDisciplineDto} createDisciplineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiscipline: async (createDisciplineDto: CreateDisciplineDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDisciplineDto' is not null or undefined
            assertParamExists('createDiscipline', 'createDisciplineDto', createDisciplineDto)
            const localVarPath = `/disciplines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDisciplineDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscipline: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDiscipline', 'id', id)
            const localVarPath = `/disciplines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisciplines: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/disciplines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateDisciplineDto} updateDisciplineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDiscipline: async (id: number, updateDisciplineDto: UpdateDisciplineDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDiscipline', 'id', id)
            // verify required parameter 'updateDisciplineDto' is not null or undefined
            assertParamExists('updateDiscipline', 'updateDisciplineDto', updateDisciplineDto)
            const localVarPath = `/disciplines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDisciplineDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DisciplinesApi - functional programming interface
 * @export
 */
export const DisciplinesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DisciplinesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateDisciplineDto} createDisciplineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDiscipline(createDisciplineDto: CreateDisciplineDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisciplineDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDiscipline(createDisciplineDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDiscipline(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDiscipline(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDisciplines(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DisciplineDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDisciplines(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateDisciplineDto} updateDisciplineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDiscipline(id: number, updateDisciplineDto: UpdateDisciplineDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisciplineDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDiscipline(id, updateDisciplineDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DisciplinesApi - factory interface
 * @export
 */
export const DisciplinesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DisciplinesApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateDisciplineDto} createDisciplineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiscipline(createDisciplineDto: CreateDisciplineDto, options?: any): AxiosPromise<DisciplineDto> {
            return localVarFp.createDiscipline(createDisciplineDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscipline(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDiscipline(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisciplines(options?: any): AxiosPromise<Array<DisciplineDto>> {
            return localVarFp.getDisciplines(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateDisciplineDto} updateDisciplineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDiscipline(id: number, updateDisciplineDto: UpdateDisciplineDto, options?: any): AxiosPromise<DisciplineDto> {
            return localVarFp.updateDiscipline(id, updateDisciplineDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DisciplinesApi - object-oriented interface
 * @export
 * @class DisciplinesApi
 * @extends {BaseAPI}
 */
export class DisciplinesApi extends BaseAPI {
    /**
     * 
     * @param {CreateDisciplineDto} createDisciplineDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisciplinesApi
     */
    public createDiscipline(createDisciplineDto: CreateDisciplineDto, options?: AxiosRequestConfig) {
        return DisciplinesApiFp(this.configuration).createDiscipline(createDisciplineDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisciplinesApi
     */
    public deleteDiscipline(id: number, options?: AxiosRequestConfig) {
        return DisciplinesApiFp(this.configuration).deleteDiscipline(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisciplinesApi
     */
    public getDisciplines(options?: AxiosRequestConfig) {
        return DisciplinesApiFp(this.configuration).getDisciplines(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UpdateDisciplineDto} updateDisciplineDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisciplinesApi
     */
    public updateDiscipline(id: number, updateDisciplineDto: UpdateDisciplineDto, options?: AxiosRequestConfig) {
        return DisciplinesApiFp(this.configuration).updateDiscipline(id, updateDisciplineDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DiscordServersApi - axios parameter creator
 * @export
 */
export const DiscordServersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateDiscordServerDto} createDiscordServerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiscordServer: async (createDiscordServerDto: CreateDiscordServerDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDiscordServerDto' is not null or undefined
            assertParamExists('createDiscordServer', 'createDiscordServerDto', createDiscordServerDto)
            const localVarPath = `/discord-servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDiscordServerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscordServer: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDiscordServer', 'id', id)
            const localVarPath = `/discord-servers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscordServers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/discord-servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateDiscordServerDto} updateDiscordServerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDiscordServer: async (id: number, updateDiscordServerDto: UpdateDiscordServerDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDiscordServer', 'id', id)
            // verify required parameter 'updateDiscordServerDto' is not null or undefined
            assertParamExists('updateDiscordServer', 'updateDiscordServerDto', updateDiscordServerDto)
            const localVarPath = `/discord-servers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDiscordServerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiscordServersApi - functional programming interface
 * @export
 */
export const DiscordServersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DiscordServersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateDiscordServerDto} createDiscordServerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDiscordServer(createDiscordServerDto: CreateDiscordServerDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscordServerDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDiscordServer(createDiscordServerDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDiscordServer(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscordServerDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDiscordServer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDiscordServers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DiscordServerDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDiscordServers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateDiscordServerDto} updateDiscordServerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDiscordServer(id: number, updateDiscordServerDto: UpdateDiscordServerDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscordServerDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDiscordServer(id, updateDiscordServerDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DiscordServersApi - factory interface
 * @export
 */
export const DiscordServersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DiscordServersApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateDiscordServerDto} createDiscordServerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiscordServer(createDiscordServerDto: CreateDiscordServerDto, options?: any): AxiosPromise<DiscordServerDto> {
            return localVarFp.createDiscordServer(createDiscordServerDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscordServer(id: number, options?: any): AxiosPromise<DiscordServerDto> {
            return localVarFp.deleteDiscordServer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscordServers(options?: any): AxiosPromise<Array<DiscordServerDto>> {
            return localVarFp.getDiscordServers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateDiscordServerDto} updateDiscordServerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDiscordServer(id: number, updateDiscordServerDto: UpdateDiscordServerDto, options?: any): AxiosPromise<DiscordServerDto> {
            return localVarFp.updateDiscordServer(id, updateDiscordServerDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DiscordServersApi - object-oriented interface
 * @export
 * @class DiscordServersApi
 * @extends {BaseAPI}
 */
export class DiscordServersApi extends BaseAPI {
    /**
     * 
     * @param {CreateDiscordServerDto} createDiscordServerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscordServersApi
     */
    public createDiscordServer(createDiscordServerDto: CreateDiscordServerDto, options?: AxiosRequestConfig) {
        return DiscordServersApiFp(this.configuration).createDiscordServer(createDiscordServerDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscordServersApi
     */
    public deleteDiscordServer(id: number, options?: AxiosRequestConfig) {
        return DiscordServersApiFp(this.configuration).deleteDiscordServer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscordServersApi
     */
    public getDiscordServers(options?: AxiosRequestConfig) {
        return DiscordServersApiFp(this.configuration).getDiscordServers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UpdateDiscordServerDto} updateDiscordServerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscordServersApi
     */
    public updateDiscordServer(id: number, updateDiscordServerDto: UpdateDiscordServerDto, options?: AxiosRequestConfig) {
        return DiscordServersApiFp(this.configuration).updateDiscordServer(id, updateDiscordServerDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GratitudesApi - axios parameter creator
 * @export
 */
export const GratitudesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateGratitudeDto} createGratitudeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGratitude: async (createGratitudeDto: CreateGratitudeDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createGratitudeDto' is not null or undefined
            assertParamExists('createGratitude', 'createGratitudeDto', createGratitudeDto)
            const localVarPath = `/gratitudes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGratitudeDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBadges: async (courseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getBadges', 'courseId', courseId)
            const localVarPath = `/gratitudes/badges/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GratitudesApi - functional programming interface
 * @export
 */
export const GratitudesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GratitudesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateGratitudeDto} createGratitudeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGratitude(createGratitudeDto: CreateGratitudeDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GratitudeDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGratitude(createGratitudeDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBadges(courseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BadgeDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBadges(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GratitudesApi - factory interface
 * @export
 */
export const GratitudesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GratitudesApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateGratitudeDto} createGratitudeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGratitude(createGratitudeDto: CreateGratitudeDto, options?: any): AxiosPromise<GratitudeDto> {
            return localVarFp.createGratitude(createGratitudeDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBadges(courseId: number, options?: any): AxiosPromise<Array<BadgeDto>> {
            return localVarFp.getBadges(courseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GratitudesApi - object-oriented interface
 * @export
 * @class GratitudesApi
 * @extends {BaseAPI}
 */
export class GratitudesApi extends BaseAPI {
    /**
     * 
     * @param {CreateGratitudeDto} createGratitudeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GratitudesApi
     */
    public createGratitude(createGratitudeDto: CreateGratitudeDto, options?: AxiosRequestConfig) {
        return GratitudesApiFp(this.configuration).createGratitude(createGratitudeDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GratitudesApi
     */
    public getBadges(courseId: number, options?: AxiosRequestConfig) {
        return GratitudesApiFp(this.configuration).getBadges(courseId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MentorsApi - axios parameter creator
 * @export
 */
export const MentorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} mentorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMentorStudents: async (mentorId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mentorId' is not null or undefined
            assertParamExists('getMentorStudents', 'mentorId', mentorId)
            const localVarPath = `/mentors/{mentorId}/students`
                .replace(`{${"mentorId"}}`, encodeURIComponent(String(mentorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MentorsApi - functional programming interface
 * @export
 */
export const MentorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MentorsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} mentorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMentorStudents(mentorId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MentorStudentDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMentorStudents(mentorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MentorsApi - factory interface
 * @export
 */
export const MentorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MentorsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} mentorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMentorStudents(mentorId: number, options?: any): AxiosPromise<Array<MentorStudentDto>> {
            return localVarFp.getMentorStudents(mentorId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MentorsApi - object-oriented interface
 * @export
 * @class MentorsApi
 * @extends {BaseAPI}
 */
export class MentorsApi extends BaseAPI {
    /**
     * 
     * @param {number} mentorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MentorsApi
     */
    public getMentorStudents(mentorId: number, options?: AxiosRequestConfig) {
        return MentorsApiFp(this.configuration).getMentorStudents(mentorId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UpdateNotificationDto} updateNotificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotification: async (updateNotificationDto: UpdateNotificationDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateNotificationDto' is not null or undefined
            assertParamExists('createNotification', 'updateNotificationDto', updateNotificationDto)
            const localVarPath = `/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNotificationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotification: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteNotification', 'id', id)
            const localVarPath = `/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateNotificationDto} updateNotificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotification: async (updateNotificationDto: UpdateNotificationDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateNotificationDto' is not null or undefined
            assertParamExists('updateNotification', 'updateNotificationDto', updateNotificationDto)
            const localVarPath = `/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNotificationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UpdateNotificationDto} updateNotificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNotification(updateNotificationDto: UpdateNotificationDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNotification(updateNotificationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNotification(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNotification(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotifications(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotifications(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateNotificationDto} updateNotificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNotification(updateNotificationDto: UpdateNotificationDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNotification(updateNotificationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * 
         * @param {UpdateNotificationDto} updateNotificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotification(updateNotificationDto: UpdateNotificationDto, options?: any): AxiosPromise<NotificationDto> {
            return localVarFp.createNotification(updateNotificationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotification(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteNotification(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(options?: any): AxiosPromise<Array<NotificationDto>> {
            return localVarFp.getNotifications(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateNotificationDto} updateNotificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotification(updateNotificationDto: UpdateNotificationDto, options?: any): AxiosPromise<NotificationDto> {
            return localVarFp.updateNotification(updateNotificationDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * 
     * @param {UpdateNotificationDto} updateNotificationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public createNotification(updateNotificationDto: UpdateNotificationDto, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).createNotification(updateNotificationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public deleteNotification(id: string, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).deleteNotification(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public getNotifications(options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).getNotifications(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateNotificationDto} updateNotificationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public updateNotification(updateNotificationDto: UpdateNotificationDto, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).updateNotification(updateNotificationDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OpportunitiesApi - axios parameter creator
 * @export
 */
export const OpportunitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConsent: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/opportunities/consent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConsent: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/opportunities/consent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicants: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/opportunities/applicants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsent: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/opportunities/consent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicResume: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getPublicResume', 'uuid', uuid)
            const localVarPath = `/opportunities/public/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} githubId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResume: async (githubId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'githubId' is not null or undefined
            assertParamExists('getResume', 'githubId', githubId)
            const localVarPath = `/opportunities/{githubId}/resume`
                .replace(`{${"githubId"}}`, encodeURIComponent(String(githubId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OpportunitiesApi - functional programming interface
 * @export
 */
export const OpportunitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OpportunitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConsent(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConsent(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConsent(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConsent(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicants(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicantResumeDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicants(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConsent(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConsent(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicResume(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResumeDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicResume(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} githubId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResume(githubId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResumeDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResume(githubId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OpportunitiesApi - factory interface
 * @export
 */
export const OpportunitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OpportunitiesApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConsent(options?: any): AxiosPromise<ConsentDto> {
            return localVarFp.createConsent(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConsent(options?: any): AxiosPromise<ConsentDto> {
            return localVarFp.deleteConsent(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicants(options?: any): AxiosPromise<Array<ApplicantResumeDto>> {
            return localVarFp.getApplicants(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsent(options?: any): AxiosPromise<ConsentDto> {
            return localVarFp.getConsent(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicResume(uuid: string, options?: any): AxiosPromise<ResumeDto> {
            return localVarFp.getPublicResume(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} githubId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResume(githubId: string, options?: any): AxiosPromise<ResumeDto> {
            return localVarFp.getResume(githubId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OpportunitiesApi - object-oriented interface
 * @export
 * @class OpportunitiesApi
 * @extends {BaseAPI}
 */
export class OpportunitiesApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpportunitiesApi
     */
    public createConsent(options?: AxiosRequestConfig) {
        return OpportunitiesApiFp(this.configuration).createConsent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpportunitiesApi
     */
    public deleteConsent(options?: AxiosRequestConfig) {
        return OpportunitiesApiFp(this.configuration).deleteConsent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpportunitiesApi
     */
    public getApplicants(options?: AxiosRequestConfig) {
        return OpportunitiesApiFp(this.configuration).getApplicants(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpportunitiesApi
     */
    public getConsent(options?: AxiosRequestConfig) {
        return OpportunitiesApiFp(this.configuration).getConsent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpportunitiesApi
     */
    public getPublicResume(uuid: string, options?: AxiosRequestConfig) {
        return OpportunitiesApiFp(this.configuration).getPublicResume(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} githubId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpportunitiesApi
     */
    public getResume(githubId: string, options?: AxiosRequestConfig) {
        return OpportunitiesApiFp(this.configuration).getResume(githubId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProfileApi - axios parameter creator
 * @export
 */
export const ProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getProfile', 'username', username)
            const localVarPath = `/profile/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCourses: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUserCourses', 'username', username)
            const localVarPath = `/profile/{username}/courses`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ProfileInfoDto} profileInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileInfo: async (profileInfoDto: ProfileInfoDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileInfoDto' is not null or undefined
            assertParamExists('updateProfileInfo', 'profileInfoDto', profileInfoDto)
            const localVarPath = `/profile/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profileInfoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateProfileInfoDto} updateProfileInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileInfoFlat: async (updateProfileInfoDto: UpdateProfileInfoDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateProfileInfoDto' is not null or undefined
            assertParamExists('updateProfileInfoFlat', 'updateProfileInfoDto', updateProfileInfoDto)
            const localVarPath = `/profile/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProfileInfoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (updateUserDto: UpdateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('updateUser', 'updateUserDto', updateUserDto)
            const localVarPath = `/profile/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfile(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfile(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCourses(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProfileCourseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCourses(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ProfileInfoDto} profileInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfileInfo(profileInfoDto: ProfileInfoDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProfileInfo(profileInfoDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateProfileInfoDto} updateProfileInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfileInfoFlat(updateProfileInfoDto: UpdateProfileInfoDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProfileInfoFlat(updateProfileInfoDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(updateUserDto: UpdateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(updateUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileApiFp(configuration)
    return {
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(username: string, options?: any): AxiosPromise<ProfileDto> {
            return localVarFp.getProfile(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCourses(username: string, options?: any): AxiosPromise<Array<ProfileCourseDto>> {
            return localVarFp.getUserCourses(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ProfileInfoDto} profileInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileInfo(profileInfoDto: ProfileInfoDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateProfileInfo(profileInfoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateProfileInfoDto} updateProfileInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileInfoFlat(updateProfileInfoDto: UpdateProfileInfoDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateProfileInfoFlat(updateProfileInfoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(updateUserDto: UpdateUserDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateUser(updateUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
    /**
     * 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getProfile(username: string, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).getProfile(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getUserCourses(username: string, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).getUserCourses(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ProfileInfoDto} profileInfoDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public updateProfileInfo(profileInfoDto: ProfileInfoDto, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).updateProfileInfo(profileInfoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateProfileInfoDto} updateProfileInfoDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public updateProfileInfoFlat(updateProfileInfoDto: UpdateProfileInfoDto, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).updateProfileInfoFlat(updateProfileInfoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateUserDto} updateUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public updateUser(updateUserDto: UpdateUserDto, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).updateUser(updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RegistryApi - axios parameter creator
 * @export
 */
export const RegistryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} githubId 
         * @param {ApproveMentorDto} approveMentorDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveMentor: async (githubId: string, approveMentorDto: ApproveMentorDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'githubId' is not null or undefined
            assertParamExists('approveMentor', 'githubId', githubId)
            // verify required parameter 'approveMentorDto' is not null or undefined
            assertParamExists('approveMentor', 'approveMentorDto', approveMentorDto)
            const localVarPath = `/registry/mentor/{githubId}`
                .replace(`{${"githubId"}}`, encodeURIComponent(String(githubId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(approveMentorDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistryApi - functional programming interface
 * @export
 */
export const RegistryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegistryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} githubId 
         * @param {ApproveMentorDto} approveMentorDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveMentor(githubId: string, approveMentorDto: ApproveMentorDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveMentor(githubId, approveMentorDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RegistryApi - factory interface
 * @export
 */
export const RegistryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegistryApiFp(configuration)
    return {
        /**
         * 
         * @param {string} githubId 
         * @param {ApproveMentorDto} approveMentorDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveMentor(githubId: string, approveMentorDto: ApproveMentorDto, options?: any): AxiosPromise<void> {
            return localVarFp.approveMentor(githubId, approveMentorDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RegistryApi - object-oriented interface
 * @export
 * @class RegistryApi
 * @extends {BaseAPI}
 */
export class RegistryApi extends BaseAPI {
    /**
     * 
     * @param {string} githubId 
     * @param {ApproveMentorDto} approveMentorDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public approveMentor(githubId: string, approveMentorDto: ApproveMentorDto, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).approveMentor(githubId, approveMentorDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ScheduleApi - axios parameter creator
 * @export
 */
export const ScheduleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CheckScheduleChangesDto} checkScheduleChangesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyScheduleChanges: async (checkScheduleChangesDto: CheckScheduleChangesDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkScheduleChangesDto' is not null or undefined
            assertParamExists('notifyScheduleChanges', 'checkScheduleChangesDto', checkScheduleChangesDto)
            const localVarPath = `/schedule/notify/changes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkScheduleChangesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduleApi - functional programming interface
 * @export
 */
export const ScheduleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScheduleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CheckScheduleChangesDto} checkScheduleChangesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyScheduleChanges(checkScheduleChangesDto: CheckScheduleChangesDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyScheduleChanges(checkScheduleChangesDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ScheduleApi - factory interface
 * @export
 */
export const ScheduleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScheduleApiFp(configuration)
    return {
        /**
         * 
         * @param {CheckScheduleChangesDto} checkScheduleChangesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyScheduleChanges(checkScheduleChangesDto: CheckScheduleChangesDto, options?: any): AxiosPromise<void> {
            return localVarFp.notifyScheduleChanges(checkScheduleChangesDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScheduleApi - object-oriented interface
 * @export
 * @class ScheduleApi
 * @extends {BaseAPI}
 */
export class ScheduleApi extends BaseAPI {
    /**
     * 
     * @param {CheckScheduleChangesDto} checkScheduleChangesDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public notifyScheduleChanges(checkScheduleChangesDto: CheckScheduleChangesDto, options?: AxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).notifyScheduleChanges(checkScheduleChangesDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudentsApi - axios parameter creator
 * @export
 */
export const StudentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} studentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudent: async (studentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studentId' is not null or undefined
            assertParamExists('getStudent', 'studentId', studentId)
            const localVarPath = `/students/{studentId}`
                .replace(`{${"studentId"}}`, encodeURIComponent(String(studentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudentsApi - functional programming interface
 * @export
 */
export const StudentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} studentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudent(studentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudent(studentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StudentsApi - factory interface
 * @export
 */
export const StudentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudentsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} studentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudent(studentId: number, options?: any): AxiosPromise<StudentDto> {
            return localVarFp.getStudent(studentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudentsApi - object-oriented interface
 * @export
 * @class StudentsApi
 * @extends {BaseAPI}
 */
export class StudentsApi extends BaseAPI {
    /**
     * 
     * @param {number} studentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public getStudent(studentId: number, options?: AxiosRequestConfig) {
        return StudentsApiFp(this.configuration).getStudent(studentId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudentsFeedbacksApi - axios parameter creator
 * @export
 */
export const StudentsFeedbacksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} studentId 
         * @param {CreateStudentFeedbackDto} createStudentFeedbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudentFeedback: async (studentId: number, createStudentFeedbackDto: CreateStudentFeedbackDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studentId' is not null or undefined
            assertParamExists('createStudentFeedback', 'studentId', studentId)
            // verify required parameter 'createStudentFeedbackDto' is not null or undefined
            assertParamExists('createStudentFeedback', 'createStudentFeedbackDto', createStudentFeedbackDto)
            const localVarPath = `/students/{studentId}/feedbacks`
                .replace(`{${"studentId"}}`, encodeURIComponent(String(studentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStudentFeedbackDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} studentId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentFeedback: async (studentId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studentId' is not null or undefined
            assertParamExists('getStudentFeedback', 'studentId', studentId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStudentFeedback', 'id', id)
            const localVarPath = `/students/{studentId}/feedbacks/{id}`
                .replace(`{${"studentId"}}`, encodeURIComponent(String(studentId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} studentId 
         * @param {number} id 
         * @param {UpdateStudentFeedbackDto} updateStudentFeedbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStudentFeedback: async (studentId: number, id: number, updateStudentFeedbackDto: UpdateStudentFeedbackDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studentId' is not null or undefined
            assertParamExists('updateStudentFeedback', 'studentId', studentId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateStudentFeedback', 'id', id)
            // verify required parameter 'updateStudentFeedbackDto' is not null or undefined
            assertParamExists('updateStudentFeedback', 'updateStudentFeedbackDto', updateStudentFeedbackDto)
            const localVarPath = `/students/{studentId}/feedbacks/{id}`
                .replace(`{${"studentId"}}`, encodeURIComponent(String(studentId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStudentFeedbackDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudentsFeedbacksApi - functional programming interface
 * @export
 */
export const StudentsFeedbacksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudentsFeedbacksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} studentId 
         * @param {CreateStudentFeedbackDto} createStudentFeedbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStudentFeedback(studentId: number, createStudentFeedbackDto: CreateStudentFeedbackDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentFeedbackDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStudentFeedback(studentId, createStudentFeedbackDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} studentId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudentFeedback(studentId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentFeedbackDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudentFeedback(studentId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} studentId 
         * @param {number} id 
         * @param {UpdateStudentFeedbackDto} updateStudentFeedbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStudentFeedback(studentId: number, id: number, updateStudentFeedbackDto: UpdateStudentFeedbackDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentFeedbackDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStudentFeedback(studentId, id, updateStudentFeedbackDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StudentsFeedbacksApi - factory interface
 * @export
 */
export const StudentsFeedbacksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudentsFeedbacksApiFp(configuration)
    return {
        /**
         * 
         * @param {number} studentId 
         * @param {CreateStudentFeedbackDto} createStudentFeedbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudentFeedback(studentId: number, createStudentFeedbackDto: CreateStudentFeedbackDto, options?: any): AxiosPromise<StudentFeedbackDto> {
            return localVarFp.createStudentFeedback(studentId, createStudentFeedbackDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} studentId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudentFeedback(studentId: number, id: number, options?: any): AxiosPromise<StudentFeedbackDto> {
            return localVarFp.getStudentFeedback(studentId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} studentId 
         * @param {number} id 
         * @param {UpdateStudentFeedbackDto} updateStudentFeedbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStudentFeedback(studentId: number, id: number, updateStudentFeedbackDto: UpdateStudentFeedbackDto, options?: any): AxiosPromise<StudentFeedbackDto> {
            return localVarFp.updateStudentFeedback(studentId, id, updateStudentFeedbackDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudentsFeedbacksApi - object-oriented interface
 * @export
 * @class StudentsFeedbacksApi
 * @extends {BaseAPI}
 */
export class StudentsFeedbacksApi extends BaseAPI {
    /**
     * 
     * @param {number} studentId 
     * @param {CreateStudentFeedbackDto} createStudentFeedbackDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsFeedbacksApi
     */
    public createStudentFeedback(studentId: number, createStudentFeedbackDto: CreateStudentFeedbackDto, options?: AxiosRequestConfig) {
        return StudentsFeedbacksApiFp(this.configuration).createStudentFeedback(studentId, createStudentFeedbackDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} studentId 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsFeedbacksApi
     */
    public getStudentFeedback(studentId: number, id: number, options?: AxiosRequestConfig) {
        return StudentsFeedbacksApiFp(this.configuration).getStudentFeedback(studentId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} studentId 
     * @param {number} id 
     * @param {UpdateStudentFeedbackDto} updateStudentFeedbackDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsFeedbacksApi
     */
    public updateStudentFeedback(studentId: number, id: number, updateStudentFeedbackDto: UpdateStudentFeedbackDto, options?: AxiosRequestConfig) {
        return StudentsFeedbacksApiFp(this.configuration).updateStudentFeedback(studentId, id, updateStudentFeedbackDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudentsScoreApi - axios parameter creator
 * @export
 */
export const StudentsScoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} activeOnly 
         * @param {'rank' | 'totalScore' | 'crossCheckScore' | 'githubId' | 'name' | 'cityName' | 'mentor' | 'totalScoreChangeDate' | 'repositoryLastActivityDate'} orderBy 
         * @param {'asc' | 'null' | 'desc'} orderDirection 
         * @param {string} current 
         * @param {string} pageSize 
         * @param {number} courseId 
         * @param {string} [githubId] 
         * @param {string} [name] 
         * @param {string} [mentorGithubId] 
         * @param {string} [cityName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScore: async (activeOnly: string, orderBy: 'rank' | 'totalScore' | 'crossCheckScore' | 'githubId' | 'name' | 'cityName' | 'mentor' | 'totalScoreChangeDate' | 'repositoryLastActivityDate', orderDirection: 'asc' | 'null' | 'desc', current: string, pageSize: string, courseId: number, githubId?: string, name?: string, mentorGithubId?: string, cityName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activeOnly' is not null or undefined
            assertParamExists('getScore', 'activeOnly', activeOnly)
            // verify required parameter 'orderBy' is not null or undefined
            assertParamExists('getScore', 'orderBy', orderBy)
            // verify required parameter 'orderDirection' is not null or undefined
            assertParamExists('getScore', 'orderDirection', orderDirection)
            // verify required parameter 'current' is not null or undefined
            assertParamExists('getScore', 'current', current)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getScore', 'pageSize', pageSize)
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getScore', 'courseId', courseId)
            const localVarPath = `/course/{courseId}/students/score`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (activeOnly !== undefined) {
                localVarQueryParameter['activeOnly'] = activeOnly;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (githubId !== undefined) {
                localVarQueryParameter['githubId'] = githubId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (mentorGithubId !== undefined) {
                localVarQueryParameter['mentor.githubId'] = mentorGithubId;
            }

            if (cityName !== undefined) {
                localVarQueryParameter['cityName'] = cityName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudentsScoreApi - functional programming interface
 * @export
 */
export const StudentsScoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudentsScoreApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} activeOnly 
         * @param {'rank' | 'totalScore' | 'crossCheckScore' | 'githubId' | 'name' | 'cityName' | 'mentor' | 'totalScoreChangeDate' | 'repositoryLastActivityDate'} orderBy 
         * @param {'asc' | 'null' | 'desc'} orderDirection 
         * @param {string} current 
         * @param {string} pageSize 
         * @param {number} courseId 
         * @param {string} [githubId] 
         * @param {string} [name] 
         * @param {string} [mentorGithubId] 
         * @param {string} [cityName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScore(activeOnly: string, orderBy: 'rank' | 'totalScore' | 'crossCheckScore' | 'githubId' | 'name' | 'cityName' | 'mentor' | 'totalScoreChangeDate' | 'repositoryLastActivityDate', orderDirection: 'asc' | 'null' | 'desc', current: string, pageSize: string, courseId: number, githubId?: string, name?: string, mentorGithubId?: string, cityName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScoreDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScore(activeOnly, orderBy, orderDirection, current, pageSize, courseId, githubId, name, mentorGithubId, cityName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StudentsScoreApi - factory interface
 * @export
 */
export const StudentsScoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudentsScoreApiFp(configuration)
    return {
        /**
         * 
         * @param {string} activeOnly 
         * @param {'rank' | 'totalScore' | 'crossCheckScore' | 'githubId' | 'name' | 'cityName' | 'mentor' | 'totalScoreChangeDate' | 'repositoryLastActivityDate'} orderBy 
         * @param {'asc' | 'null' | 'desc'} orderDirection 
         * @param {string} current 
         * @param {string} pageSize 
         * @param {number} courseId 
         * @param {string} [githubId] 
         * @param {string} [name] 
         * @param {string} [mentorGithubId] 
         * @param {string} [cityName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScore(activeOnly: string, orderBy: 'rank' | 'totalScore' | 'crossCheckScore' | 'githubId' | 'name' | 'cityName' | 'mentor' | 'totalScoreChangeDate' | 'repositoryLastActivityDate', orderDirection: 'asc' | 'null' | 'desc', current: string, pageSize: string, courseId: number, githubId?: string, name?: string, mentorGithubId?: string, cityName?: string, options?: any): AxiosPromise<ScoreDto> {
            return localVarFp.getScore(activeOnly, orderBy, orderDirection, current, pageSize, courseId, githubId, name, mentorGithubId, cityName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudentsScoreApi - object-oriented interface
 * @export
 * @class StudentsScoreApi
 * @extends {BaseAPI}
 */
export class StudentsScoreApi extends BaseAPI {
    /**
     * 
     * @param {string} activeOnly 
     * @param {'rank' | 'totalScore' | 'crossCheckScore' | 'githubId' | 'name' | 'cityName' | 'mentor' | 'totalScoreChangeDate' | 'repositoryLastActivityDate'} orderBy 
     * @param {'asc' | 'null' | 'desc'} orderDirection 
     * @param {string} current 
     * @param {string} pageSize 
     * @param {number} courseId 
     * @param {string} [githubId] 
     * @param {string} [name] 
     * @param {string} [mentorGithubId] 
     * @param {string} [cityName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsScoreApi
     */
    public getScore(activeOnly: string, orderBy: 'rank' | 'totalScore' | 'crossCheckScore' | 'githubId' | 'name' | 'cityName' | 'mentor' | 'totalScoreChangeDate' | 'repositoryLastActivityDate', orderDirection: 'asc' | 'null' | 'desc', current: string, pageSize: string, courseId: number, githubId?: string, name?: string, mentorGithubId?: string, cityName?: string, options?: AxiosRequestConfig) {
        return StudentsScoreApiFp(this.configuration).getScore(activeOnly, orderBy, orderDirection, current, pageSize, courseId, githubId, name, mentorGithubId, cityName, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserGroupApi - axios parameter creator
 * @export
 */
export const UserGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateUserGroupDto} createUserGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserGroup: async (createUserGroupDto: CreateUserGroupDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserGroupDto' is not null or undefined
            assertParamExists('createUserGroup', 'createUserGroupDto', createUserGroupDto)
            const localVarPath = `/user-group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserGroupDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserGroup: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUserGroup', 'id', id)
            const localVarPath = `/user-group/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateUserGroupDto} updateUserGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserGroup: async (id: number, updateUserGroupDto: UpdateUserGroupDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserGroup', 'id', id)
            // verify required parameter 'updateUserGroupDto' is not null or undefined
            assertParamExists('updateUserGroup', 'updateUserGroupDto', updateUserGroupDto)
            const localVarPath = `/user-group/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserGroupDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserGroupApi - functional programming interface
 * @export
 */
export const UserGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserGroupApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateUserGroupDto} createUserGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserGroup(createUserGroupDto: CreateUserGroupDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGroupDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserGroup(createUserGroupDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserGroup(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGroupDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserGroups(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserGroupDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateUserGroupDto} updateUserGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserGroup(id: number, updateUserGroupDto: UpdateUserGroupDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGroupDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserGroup(id, updateUserGroupDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserGroupApi - factory interface
 * @export
 */
export const UserGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserGroupApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateUserGroupDto} createUserGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserGroup(createUserGroupDto: CreateUserGroupDto, options?: any): AxiosPromise<UserGroupDto> {
            return localVarFp.createUserGroup(createUserGroupDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserGroup(id: number, options?: any): AxiosPromise<UserGroupDto> {
            return localVarFp.deleteUserGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups(options?: any): AxiosPromise<Array<UserGroupDto>> {
            return localVarFp.getUserGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateUserGroupDto} updateUserGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserGroup(id: number, updateUserGroupDto: UpdateUserGroupDto, options?: any): AxiosPromise<UserGroupDto> {
            return localVarFp.updateUserGroup(id, updateUserGroupDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserGroupApi - object-oriented interface
 * @export
 * @class UserGroupApi
 * @extends {BaseAPI}
 */
export class UserGroupApi extends BaseAPI {
    /**
     * 
     * @param {CreateUserGroupDto} createUserGroupDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    public createUserGroup(createUserGroupDto: CreateUserGroupDto, options?: AxiosRequestConfig) {
        return UserGroupApiFp(this.configuration).createUserGroup(createUserGroupDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    public deleteUserGroup(id: number, options?: AxiosRequestConfig) {
        return UserGroupApiFp(this.configuration).deleteUserGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    public getUserGroups(options?: AxiosRequestConfig) {
        return UserGroupApiFp(this.configuration).getUserGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UpdateUserGroupDto} updateUserGroupDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    public updateUserGroup(id: number, updateUserGroupDto: UpdateUserGroupDto, options?: AxiosRequestConfig) {
        return UserGroupApiFp(this.configuration).updateUserGroup(id, updateUserGroupDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersNotificationsApi - axios parameter creator
 * @export
 */
export const UsersNotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotificationConnections: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/notifications/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotifications: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailConfirmationLink: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/notifications/confirmation/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SendUserNotificationDto} sendUserNotificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendNotification: async (sendUserNotificationDto: SendUserNotificationDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendUserNotificationDto' is not null or undefined
            assertParamExists('sendNotification', 'sendUserNotificationDto', sendUserNotificationDto)
            const localVarPath = `/users/notifications/send`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendUserNotificationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<UpdateNotificationUserSettingsDto>} updateNotificationUserSettingsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNotifications: async (updateNotificationUserSettingsDto: Array<UpdateNotificationUserSettingsDto>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateNotificationUserSettingsDto' is not null or undefined
            assertParamExists('updateUserNotifications', 'updateNotificationUserSettingsDto', updateNotificationUserSettingsDto)
            const localVarPath = `/users/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNotificationUserSettingsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpsertNotificationConnectionDto} upsertNotificationConnectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersNotificationsControllerCreateUserConnection: async (upsertNotificationConnectionDto: UpsertNotificationConnectionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'upsertNotificationConnectionDto' is not null or undefined
            assertParamExists('usersNotificationsControllerCreateUserConnection', 'upsertNotificationConnectionDto', upsertNotificationConnectionDto)
            const localVarPath = `/users/notifications/connection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertNotificationConnectionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NotificationConnectionExistsDto} notificationConnectionExistsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersNotificationsControllerFindConnection: async (notificationConnectionExistsDto: NotificationConnectionExistsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationConnectionExistsDto' is not null or undefined
            assertParamExists('usersNotificationsControllerFindConnection', 'notificationConnectionExistsDto', notificationConnectionExistsDto)
            const localVarPath = `/users/notifications/connection/find`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationConnectionExistsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersNotificationsApi - functional programming interface
 * @export
 */
export const UsersNotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersNotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserNotificationConnections(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationUserConnectionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserNotificationConnections(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserNotifications(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserNotificationsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserNotifications(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendEmailConfirmationLink(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendEmailConfirmationLink(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SendUserNotificationDto} sendUserNotificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendNotification(sendUserNotificationDto: SendUserNotificationDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendNotification(sendUserNotificationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<UpdateNotificationUserSettingsDto>} updateNotificationUserSettingsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserNotifications(updateNotificationUserSettingsDto: Array<UpdateNotificationUserSettingsDto>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UpdateNotificationUserSettingsDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserNotifications(updateNotificationUserSettingsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpsertNotificationConnectionDto} upsertNotificationConnectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersNotificationsControllerCreateUserConnection(upsertNotificationConnectionDto: UpsertNotificationConnectionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationConnectionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersNotificationsControllerCreateUserConnection(upsertNotificationConnectionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {NotificationConnectionExistsDto} notificationConnectionExistsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersNotificationsControllerFindConnection(notificationConnectionExistsDto: NotificationConnectionExistsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationConnectionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersNotificationsControllerFindConnection(notificationConnectionExistsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersNotificationsApi - factory interface
 * @export
 */
export const UsersNotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersNotificationsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotificationConnections(options?: any): AxiosPromise<NotificationUserConnectionsDto> {
            return localVarFp.getUserNotificationConnections(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotifications(options?: any): AxiosPromise<UserNotificationsDto> {
            return localVarFp.getUserNotifications(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailConfirmationLink(options?: any): AxiosPromise<void> {
            return localVarFp.sendEmailConfirmationLink(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SendUserNotificationDto} sendUserNotificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendNotification(sendUserNotificationDto: SendUserNotificationDto, options?: any): AxiosPromise<void> {
            return localVarFp.sendNotification(sendUserNotificationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<UpdateNotificationUserSettingsDto>} updateNotificationUserSettingsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNotifications(updateNotificationUserSettingsDto: Array<UpdateNotificationUserSettingsDto>, options?: any): AxiosPromise<Array<UpdateNotificationUserSettingsDto>> {
            return localVarFp.updateUserNotifications(updateNotificationUserSettingsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpsertNotificationConnectionDto} upsertNotificationConnectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersNotificationsControllerCreateUserConnection(upsertNotificationConnectionDto: UpsertNotificationConnectionDto, options?: any): AxiosPromise<NotificationConnectionDto> {
            return localVarFp.usersNotificationsControllerCreateUserConnection(upsertNotificationConnectionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {NotificationConnectionExistsDto} notificationConnectionExistsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersNotificationsControllerFindConnection(notificationConnectionExistsDto: NotificationConnectionExistsDto, options?: any): AxiosPromise<NotificationConnectionDto> {
            return localVarFp.usersNotificationsControllerFindConnection(notificationConnectionExistsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersNotificationsApi - object-oriented interface
 * @export
 * @class UsersNotificationsApi
 * @extends {BaseAPI}
 */
export class UsersNotificationsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersNotificationsApi
     */
    public getUserNotificationConnections(options?: AxiosRequestConfig) {
        return UsersNotificationsApiFp(this.configuration).getUserNotificationConnections(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersNotificationsApi
     */
    public getUserNotifications(options?: AxiosRequestConfig) {
        return UsersNotificationsApiFp(this.configuration).getUserNotifications(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersNotificationsApi
     */
    public sendEmailConfirmationLink(options?: AxiosRequestConfig) {
        return UsersNotificationsApiFp(this.configuration).sendEmailConfirmationLink(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SendUserNotificationDto} sendUserNotificationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersNotificationsApi
     */
    public sendNotification(sendUserNotificationDto: SendUserNotificationDto, options?: AxiosRequestConfig) {
        return UsersNotificationsApiFp(this.configuration).sendNotification(sendUserNotificationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<UpdateNotificationUserSettingsDto>} updateNotificationUserSettingsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersNotificationsApi
     */
    public updateUserNotifications(updateNotificationUserSettingsDto: Array<UpdateNotificationUserSettingsDto>, options?: AxiosRequestConfig) {
        return UsersNotificationsApiFp(this.configuration).updateUserNotifications(updateNotificationUserSettingsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpsertNotificationConnectionDto} upsertNotificationConnectionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersNotificationsApi
     */
    public usersNotificationsControllerCreateUserConnection(upsertNotificationConnectionDto: UpsertNotificationConnectionDto, options?: AxiosRequestConfig) {
        return UsersNotificationsApiFp(this.configuration).usersNotificationsControllerCreateUserConnection(upsertNotificationConnectionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {NotificationConnectionExistsDto} notificationConnectionExistsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersNotificationsApi
     */
    public usersNotificationsControllerFindConnection(notificationConnectionExistsDto: NotificationConnectionExistsDto, options?: AxiosRequestConfig) {
        return UsersNotificationsApiFp(this.configuration).usersNotificationsControllerFindConnection(notificationConnectionExistsDto, options).then((request) => request(this.axios, this.basePath));
    }
}


